<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>01 多维数组对象 - 迭代自己</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="iterateself" />
  <meta name="description" content="CHAPTER 4 NumPy Basics: Arrays and Vectorized Computation 在数值计算领域，说Numpy是python最重要的包也不为过。在numpy中有下面这些东西： ndarray, 一个有效的多维数组，能提供以数" />

  <meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.47.1" />


<link rel="canonical" href="http://iterate.site/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02-python/02data/02-numpy/01-%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">




<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<link href="/dist/even.min.css?v=3.2.0" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">




<meta property="og:title" content="01 多维数组对象" />
<meta property="og:description" content="CHAPTER 4 NumPy Basics: Arrays and Vectorized Computation 在数值计算领域，说Numpy是python最重要的包也不为过。在numpy中有下面这些东西： ndarray, 一个有效的多维数组，能提供以数" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://iterate.site/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02-python/02data/02-numpy/01-%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1/" /><meta property="article:published_time" content="2018-07-28T23:21:07&#43;00:00"/>
<meta property="article:modified_time" content="2018-07-28T23:21:07&#43;00:00"/>
<meta itemprop="name" content="01 多维数组对象">
<meta itemprop="description" content="CHAPTER 4 NumPy Basics: Arrays and Vectorized Computation 在数值计算领域，说Numpy是python最重要的包也不为过。在numpy中有下面这些东西： ndarray, 一个有效的多维数组，能提供以数">


<meta itemprop="datePublished" content="2018-07-28T23:21:07&#43;00:00" />
<meta itemprop="dateModified" content="2018-07-28T23:21:07&#43;00:00" />
<meta itemprop="wordCount" content="4364">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="01 多维数组对象"/>
<meta name="twitter:description" content="CHAPTER 4 NumPy Basics: Arrays and Vectorized Computation 在数值计算领域，说Numpy是python最重要的包也不为过。在numpy中有下面这些东西： ndarray, 一个有效的多维数组，能提供以数"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">iterate self</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">about</li>
      </a><a href="/catalog/">
        <li class="mobile-menu-item">目录</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">iterate self</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">about</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/catalog/">目录</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">01 多维数组对象</h1>

      <div class="post-meta">
        <span class="post-time"> 2018-07-28 </span>
        
        <span class="more-meta"> 4364 words </span>
        <span class="more-meta"> 9 mins read </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> times read </span>
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  
  <div class="post-toc-content">
    <nav id="TableOfContents">
<ul>
<li><a href="#chapter-4">CHAPTER 4</a></li>
<li><a href="#numpy-basics-arrays-and-vectorized-computation">NumPy Basics: Arrays and Vectorized Computation</a></li>
<li><a href="#4-1-the-numpy-ndarray-a-multidimensional-array-object-ndarray-多维数组对象">4.1 The NumPy ndarray: A Multidimensional Array Object（ndarray: 多维数组对象）</a></li>
<li><a href="#1-greating-ndarrays-创建n维数组">1 Greating ndarrays (创建n维数组)</a></li>
<li><a href="#2-data-types-for-ndarrays">2 Data Types for ndarrays</a></li>
<li><a href="#3-arithmetic-with-numpy-arrays-数组计算">3 Arithmetic with NumPy Arrays（数组计算）</a></li>
<li><a href="#4-basic-indexing-and-slicing-基本的索引和切片">4 Basic Indexing and Slicing（基本的索引和切片）</a>
<ul>
<li><a href="#indexing-with-slices-用切片索引">Indexing with slices（用切片索引）</a></li>
</ul></li>
<li><a href="#5-boolean-indexing-布尔索引">5 Boolean Indexing (布尔索引)</a></li>
<li><a href="#6-fancy-indexing-花式索引">6 Fancy Indexing(花式索引)</a></li>
<li><a href="#7-transposing-arrays-and-swapping-axes-数组转置和轴交换">7 Transposing Arrays and Swapping Axes（数组转置和轴交换）</a></li>
</ul>
</nav>
  </div>
</div>

    
    

    
    <div class="post-content">
      

<h1 id="chapter-4">CHAPTER 4</h1>

<h1 id="numpy-basics-arrays-and-vectorized-computation">NumPy Basics: Arrays and Vectorized Computation</h1>

<p>在数值计算领域，说Numpy是python最重要的包也不为过。在numpy中有下面这些东西：</p>

<ul>
<li><p>ndarray, 一个有效的多维数组，能提供以数组为导向的快速数值计算和灵活的广播功能（broadcasting）</p></li>

<li><p>便利的数学函数</p></li>

<li><p>用于读取/写入(reading/writing)数据到磁盘的便利工具</p></li>

<li><p>线性代数，随机数生成，傅里叶变换能力</p></li>

<li><p>可以用C API来写C，C++，或FORTRAN</p></li>
</ul>

<p>通过学习理解numpy中数组和数组导向计算，能帮我们理解pandas之类的工具。</p>

<h1 id="4-1-the-numpy-ndarray-a-multidimensional-array-object-ndarray-多维数组对象">4.1 The NumPy ndarray: A Multidimensional Array Object（ndarray: 多维数组对象）</h1>

<p>N-dimensional array object（n维数组对象）, or ndarray，这是numpy的关键特征。先来尝试一下，生成一个随机数组：</p>

<pre><code class="language-python">import numpy as np
</code></pre>

<pre><code class="language-python"># Generate some random data
data = np.random.randn(2, 3)
</code></pre>

<pre><code class="language-python">data
</code></pre>

<pre><code>array([[-0.35512366, -0.63779545,  0.14137933],
       [ 0.36642056,  0.30898139, -0.87040292]])
</code></pre>

<p>进行一些数学运算：</p>

<pre><code class="language-python">data * 10
</code></pre>

<pre><code>array([[-3.55123655, -6.37795453,  1.41379333],
       [ 3.66420556,  3.0898139 , -8.70402916]])
</code></pre>

<pre><code class="language-python">data + data
</code></pre>

<pre><code>array([[-0.71024731, -1.27559091,  0.28275867],
       [ 0.73284111,  0.61796278, -1.74080583]])
</code></pre>

<p>每一个数组都有一个shape，来表示维度大小。而dtype，用来表示data type：</p>

<pre><code class="language-python">data.shape
</code></pre>

<pre><code>(2, 3)
</code></pre>

<pre><code class="language-python">data.dtype
</code></pre>

<pre><code>dtype('float64')
</code></pre>

<h1 id="1-greating-ndarrays-创建n维数组">1 Greating ndarrays (创建n维数组)</h1>

<p>最简单的方法使用array函数，输入一个序列即可，比如list：</p>

<pre><code class="language-python">data1 = [6, 7.5, 8, 0, 1]
arr1 = np.array(data1)
arr1
</code></pre>

<pre><code>array([ 6. ,  7.5,  8. ,  0. ,  1. ])
</code></pre>

<p>嵌套序列能被转换为多维数组：</p>

<pre><code class="language-python">data2 = [[1, 2, 3, 4], [5, 6, 7, 8]]
arr2 = np.array(data2)
arr2
</code></pre>

<pre><code>array([[1, 2, 3, 4],
       [5, 6, 7, 8]])
</code></pre>

<p>因为data2是一个list of lists, 所以arr2维度为2。我们能用ndim和shape属性来确认一下：</p>

<pre><code class="language-python">arr2.ndim
</code></pre>

<pre><code>2
</code></pre>

<pre><code class="language-python">arr2.shape
</code></pre>

<pre><code>(2, 4)
</code></pre>

<p>除非主动声明，否则np.array会自动给data搭配适合的类型，并保存在dtype里：</p>

<pre><code class="language-python">arr1.dtype
</code></pre>

<pre><code>dtype('float64')
</code></pre>

<pre><code class="language-python">arr2.dtype
</code></pre>

<pre><code>dtype('int64')
</code></pre>

<p>除了np.array，还有一些其他函数能创建数组。比如zeros,ones,另外还可以在一个tuple里指定shape：</p>

<pre><code class="language-python">np.zeros(10)
</code></pre>

<pre><code>array([ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.])
</code></pre>

<pre><code class="language-python">np.zeros((3, 6))
</code></pre>

<pre><code>array([[ 0.,  0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.,  0.]])
</code></pre>

<pre><code class="language-python">np.empty((2, 3, 2))
</code></pre>

<pre><code>array([[[  0.00000000e+000,   0.00000000e+000],
        [  2.16538378e-314,   2.16514681e-314],
        [  2.16511832e-314,   2.16072529e-314]],

       [[  0.00000000e+000,   0.00000000e+000],
        [  2.14037397e-314,   6.36598737e-311],
        [  0.00000000e+000,   0.00000000e+000]]])
</code></pre>

<p>np.empty并不能保证返回所有是0的数组，某些情况下，会返回为初始化的垃圾数值，比如上面。</p>

<p>arange是一个数组版的python range函数：</p>

<pre><code class="language-python">np.arange(15)
</code></pre>

<pre><code>array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14])
</code></pre>

<p>这里是一些创建数组的函数：</p>

<p><img src="http://pacdb2bfr.bkt.clouddn.com/blog/image/180728/f24ijflHiH.png?imageslim" alt="mark" />
<img src="http://pacdb2bfr.bkt.clouddn.com/blog/image/180728/872LBA1Hgh.png?imageslim" alt="mark" /></p>

<h1 id="2-data-types-for-ndarrays">2 Data Types for ndarrays</h1>

<p>dtype保存数据的类型：</p>

<pre><code class="language-python">arr1 = np.array([1, 2, 3], dtype=np.float64)
</code></pre>

<pre><code class="language-python">arr2 = np.array([1, 2, 3], dtype=np.int32)
</code></pre>

<pre><code class="language-python">arr1.dtype
</code></pre>

<pre><code>dtype('float64')
</code></pre>

<pre><code class="language-python">arr2.dtype
</code></pre>

<pre><code>dtype('int32')
</code></pre>

<p>dtype才是numpy能灵活处理其他外界数据的原因。</p>

<p>类型表格：</p>

<p><img src="http://pacdb2bfr.bkt.clouddn.com/blog/image/180728/chCH8lgffF.png?imageslim" alt="mark" /></p>

<p><img src="http://pacdb2bfr.bkt.clouddn.com/blog/image/180728/2k2FJf2l83.png?imageslim" alt="mark" /></p>

<p>可以用 <code>astype</code> 来转换类型：</p>

<pre><code class="language-python">arr = np.array([1, 2, 3, 4, 5])
arr.dtype
</code></pre>

<pre><code>dtype('int64')
</code></pre>

<pre><code class="language-python">float_arr = arr.astype(np.float64)
float_arr.dtype
</code></pre>

<pre><code>dtype('float64')
</code></pre>

<p>上面是把int变为float。如果是把float变为int，小数点后的部分会被丢弃：</p>

<pre><code class="language-python">arr = np.array([3.7, -1.2, -2.6, 0.5, 12.9, 10.1])
arr
</code></pre>

<pre><code>array([  3.7,  -1.2,  -2.6,   0.5,  12.9,  10.1])
</code></pre>

<pre><code class="language-python">arr.astype(np.int32)
</code></pre>

<pre><code>array([ 3, -1, -2,  0, 12, 10], dtype=int32)
</code></pre>

<p>还可以用astype把string里的数字变为实际的数字：</p>

<pre><code class="language-python">numeric_strings = np.array(['1.25', '-9.6', '42'], dtype=np.string_)
numeric_strings
</code></pre>

<pre><code>array([b'1.25', b'-9.6', b'42'],
      dtype='|S4')
</code></pre>

<pre><code class="language-python">numeric_strings.astype(float)
</code></pre>

<pre><code>array([  1.25,  -9.6 ,  42.  ])
</code></pre>

<p>要十分注意<code>numpy.string_</code>类型，这种类型的长度是固定的，所以可能会直接截取部分输入而不给警告。</p>

<p>如果转换（casting）失败的话，会给出一个ValueError提示。</p>

<p>可以用其他数组的dtype直接来制定类型：</p>

<pre><code class="language-python">int_array = np.arange(10)

calibers = np.array([.22, .270, .357, .380, .44, .50], dtype=np.float64)
</code></pre>

<pre><code class="language-python">int_array.astype(calibers.dtype)
</code></pre>

<pre><code>array([ 0.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9.])
</code></pre>

<p>还可以利用类型的缩写，比如u4就代表unit32：</p>

<pre><code class="language-python">empty_unit32 = np.empty(8, dtype='u4')
empty_unit32
</code></pre>

<pre><code>array([0, 0, 0, 0, 0, 0, 0, 0], dtype=uint32)
</code></pre>

<p>记住，astype总是会返回一个新的数组</p>

<h1 id="3-arithmetic-with-numpy-arrays-数组计算">3 Arithmetic with NumPy Arrays（数组计算）</h1>

<p>数组之所以重要，是因为不用写for循环就能表达很多操作，这种特性叫做vectorization(向量化)。任何两个大小相等的数组之间的运算，都是element-wise（点对点）：</p>

<pre><code class="language-python">arr = np.array([[1., 2., 3.], [4., 5., 6.]])
</code></pre>

<pre><code class="language-python">arr
</code></pre>

<pre><code>array([[ 1.,  2.,  3.],
       [ 4.,  5.,  6.]])
</code></pre>

<pre><code class="language-python">arr * arr
</code></pre>

<pre><code>array([[  1.,   4.,   9.],
       [ 16.,  25.,  36.]])
</code></pre>

<pre><code class="language-python">arr - arr
</code></pre>

<pre><code>array([[ 0.,  0.,  0.],
       [ 0.,  0.,  0.]])
</code></pre>

<p>element-wise 我翻译为点对点，就是指两个数组的运算，在同一位置的元素间才会进行运算。</p>

<p>这种算数操作如果涉及标量（scalar）的话，会涉及到数组的每一个元素：</p>

<pre><code class="language-python">1 / arr
</code></pre>

<pre><code>array([[ 1.        ,  0.5       ,  0.33333333],
       [ 0.25      ,  0.2       ,  0.16666667]])
</code></pre>

<pre><code class="language-python">arr ** 0.5
</code></pre>

<pre><code>array([[ 1.        ,  1.41421356,  1.73205081],
       [ 2.        ,  2.23606798,  2.44948974]])
</code></pre>

<p>两个数组的比较会产生布尔数组：</p>

<pre><code class="language-python">arr2 = np.array([[0., 4., 1.], [7., 2., 12.]])
arr2
</code></pre>

<pre><code>array([[  0.,   4.,   1.],
       [  7.,   2.,  12.]])
</code></pre>

<pre><code class="language-python">arr2 &gt; arr
</code></pre>

<pre><code>array([[False,  True, False],
       [ True, False,  True]], dtype=bool)
</code></pre>

<h1 id="4-basic-indexing-and-slicing-基本的索引和切片">4 Basic Indexing and Slicing（基本的索引和切片）</h1>

<p>一维的我们之前已经在list部分用过了，没什么不同：</p>

<pre><code class="language-python">arr = np.arange(10)
arr
</code></pre>

<pre><code>array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
</code></pre>

<pre><code class="language-python">arr[5]
</code></pre>

<pre><code>5
</code></pre>

<pre><code class="language-python">arr[5:8]
</code></pre>

<pre><code>array([5, 6, 7])
</code></pre>

<pre><code class="language-python">arr[5:8] = 12
</code></pre>

<pre><code class="language-python">arr
</code></pre>

<pre><code>array([ 0,  1,  2,  3,  4, 12, 12, 12,  8,  9])
</code></pre>

<p>这里把12赋给<code>arr[5:8]</code>，其实用到了broadcasted（我觉得应该翻译为广式转变）。这里有一个比较重要的概念需要区分，python内建的list与numpy的array有个明显的区别，这里array的切片后的结果只是一个views（视图），用来代表原有array对应的元素，而不是创建了一个新的array。但list里的切片是产生了一个新的list：</p>

<pre><code class="language-python">arr_slice = arr[5:8]
arr_slice
</code></pre>

<pre><code>array([12, 12, 12])
</code></pre>

<p>如果我们改变arr_slice的值，会反映在原始的数组arr上：</p>

<pre><code class="language-python">arr_slice[1] = 12345
</code></pre>

<pre><code class="language-python">arr
</code></pre>

<pre><code>array([    0,     1,     2,     3,     4,    12, 12345,    12,     8,     9])
</code></pre>

<p><code>[:]</code>这个赋值给所有元素：</p>

<pre><code class="language-python">arr_slice[:] = 64
</code></pre>

<pre><code class="language-python">arr
</code></pre>

<pre><code>array([ 0,  1,  2,  3,  4, 64, 64, 64,  8,  9])
</code></pre>

<p>之所以这样设计是出于性能和内存的考虑，毕竟如果总是复制数据的话，会很影响运算时间。当然如果想要复制，可以使用copy()方法，比如<code>arr[5:8].copy()</code></p>

<p>在一个二维数组里，单一的索引指代的是一维的数组：</p>

<pre><code class="language-python">arr2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
arr2d[2]
</code></pre>

<pre><code>array([7, 8, 9])
</code></pre>

<p>有两种方式可以访问单一元素：</p>

<pre><code class="language-python">arr2d[0][2]
</code></pre>

<pre><code>3
</code></pre>

<pre><code class="language-python">arr2d[0, 2]
</code></pre>

<pre><code>3
</code></pre>

<p>我们可以把下图中的axis0看做row（行），把axis1看做column（列）：</p>

<p><img src="http://pacdb2bfr.bkt.clouddn.com/blog/image/180728/gH5CfDGcJ3.png?imageslim" alt="mark" /></p>

<p>对于多维数组，如果省略后面的索引，返回的将是一个低纬度的多维数组。比如下面一个2 x 2 x 3数组：</p>

<pre><code class="language-python">arr3d = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])
arr3d
</code></pre>

<pre><code>array([[[ 1,  2,  3],
        [ 4,  5,  6]],

       [[ 7,  8,  9],
        [10, 11, 12]]])
</code></pre>

<p>arr3d[0]是一个2x3数组：</p>

<pre><code class="language-python">arr3d[0]
</code></pre>

<pre><code>array([[1, 2, 3],
       [4, 5, 6]])
</code></pre>

<p>标量和数组都能赋给arr3d[0]:</p>

<pre><code class="language-python">old_values = arr3d[0].copy()

arr3d[0] = 42

arr3d
</code></pre>

<pre><code>array([[[42, 42, 42],
        [42, 42, 42]],

       [[ 7,  8,  9],
        [10, 11, 12]]])
</code></pre>

<pre><code class="language-python">arr3d[0] = old_values
arr3d
</code></pre>

<pre><code>array([[[ 1,  2,  3],
        [ 4,  5,  6]],

       [[ 7,  8,  9],
        [10, 11, 12]]])
</code></pre>

<p><code>arr3d[1, 0]</code>会给你一个(1, 0)的一维数组：</p>

<pre><code class="language-python">arr3d[1, 0]
</code></pre>

<pre><code>array([7, 8, 9])
</code></pre>

<p>上面的一步等于下面的两步：</p>

<pre><code class="language-python">x = arr3d[1]
x
</code></pre>

<pre><code>array([[ 7,  8,  9],
       [10, 11, 12]])
</code></pre>

<pre><code class="language-python">x[0]
</code></pre>

<pre><code>array([7, 8, 9])
</code></pre>

<p>一定要牢记这些切片后返回的数组都是views</p>

<h2 id="indexing-with-slices-用切片索引">Indexing with slices（用切片索引）</h2>

<p>一维的话和python里的list没什么差别：</p>

<pre><code class="language-python">arr
</code></pre>

<pre><code>array([ 0,  1,  2,  3,  4, 64, 64, 64,  8,  9])
</code></pre>

<pre><code class="language-python">arr[1:6]
</code></pre>

<pre><code>array([ 1,  2,  3,  4, 64])
</code></pre>

<p>二维的话，数组的切片有点不同：</p>

<pre><code class="language-python">arr2d[:2]
</code></pre>

<pre><code>array([[1, 2, 3],
       [4, 5, 6]])
</code></pre>

<p>可以看到，切片是沿着axis 0（行）来处理的。所以，数组中的切片，是要沿着设置的axis来处理的。我们可以把arr2d[:2]理解为“选中arr2d的前两行”。</p>

<p>当然，给定多个索引后，也可以使用复数切片：</p>

<pre><code class="language-python">arr2d
</code></pre>

<pre><code>array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]])
</code></pre>

<pre><code class="language-python">arr2d[:2, 1:] # 前两行，第二列之后
</code></pre>

<pre><code>array([[2, 3],
       [5, 6]])
</code></pre>

<p>记住，选中的是array view。通过混合整数和切片，能做低维切片。比如，我们选中第二行的前两列：</p>

<pre><code class="language-python">arr2d[1, :2]
</code></pre>

<pre><code>array([4, 5])
</code></pre>

<p>选中第三列的前两行：</p>

<pre><code class="language-python">arr2d[:2, 2]
</code></pre>

<pre><code>array([3, 6])
</code></pre>

<p>冒号表示提取整个axis（轴）：</p>

<pre><code class="language-python">arr2d[:, :1]
</code></pre>

<pre><code>array([[1],
       [4],
       [7]])
</code></pre>

<p>看图示有助于理解：
<img src="http://pacdb2bfr.bkt.clouddn.com/blog/image/180728/Kag9g9Fm6A.png?imageslim" alt="mark" /></p>

<p>赋值也很方便：</p>

<pre><code class="language-python">arr2d[:2, 1:] = 0
arr2d
</code></pre>

<pre><code>array([[1, 0, 0],
       [4, 0, 0],
       [7, 8, 9]])
</code></pre>

<h1 id="5-boolean-indexing-布尔索引">5 Boolean Indexing (布尔索引)</h1>

<p>假设我们的数组数据里有一些重复。这里我们用numpy.random里的randn函数来随机生成一些离散数据：</p>

<pre><code class="language-python">names = np.array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'])
names
</code></pre>

<pre><code>array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'],
      dtype='&lt;U4')
</code></pre>

<pre><code class="language-python">data = np.random.randn(7, 4)
data
</code></pre>

<pre><code>array([[ 0.02584271, -1.53529621,  0.73143988, -0.34086189],
       [ 0.40864782,  0.53476799,  1.09620596,  0.4846564 ],
       [ 1.95024076, -0.37291038, -0.40424703,  0.30297059],
       [-0.48632936,  0.63817756, -0.40792716, -1.48037389],
       [-0.81976335, -1.10162466, -0.59823212, -0.10926744],
       [-0.5212113 ,  0.29449179,  2.0568032 ,  2.00515735],
       [-2.36066876, -0.3294302 , -0.24464646, -0.81432884]])
</code></pre>

<p>假设每一个name对应data数组中的一行，我们想要选中name为&rsquo;Bob&rsquo;的所有行。就像四则运算，用比较运算符（==）：</p>

<pre><code class="language-python">names == 'Bob'
</code></pre>

<pre><code>array([ True, False, False,  True, False, False, False], dtype=bool)
</code></pre>

<p>然后用这个布尔数组当做索引：</p>

<pre><code class="language-python">data[names == 'Bob']
</code></pre>

<pre><code>array([[ 0.02584271, -1.53529621,  0.73143988, -0.34086189],
       [-0.48632936,  0.63817756, -0.40792716, -1.48037389]])
</code></pre>

<p>注意：布尔数组和data数组的长度要一样。</p>

<p>我们可以选中names==&lsquo;Bob&rsquo;的行，然后索引列：</p>

<pre><code class="language-python">data[names == 'Bob', 2:]
</code></pre>

<pre><code>array([[ 0.73143988, -0.34086189],
       [-0.40792716, -1.48037389]])
</code></pre>

<pre><code class="language-python">data[names == 'Bob', 3]
</code></pre>

<pre><code>array([-0.34086189, -1.48037389])
</code></pre>

<p>选中除了&rsquo;Bob&rsquo;外的所有行，可以用<code>!=</code>或者<code>~</code>：</p>

<pre><code class="language-python">names != 'Bob'
</code></pre>

<pre><code>array([False,  True,  True, False,  True,  True,  True], dtype=bool)
</code></pre>

<pre><code class="language-python">data[~(names == 'Bob')]
</code></pre>

<pre><code>array([[ 0.40864782,  0.53476799,  1.09620596,  0.4846564 ],
       [ 1.95024076, -0.37291038, -0.40424703,  0.30297059],
       [-0.81976335, -1.10162466, -0.59823212, -0.10926744],
       [-0.5212113 ,  0.29449179,  2.0568032 ,  2.00515735],
       [-2.36066876, -0.3294302 , -0.24464646, -0.81432884]])
</code></pre>

<p>当想要反转一个条件时，用<code>~</code>操作符很方便：</p>

<pre><code class="language-python">cond = names == 'Bob'
</code></pre>

<pre><code class="language-python">data[~cond]
</code></pre>

<pre><code>array([[ 0.40864782,  0.53476799,  1.09620596,  0.4846564 ],
       [ 1.95024076, -0.37291038, -0.40424703,  0.30297059],
       [-0.81976335, -1.10162466, -0.59823212, -0.10926744],
       [-0.5212113 ,  0.29449179,  2.0568032 ,  2.00515735],
       [-2.36066876, -0.3294302 , -0.24464646, -0.81432884]])
</code></pre>

<p>选中2个或3个名字，组合多个布尔条件，用布尔运算符&amp;，|，另外python中的关键词and和or不管用：</p>

<pre><code class="language-python">names
</code></pre>

<pre><code>array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'],
      dtype='&lt;U4')
</code></pre>

<pre><code class="language-python">mask = (names == 'Bob') | (names == 'Will')
mask
</code></pre>

<pre><code>array([ True, False,  True,  True,  True, False, False], dtype=bool)
</code></pre>

<pre><code class="language-python">data[mask]
</code></pre>

<pre><code>array([[ 0.02584271, -1.53529621,  0.73143988, -0.34086189],
       [ 1.95024076, -0.37291038, -0.40424703,  0.30297059],
       [-0.48632936,  0.63817756, -0.40792716, -1.48037389],
       [-0.81976335, -1.10162466, -0.59823212, -0.10926744]])
</code></pre>

<p>用布尔索引总是会返回一份新创建的数据，原本的数据不会被改变。</p>

<p>更改值的方式也很直觉。比如我们想让所有负数变为0：</p>

<pre><code class="language-python">data[data &lt; 0] = 0
</code></pre>

<pre><code class="language-python">data
</code></pre>

<pre><code>array([[ 0.02584271,  0.        ,  0.73143988,  0.        ],
       [ 0.40864782,  0.53476799,  1.09620596,  0.4846564 ],
       [ 1.95024076,  0.        ,  0.        ,  0.30297059],
       [ 0.        ,  0.63817756,  0.        ,  0.        ],
       [ 0.        ,  0.        ,  0.        ,  0.        ],
       [ 0.        ,  0.29449179,  2.0568032 ,  2.00515735],
       [ 0.        ,  0.        ,  0.        ,  0.        ]])
</code></pre>

<p>用一维的布尔数组也能更改所有行或列：</p>

<pre><code class="language-python">names
</code></pre>

<pre><code>array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'],
      dtype='&lt;U4')
</code></pre>

<pre><code class="language-python">data[names != 'Joe'] = 7
</code></pre>

<pre><code class="language-python">data
</code></pre>

<pre><code>array([[ 7.        ,  7.        ,  7.        ,  7.        ],
       [ 0.40864782,  0.53476799,  1.09620596,  0.4846564 ],
       [ 7.        ,  7.        ,  7.        ,  7.        ],
       [ 7.        ,  7.        ,  7.        ,  7.        ],
       [ 7.        ,  7.        ,  7.        ,  7.        ],
       [ 0.        ,  0.29449179,  2.0568032 ,  2.00515735],
       [ 0.        ,  0.        ,  0.        ,  0.        ]])
</code></pre>

<h1 id="6-fancy-indexing-花式索引">6 Fancy Indexing(花式索引)</h1>

<p>通过整数数组来索引。假设我们有一个8 x 4的数组：</p>

<pre><code class="language-python">arr = np.empty((8, 4))
</code></pre>

<pre><code class="language-python">for i in range(8):
    arr[i] = i
</code></pre>

<pre><code class="language-python">arr
</code></pre>

<pre><code>array([[ 0.,  0.,  0.,  0.],
       [ 1.,  1.,  1.,  1.],
       [ 2.,  2.,  2.,  2.],
       [ 3.,  3.,  3.,  3.],
       [ 4.,  4.,  4.,  4.],
       [ 5.,  5.,  5.,  5.],
       [ 6.,  6.,  6.,  6.],
       [ 7.,  7.,  7.,  7.]])
</code></pre>

<p>想要按一定顺序选出几行，可以用一个整数list或整数ndarray来指定顺序：</p>

<pre><code class="language-python">arr[[4, 3, 0, 6]]
</code></pre>

<pre><code>array([[ 4.,  4.,  4.,  4.],
       [ 3.,  3.,  3.,  3.],
       [ 0.,  0.,  0.,  0.],
       [ 6.,  6.,  6.,  6.]])
</code></pre>

<p>用符号来从后选择row：</p>

<pre><code class="language-python">arr[[-3, -5, -7]]
</code></pre>

<pre><code>array([[ 5.,  5.,  5.,  5.],
       [ 3.,  3.,  3.,  3.],
       [ 1.,  1.,  1.,  1.]])
</code></pre>

<p>用多维索引数组，能选出由一维数组中的元素，通过在每个tuple中指定索引：</p>

<pre><code class="language-python">arr = np.arange(32).reshape((8, 4))
arr
</code></pre>

<pre><code>array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11],
       [12, 13, 14, 15],
       [16, 17, 18, 19],
       [20, 21, 22, 23],
       [24, 25, 26, 27],
       [28, 29, 30, 31]])
</code></pre>

<pre><code class="language-python">arr[[1, 5, 7, 2], [0, 3, 1, 2]]
</code></pre>

<pre><code>array([ 4, 23, 29, 10])
</code></pre>

<p>可以看到<code>[ 4, 23, 29, 10]</code>分别对应<code>(1, 0), (5, 3), (7, 1), (2, 2)</code>。不论数组有多少维，fancy indexing的结果总是一维。</p>

<p>对于长方形区域，有下面的方法来截取：</p>

<pre><code class="language-python">arr[[1, 5, 7, 2]][:, [0, 3, 1, 2]]
</code></pre>

<pre><code>array([[ 4,  7,  5,  6],
       [20, 23, 21, 22],
       [28, 31, 29, 30],
       [ 8, 11,  9, 10]])
</code></pre>

<p>上面的意思是，先从arr中选出[1, 5, 7, 2]这四行：</p>

<pre><code>array([[ 4,  5,  6,  7],
       [20, 21, 22, 23],
       [28, 29, 30, 31],
       [ 8,  9, 10, 11]])
</code></pre>

<p>然后[:, [0, 3, 1, 2]]表示选中所有行，但是列的顺序要按0,3,1,2来排。于是得到：</p>

<pre><code>array([[ 4,  7,  5,  6],
       [20, 23, 21, 22],
       [28, 31, 29, 30],
       [ 8, 11,  9, 10]])
</code></pre>

<p>要记住，fancy indexing和切片不同，得到的是一个新的array。</p>

<h1 id="7-transposing-arrays-and-swapping-axes-数组转置和轴交换">7 Transposing Arrays and Swapping Axes（数组转置和轴交换）</h1>

<p>转置也是返回一个view，而不是新建一个数组。有两种方式，一个是transpose方法，一个是T属性：</p>

<pre><code class="language-python">arr = np.arange(15).reshape((3, 5))
arr
</code></pre>

<pre><code>array([[ 0,  1,  2,  3,  4],
       [ 5,  6,  7,  8,  9],
       [10, 11, 12, 13, 14]])
</code></pre>

<pre><code class="language-python">arr.T
</code></pre>

<pre><code>array([[ 0,  5, 10],
       [ 1,  6, 11],
       [ 2,  7, 12],
       [ 3,  8, 13],
       [ 4,  9, 14]])
</code></pre>

<p>做矩阵计算的时候，这个功能很常用，计算矩阵乘法的时候，用np.dot:</p>

<pre><code class="language-python">arr = np.arange(8).reshape((4, 2))
print(arr.T)
print(arr)
</code></pre>

<pre><code>[[0 2 4 6]
 [1 3 5 7]]
[[0 1]
 [2 3]
 [4 5]
 [6 7]]
</code></pre>

<pre><code class="language-python">np.dot(arr.T, arr)
</code></pre>

<pre><code>array([[56, 68],
       [68, 84]])
</code></pre>

<p>上面的例子是 (2x4) x (4x2) = (2x2)。得到的结果是2x2维，就是普通的矩阵乘法。</p>

<p>对于多维数组，transpose会接受由轴数字组成的tuple，来交换轴：</p>

<pre><code class="language-python">arr = np.arange(16).reshape((2, 2, 4))
arr
</code></pre>

<pre><code>array([[[ 0,  1,  2,  3],
        [ 4,  5,  6,  7]],

       [[ 8,  9, 10, 11],
        [12, 13, 14, 15]]])
</code></pre>

<pre><code class="language-python">arr.transpose((1, 0, 2))
</code></pre>

<pre><code>array([[[ 0,  1,  2,  3],
        [ 8,  9, 10, 11]],

       [[ 4,  5,  6,  7],
        [12, 13, 14, 15]]])
</code></pre>

<p>这里，secode axis(1)被设为第一个，first axis(0)第二个，最后的axis没边。</p>

<p>使用<code>.T</code>来转置swapping axes(交换轴)的一个特殊情况。ndarray有方法叫做swapaxes, 这个方法取两个axis值，并交换这两个轴：</p>

<pre><code class="language-python">arr
</code></pre>

<pre><code>array([[[ 0,  1,  2,  3],
        [ 4,  5,  6,  7]],

       [[ 8,  9, 10, 11],
        [12, 13, 14, 15]]])
</code></pre>

<pre><code class="language-python">arr.swapaxes(1, 2) # 直交换second axis和last axis
</code></pre>

<pre><code>array([[[ 0,  4],
        [ 1,  5],
        [ 2,  6],
        [ 3,  7]],

       [[ 8, 12],
        [ 9, 13],
        [10, 14],
        [11, 15]]])
</code></pre>

<p>swapaxes也是返回view，不生成新的data。</p>

    </div>

    
    

    
    

    <footer class="post-footer">
      

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02-python/02data/02-numpy/02-%E9%80%9A%E7%94%A8%E5%87%BD%E6%95%B0/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">02 通用函数</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02-python/01%E5%9F%BA%E7%A1%80/python-%E7%AE%80%E4%BB%8B/">
            <span class="next-text nav-default">Python 简介</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="iteratelyd@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="http://github.com/iterateself" class="iconfont icon-github" title="github"></a>
      <a href="https://www.zhihu.com/people/thebegin/activities" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="https://www.douban.com/people/68028070/" class="iconfont icon-douban" title="douban"></a>
  <a href="http://iterate.site/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> site pv: <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
    <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> site uv: <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2018
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">iterateself</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>


<script type="text/javascript" src="/dist/even.min.js?v=3.2.0"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>








</body>
</html>
