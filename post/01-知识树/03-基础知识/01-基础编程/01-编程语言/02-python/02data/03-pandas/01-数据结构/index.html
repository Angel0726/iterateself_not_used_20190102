<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>01 数据结构 - 迭代自己</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="iterateself" />
  <meta name="description" content="需要补充的 实际上，一直对pandas 的参数有些疑问，比如说，什么时候使用列表作为参数？什么时候一个参数也要放在列表里面？ pandas 的一些函数的参数详" />

  <meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.47.1" />


<link rel="canonical" href="http://iterate.site/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02-python/02data/03-pandas/01-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">




<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<link href="/dist/even.min.css?v=3.2.0" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">




<meta property="og:title" content="01 数据结构" />
<meta property="og:description" content="需要补充的 实际上，一直对pandas 的参数有些疑问，比如说，什么时候使用列表作为参数？什么时候一个参数也要放在列表里面？ pandas 的一些函数的参数详" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://iterate.site/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02-python/02data/03-pandas/01-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" /><meta property="article:published_time" content="2018-08-21T18:16:23&#43;00:00"/>
<meta property="article:modified_time" content="2018-08-21T18:16:23&#43;00:00"/>
<meta itemprop="name" content="01 数据结构">
<meta itemprop="description" content="需要补充的 实际上，一直对pandas 的参数有些疑问，比如说，什么时候使用列表作为参数？什么时候一个参数也要放在列表里面？ pandas 的一些函数的参数详">


<meta itemprop="datePublished" content="2018-08-21T18:16:23&#43;00:00" />
<meta itemprop="dateModified" content="2018-08-21T18:16:23&#43;00:00" />
<meta itemprop="wordCount" content="3312">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="01 数据结构"/>
<meta name="twitter:description" content="需要补充的 实际上，一直对pandas 的参数有些疑问，比如说，什么时候使用列表作为参数？什么时候一个参数也要放在列表里面？ pandas 的一些函数的参数详"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">迭代自己</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">主页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a><a href="/catalog/">
        <li class="mobile-menu-item">完整目录</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">迭代自己</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">主页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/catalog/">完整目录</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">01 数据结构</h1>

      <div class="post-meta">
        <span class="post-time"> 2018-08-21 </span>
        
        <span class="more-meta"> 3312 words </span>
        <span class="more-meta"> 7 mins read </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> times read </span>
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  
  <div class="post-toc-content">
    <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#需要补充的">需要补充的</a></li>
</ul></li>
<li><a href="#5-1-introduction-to-pandas-data-structures">5.1 Introduction to pandas Data Structures</a></li>
<li><a href="#1-series">1 Series</a></li>
<li><a href="#2-dataframe">2 DataFrame</a></li>
<li><a href="#3-index-objects-索引对象">3 Index Objects (索引对象)</a></li>
</ul>
</nav>
  </div>
</div>

    
    

    
    <div class="post-content">
      

<h2 id="需要补充的">需要补充的</h2>

<ul>
<li><span style="color:red;">实际上，一直对pandas 的参数有些疑问，比如说，什么时候使用列表作为参数？什么时候一个参数也要放在列表里面？</span></li>
<li><span style="color:red;">pandas 的一些函数的参数详解还是要阅读以下的，比如 <a href="https://www.cnblogs.com/datablog/p/6127000.html">pandas.read_csv参数详解</a> 这样你使用的时候才能大概知道有些什么用法。</span></li>
</ul>

<p>本书的主角，用于进行数据处理和清洗的利器。详情可见第5章。</p>

<p>这一节终于要开始讲pandas了。闲话不说，直接开始正题。之后的笔记里，这样导入pandas：</p>

<pre><code class="language-python">import pandas as pd
from pandas import Series, DataFrame# 这两个经常用到
</code></pre>

<h1 id="5-1-introduction-to-pandas-data-structures">5.1 Introduction to pandas Data Structures</h1>

<p>数据结构其实就是Series和DataFrame。</p>

<h1 id="1-series">1 Series</h1>

<p>这里 series 我就不翻译成序列了，因为之前的所有笔记里，我都是把 sequence 翻译成序列的。</p>

<p>series 是一个像数组一样的一维序列，并伴有一个数组表示 label，叫做 index。创建一个 series 的方法也很简单：</p>

<pre><code>obj = pd.Series([4, 7, -5, 3])
obj
</code></pre>

<p>输出：</p>

<pre><code>0    4
1    7
2   -5
3    3
dtype: int64
</code></pre>

<p>可以看到，左边表示index，右边表示对应的value。可以通过value和index属性查看：</p>

<pre><code>obj.values
obj.index # like range(4)
</code></pre>

<p>输出：</p>

<pre><code>array([ 4,  7, -5,  3])
RangeIndex(start=0, stop=4, step=1)# 看来使用默认的range 初始化的就是这个RageIndex。
</code></pre>

<p>当然我们也可以自己指定 index 的 label：</p>

<pre><code>obj2 = pd.Series([4, 7, -5, 3], index=['d', 'b', 'a', 'c'])
print(obj2)
print(obj2.index)
</code></pre>

<p>输出：</p>

<pre><code>d    4
b    7
a   -5
c    3
dtype: int64
Index(['d', 'b', 'a', 'c'], dtype='object')
</code></pre>

<p>可以用index的label来选择：</p>

<pre><code class="language-python">print(obj2['a'])
obj2['d'] = 6
print(obj2[['c', 'a', 'd']])
</code></pre>

<p>输出：</p>

<pre><code>-5
c    3
a   -5
d    6
dtype: int64
</code></pre>

<p>这里[&lsquo;c&rsquo;, &lsquo;a&rsquo;, &rsquo;d&rsquo;]其实被当做了索引，尽管这个索引是用 string 构成的。==嗯==</p>

<p>使用 numpy 函数或类似的操作，会保留 index-value 的关系：</p>

<pre><code>print(obj2[obj2 &gt; 0])
print(obj2 * 2)
</code></pre>

<p>输出：</p>

<pre><code>d    6
b    7
c    3
dtype: int64
d    12
b    14
a   -10
c     6
dtype: int64
</code></pre>

<pre><code class="language-python">import numpy as np
np.exp(obj2)
</code></pre>

<p>输出：</p>

<pre><code>d     403.428793
b    1096.633158
a       0.006738
c      20.085537
dtype: float64
</code></pre>

<p>另一种看待series的方法，它是一个长度固定，有顺序的dict，从index映射到value。在很多场景下，可以当做dict来用：<span style="color:red;">也是哎</span></p>

<pre><code class="language-python">print('b' in obj2)
print('e' in obj2)
</code></pre>

<p>输出：</p>

<pre><code>True
False
</code></pre>

<p>还可以直接用现有的dict来创建series：==竟然可以这样==</p>

<pre><code>sdata = {'Ohio': 35000, 'Texas': 71000, 'Oregon':16000, 'Utah': 5000}
obj3 = pd.Series(sdata)
obj3
</code></pre>

<p>输出：</p>

<pre><code>Ohio      35000
Oregon    16000
Texas     71000
Utah       5000
dtype: int64
</code></pre>

<p>series 中的 index 其实就是 dict 中排好序的 keys。我们也可以传入一个自己想要的顺序：<span style="color:red;">这也行</span></p>

<pre><code class="language-python">states = ['California', 'Ohio', 'Oregon', 'Texas']
obj4 = pd.Series(sdata, index=states)
obj4
</code></pre>

<p>输出：</p>

<pre><code>California        NaN
Ohio          35000.0
Oregon        16000.0
Texas         71000.0
dtype: float64

</code></pre>

<p>顺序是按 states 里来的，但因为没有找到 california，所以是 NaN 。NaN 表示缺失数据，用之后我们提到的话就用 missing 或 NA 来指代。pandas 中的 isnull 和 notnull 函数可以用来检测缺失数据：</p>

<pre><code>pd.isnull(obj4)
pd.notnull(obj4)
</code></pre>

<p>输出：</p>

<pre><code>California     True
Ohio          False
Oregon        False
Texas         False
dtype: bool
California    False
Ohio           True
Oregon         True
Texas          True
dtype: bool
</code></pre>

<p>series也有对应的方法：</p>

<pre><code>obj4.isnull()
</code></pre>

<p>输出：</p>

<pre><code>California     True
Ohio          False
Oregon        False
Texas         False
dtype: bool
</code></pre>

<p>关于缺失数据，在第七章还会讲得更详细一些。==嗯，非常想知道缺失数据的详细处理方式以及例子==</p>

<p>series 中一个有用的特色自动按 index label 来排序（Data alignment features）：</p>

<pre><code>print(obj3)
print(obj4)
print(obj3 + obj4)
</code></pre>

<p>输出：</p>

<pre><code>Ohio      35000
Oregon    16000
Texas     71000
Utah       5000
dtype: int64
California        NaN
Ohio          35000.0
Oregon        16000.0
Texas         71000.0
dtype: float64
California         NaN
Ohio           70000.0
Oregon         32000.0
Texas         142000.0
Utah               NaN
dtype: float64

</code></pre>

<p>这个 Data alignment features（数据对齐特色）和数据库中的 join 相似。==为什么这个 + 是join 操作呢？看起来有些奇怪==</p>

<p>serice 自身和它的 index 都有一个叫name的属性，这个能和其他 pandas 的函数进行整合：</p>

<pre><code>obj4.name = 'population'
obj4.index.name = 'state'
print(obj4)
</code></pre>

<p>输出：</p>

<pre><code>state
California        NaN
Ohio          35000.0
Oregon        16000.0
Texas         71000.0
Name: population, dtype: float64
</code></pre>

<p>series 的 index 能被直接更改：==说实话，不知道什么时候会更改 series 的 index？==</p>

<pre><code>print(obj)
obj.index = ['Bob', 'Steve', 'Jeff', 'Ryan']
print(obj)
</code></pre>

<p>输出：</p>

<pre><code>0    4
1    7
2   -5
3    3
dtype: int64
Bob      4
Steve    7
Jeff    -5
Ryan     3
dtype: int64

</code></pre>

<h1 id="2-dataframe">2 DataFrame</h1>

<p>DataFrame 表示一个长方形表格，并包含排好序的列，每一列都可以是不同的数值类型（数字，字符串，布尔值）。DataFrame 有行索引和列索引（row index, column index）；可以看做是分享所有索引的由 series组成的字典。数据是保存在一维以上的区块里的。==嗯，分享所有索引的由 series 组成的字典，说的非常清晰==</p>

<p>==其实可以把dataframe当做excel里的那种表格来用的，这样感觉更直观一些==
构建一个 dataframe 的方法，用一个 dcit，dict 里的值是 list：</p>

<pre><code>data = {'state': ['Ohio', 'Ohio', 'Ohio', 'Nevada', 'Nevada', 'Nevada'],
        'year': [2000, 2001, 2002, 2001, 2002, 2003],
        'pop': [1.5, 1.7, 3.6, 2.4, 2.9, 3.2]}
frame = pd.DataFrame(data)
print(frame)
</code></pre>

<p>输出：</p>

<table>
<thead>
<tr>
<th></th>
<th>pop</th>
<th>state</th>
<th>year</th>
</tr>
</thead>

<tbody>
<tr>
<td>0</td>
<td>1.5</td>
<td>Ohio</td>
<td>2000</td>
</tr>

<tr>
<td>1</td>
<td>1.7</td>
<td>Ohio</td>
<td>2001</td>
</tr>

<tr>
<td>2</td>
<td>3.6</td>
<td>Ohio</td>
<td>2002</td>
</tr>

<tr>
<td>3</td>
<td>2.4</td>
<td>Nevada</td>
<td>2001</td>
</tr>

<tr>
<td>4</td>
<td>2.9</td>
<td>Nevada</td>
<td>2002</td>
</tr>

<tr>
<td>5</td>
<td>3.2</td>
<td>Nevada</td>
<td>2003</td>
</tr>
</tbody>
</table>

<p>dataframe 也会像 series 一样，自动给数据赋index，而列则会按顺序排好。</p>

<p>对于一个较大的DataFrame，用 head 方法会返回前5行：==注意：这个函数在数据分析中经常使用，用来查看表格里有什么东西==</p>

<pre><code>frame.head()
</code></pre>

<p>输出：</p>

<table>
<thead>
<tr>
<th></th>
<th>pop</th>
<th>state</th>
<th>year</th>
</tr>
</thead>

<tbody>
<tr>
<td>0</td>
<td>1.5</td>
<td>Ohio</td>
<td>2000</td>
</tr>

<tr>
<td>1</td>
<td>1.7</td>
<td>Ohio</td>
<td>2001</td>
</tr>

<tr>
<td>2</td>
<td>3.6</td>
<td>Ohio</td>
<td>2002</td>
</tr>

<tr>
<td>3</td>
<td>2.4</td>
<td>Nevada</td>
<td>2001</td>
</tr>

<tr>
<td>4</td>
<td>2.9</td>
<td>Nevada</td>
<td>2002</td>
</tr>
</tbody>
</table>

<p>如果指定一列的话，会自动按列排序：</p>

<pre><code>pd.DataFrame(data, columns=['year', 'state', 'pop'])
</code></pre>

<p>输出：</p>

<table>
<thead>
<tr>
<th></th>
<th>year</th>
<th>state</th>
<th>pop</th>
</tr>
</thead>

<tbody>
<tr>
<td>0</td>
<td>2000</td>
<td>Ohio</td>
<td>1.5</td>
</tr>

<tr>
<td>1</td>
<td>2001</td>
<td>Ohio</td>
<td>1.7</td>
</tr>

<tr>
<td>2</td>
<td>2002</td>
<td>Ohio</td>
<td>3.6</td>
</tr>

<tr>
<td>3</td>
<td>2001</td>
<td>Nevada</td>
<td>2.4</td>
</tr>

<tr>
<td>4</td>
<td>2002</td>
<td>Nevada</td>
<td>2.9</td>
</tr>

<tr>
<td>5</td>
<td>2003</td>
<td>Nevada</td>
<td>3.2</td>
</tr>
</tbody>
</table>

<p>如果你导入一个不存在的列名，那么会显示为缺失数据：</p>

<pre><code>frame2 = pd.DataFrame(data, columns=['year', 'state', 'pop', 'debt'],
                      index=['one', 'two', 'three', 'four', 'five', 'six'])# 还可以这样指定 index。
print(frame2)
print(frame2.columns)
</code></pre>

<p>输出：</p>

<table>
<thead>
<tr>
<th></th>
<th>year</th>
<th>state</th>
<th>pop</th>
<th>debt</th>
</tr>
</thead>

<tbody>
<tr>
<td>one</td>
<td>2000</td>
<td>Ohio</td>
<td>1.5</td>
<td>NaN</td>
</tr>

<tr>
<td>two</td>
<td>2001</td>
<td>Ohio</td>
<td>1.7</td>
<td>NaN</td>
</tr>

<tr>
<td>three</td>
<td>2002</td>
<td>Ohio</td>
<td>3.6</td>
<td>NaN</td>
</tr>

<tr>
<td>four</td>
<td>2001</td>
<td>Nevada</td>
<td>2.4</td>
<td>NaN</td>
</tr>

<tr>
<td>five</td>
<td>2002</td>
<td>Nevada</td>
<td>2.9</td>
<td>NaN</td>
</tr>

<tr>
<td>six</td>
<td>2003</td>
<td>Nevada</td>
<td>3.2</td>
<td>NaN</td>
</tr>
</tbody>
</table>

<pre><code>Index(['year', 'state', 'pop', 'debt'], dtype='object')
</code></pre>

<p>从 DataFrame 里提取一列的话会返回 series 格式，可以以属性或是 dict 一样的形式来提取：==这两种各形式都行==</p>

<pre><code>print(frame2['state'])
print(frame2.year)
</code></pre>

<p>输出：</p>

<pre><code>one        Ohio
two        Ohio
three      Ohio
four     Nevada
five     Nevada
six      Nevada
Name: state, dtype: object
one      2000
two      2001
three    2002
four     2001
five     2002
six      2003
Name: year, dtype: int64
</code></pre>

<p>注意：frame2[column] 能应对任何列名，但 frame2.column 的情况下，列名必须是有效的 python 变量名才行。==嗯，没想到这个地方还有个注意，的确，看来还是使用 frame2[column] 这种形式。==</p>

<p>返回的 series 有 DataFrame 种同样的index，而且 name 属性也是对应的。</p>

<p>对于行，要在 loc 属性里用位置或名字：==这个loc 是什么的缩写？====什么叫位置？我试了 [0] 好像不行啊？确认下==</p>

<pre><code>frame2.loc['three']
</code></pre>

<p>输出：</p>

<pre><code>year     2002
state    Ohio
pop       3.6
debt      NaN
Name: three, dtype: object
</code></pre>

<p>列值也能通过赋值改变。比如给 debt 赋值：</p>

<pre><code>frame2['debt'] = 16.5
print(frame2)
frame2['debt'] = np.arange(6.)
print(frame2)
</code></pre>

<p>输出：</p>

<table>
<thead>
<tr>
<th></th>
<th>year</th>
<th>state</th>
<th>pop</th>
<th>debt</th>
</tr>
</thead>

<tbody>
<tr>
<td>one</td>
<td>2000</td>
<td>Ohio</td>
<td>1.5</td>
<td>16.5</td>
</tr>

<tr>
<td>two</td>
<td>2001</td>
<td>Ohio</td>
<td>1.7</td>
<td>16.5</td>
</tr>

<tr>
<td>three</td>
<td>2002</td>
<td>Ohio</td>
<td>3.6</td>
<td>16.5</td>
</tr>

<tr>
<td>four</td>
<td>2001</td>
<td>Nevada</td>
<td>2.4</td>
<td>16.5</td>
</tr>

<tr>
<td>five</td>
<td>2002</td>
<td>Nevada</td>
<td>2.9</td>
<td>16.5</td>
</tr>

<tr>
<td>six</td>
<td>2003</td>
<td>Nevada</td>
<td>3.2</td>
<td>16.5</td>
</tr>

<tr>
<td></td>
<td>year</td>
<td>state</td>
<td>pop</td>
<td>debt</td>
</tr>

<tr>
<td>&mdash;&ndash;</td>
<td>&mdash;-</td>
<td>&mdash;&mdash;</td>
<td>&mdash;-</td>
<td>&mdash;-</td>
</tr>

<tr>
<td>one</td>
<td>2000</td>
<td>Ohio</td>
<td>1.5</td>
<td>0.0</td>
</tr>

<tr>
<td>two</td>
<td>2001</td>
<td>Ohio</td>
<td>1.7</td>
<td>1.0</td>
</tr>

<tr>
<td>three</td>
<td>2002</td>
<td>Ohio</td>
<td>3.6</td>
<td>2.0</td>
</tr>

<tr>
<td>four</td>
<td>2001</td>
<td>Nevada</td>
<td>2.4</td>
<td>3.0</td>
</tr>

<tr>
<td>five</td>
<td>2002</td>
<td>Nevada</td>
<td>2.9</td>
<td>4.0</td>
</tr>

<tr>
<td>six</td>
<td>2003</td>
<td>Nevada</td>
<td>3.2</td>
<td>5.0</td>
</tr>
</tbody>
</table>

<p>如果把 list 或 array 赋给 column 的话，长度必须符合 DataFrame 的长度。如果把一二 series 赋给DataFrame，会按 DataFrame 的 index 来赋值，不够的地方用缺失数据来表示：</p>

<pre><code>val = pd.Series([-1.2, -1.5, -1.7], index=['two', 'four', 'five'])
frame2['debt'] = val
print(frame2)
</code></pre>

<p>输出：</p>

<table>
<thead>
<tr>
<th></th>
<th>year</th>
<th>state</th>
<th>pop</th>
<th>debt</th>
</tr>
</thead>

<tbody>
<tr>
<td>one</td>
<td>2000</td>
<td>Ohio</td>
<td>1.5</td>
<td>NaN</td>
</tr>

<tr>
<td>two</td>
<td>2001</td>
<td>Ohio</td>
<td>1.7</td>
<td>-1.2</td>
</tr>

<tr>
<td>three</td>
<td>2002</td>
<td>Ohio</td>
<td>3.6</td>
<td>NaN</td>
</tr>

<tr>
<td>four</td>
<td>2001</td>
<td>Nevada</td>
<td>2.4</td>
<td>-1.5</td>
</tr>

<tr>
<td>five</td>
<td>2002</td>
<td>Nevada</td>
<td>2.9</td>
<td>-1.7</td>
</tr>

<tr>
<td>six</td>
<td>2003</td>
<td>Nevada</td>
<td>3.2</td>
<td>NaN</td>
</tr>
</tbody>
</table>

<p>如果列不存在，赋值会创建一个新列。而 del 也能像删除字典关键字一样，删除列：</p>

<pre><code>frame2['eastern'] = frame2.state == 'Ohio'# 这也行
print(frame2)
</code></pre>

<p>输出：</p>

<table>
<thead>
<tr>
<th></th>
<th>year</th>
<th>state</th>
<th>pop</th>
<th>debt</th>
<th>eastern</th>
</tr>
</thead>

<tbody>
<tr>
<td>one</td>
<td>2000</td>
<td>Ohio</td>
<td>1.5</td>
<td>NaN</td>
<td>True</td>
</tr>

<tr>
<td>two</td>
<td>2001</td>
<td>Ohio</td>
<td>1.7</td>
<td>-1.2</td>
<td>True</td>
</tr>

<tr>
<td>three</td>
<td>2002</td>
<td>Ohio</td>
<td>3.6</td>
<td>NaN</td>
<td>True</td>
</tr>

<tr>
<td>four</td>
<td>2001</td>
<td>Nevada</td>
<td>2.4</td>
<td>-1.5</td>
<td>False</td>
</tr>

<tr>
<td>five</td>
<td>2002</td>
<td>Nevada</td>
<td>2.9</td>
<td>-1.7</td>
<td>False</td>
</tr>

<tr>
<td>six</td>
<td>2003</td>
<td>Nevada</td>
<td>3.2</td>
<td>NaN</td>
<td>False</td>
</tr>
</tbody>
</table>

<p>然后用del删除这一列：</p>

<pre><code>del frame2['eastern']
print(frame2.columns)
</code></pre>

<p>输出：</p>

<pre><code>Index(['year', 'state', 'pop', 'debt'], dtype='object')
</code></pre>

<p>注意：columns 返回的是一个view，而不是新建了一个copy。因此，任何对 series 的改变，会反映在DataFrame上。除非我们用 copy 方法来新建一个。</p>

<p>另一种常见的格式是 dict 中的 dict：</p>

<pre><code>pop = {'Nevada': {2001: 2.4, 2002: 2.9},
       'Ohio': {2000: 1.5, 2001: 1.7, 2002: 3.6} }
</code></pre>

<p>把上面这种嵌套 dcit 传给 DataFrame ，pandas 会把外层 dcit 的 key 当做列，内层 key 当做行索引：</p>

<pre><code>frame3 = pd.DataFrame(pop)
print(frame3)
</code></pre>

<p>输出：</p>

<table>
<thead>
<tr>
<th></th>
<th>Nevada</th>
<th>Ohio</th>
</tr>
</thead>

<tbody>
<tr>
<td>2000</td>
<td>NaN</td>
<td>1.5</td>
</tr>

<tr>
<td>2001</td>
<td>2.4</td>
<td>1.7</td>
</tr>

<tr>
<td>2002</td>
<td>2.9</td>
<td>3.6</td>
</tr>
</tbody>
</table>

<p>另外DataFrame也可以向numpy数组一样做转置：==这种转置什么时候用到呢？==</p>

<pre><code>frame3.T
</code></pre>

<p>输出：</p>

<table>
<thead>
<tr>
<th></th>
<th>2000</th>
<th>2001</th>
<th>2002</th>
</tr>
</thead>

<tbody>
<tr>
<td>Nevada</td>
<td>NaN</td>
<td>2.4</td>
<td>2.9</td>
</tr>

<tr>
<td>Ohio</td>
<td>1.5</td>
<td>1.7</td>
<td>3.6</td>
</tr>
</tbody>
</table>

<p>指定index：</p>

<pre><code>pd.DataFrame(pop, index=[2001, 2002, 2003])
</code></pre>

<p>输出：</p>

<table>
<thead>
<tr>
<th></th>
<th>Nevada</th>
<th>Ohio</th>
</tr>
</thead>

<tbody>
<tr>
<td>2001</td>
<td>2.4</td>
<td>1.7</td>
</tr>

<tr>
<td>2002</td>
<td>2.9</td>
<td>3.6</td>
</tr>

<tr>
<td>2003</td>
<td>NaN</td>
<td>NaN</td>
</tr>
</tbody>
</table>

<p>series 组成的 dict：</p>

<pre><code>pdata = {'Ohio': frame3['Ohio'][:-1],
         'Nevada': frame3['Nevada'][:2]}
pd.DataFrame(pdata)
</code></pre>

<p>输出：</p>

<table>
<thead>
<tr>
<th></th>
<th>Nevada</th>
<th>Ohio</th>
</tr>
</thead>

<tbody>
<tr>
<td>2000</td>
<td>NaN</td>
<td>1.5</td>
</tr>

<tr>
<td>2001</td>
<td>2.4</td>
<td>1.7</td>
</tr>
</tbody>
</table>

<p>其他一些可以传递给 DataFrame 的构造器：==都要好好总结下==</p>

<p><img src="http://pacdb2bfr.bkt.clouddn.com/blog/image/180616/7AIEDkC9Hk.png?imageslim" alt="mark" /></p>

<p>如果 DataFrame 的 index 和 column 有自己的 name 属性，也会被显示：==这个name 属性到底是什么？==</p>

<p>==这个地方没明白？为什么第一列是index？他有column吗？==</p>

<pre><code>frame3.index.name = 'year'
frame3.columns.name = 'state'
print(frame3)
</code></pre>

<p>输出：</p>

<table>
<thead>
<tr>
<th>state</th>
<th>Nevada</th>
<th>Ohio</th>
</tr>
</thead>

<tbody>
<tr>
<td>year</td>
<td></td>
<td></td>
</tr>

<tr>
<td>2000</td>
<td>NaN</td>
<td>1.5</td>
</tr>

<tr>
<td>2001</td>
<td>2.4</td>
<td>1.7</td>
</tr>

<tr>
<td>2002</td>
<td>2.9</td>
<td>3.6</td>
</tr>
</tbody>
</table>

<p>values 属性会返回二维数组：</p>

<pre><code>frame3.values
</code></pre>

<p>输出：</p>

<pre><code>array([[ nan,  1.5],
       [ 2.4,  1.7],
       [ 2.9,  3.6]])
</code></pre>

<p>如果 column 有不同的类型，dtype 会适应所有的列：</p>

<pre><code>frame2.values
</code></pre>

<p>输出：</p>

<pre><code>array([[2000, 'Ohio', 1.5, nan],
       [2001, 'Ohio', 1.7, -1.2],
       [2002, 'Ohio', 3.6, nan],
       [2001, 'Nevada', 2.4, -1.5],
       [2002, 'Nevada', 2.9, -1.7],
       [2003, 'Nevada', 3.2, nan]], dtype=object)
</code></pre>

<h1 id="3-index-objects-索引对象">3 Index Objects (索引对象)</h1>

<p>pandas 的 Index Objects (索引对象)负责保存 axis labels 和其他一些数据（比如axis name 或 names）。一个数组或其他一个序列标签，只要被用来做构建 series 或 DataFrame，就会被自动转变为 index：</p>

<pre><code>obj = pd.Series(range(3), index=['a', 'b', 'c'])
index = obj.index
print(index)
print(index[1:])
</code></pre>

<p>输出：</p>

<pre><code>Index(['a', 'b', 'c'], dtype='object')
Index(['b', 'c'], dtype='object')
</code></pre>

<p>index object 是不可更改的：==对于这个不可更改还是没有很理解==</p>

<pre><code>index[1] = 'd'
</code></pre>

<p>输出：</p>

<pre><code>---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
&lt;ipython-input-67-676fdeb26a68&gt; in &lt;module&gt;()
----&gt; 1 index[1] = 'd'

/Users/xu/anaconda/envs/py35/lib/python3.5/site-packages/pandas/indexes/base.py in __setitem__(self, key, value)
   1243
   1244     def __setitem__(self, key, value):
-&gt; 1245         raise TypeError(&quot;Index does not support mutable operations&quot;)
   1246
   1247     def __getitem__(self, key):

TypeError: Index does not support mutable operations
</code></pre>

<p>正因为不可修改，所以 data structure 中分享 index object 是很安全的：</p>

<pre><code>labels = pd.Index(np.arange(3))
print(labels)
obj2 = pd.Series([1.5, -2.5, 0], index=labels)
print(obj2)
print(obj2.index is labels)
</code></pre>

<p>输出：</p>

<pre><code>Int64Index([0, 1, 2], dtype='int64')
0    1.5
1   -2.5
2    0.0
dtype: float64
True
</code></pre>

<p>index 除了像数组，还能像大小一定的 set：</p>

<pre><code>print(frame3)
print(frame3.columns)
print('Ohio' in frame3.columns)
print(2003 in frame3.columns)
Index(['Nevada', 'Ohio'], dtype='object', name='state')
</code></pre>

<p>输出：</p>

<table>
<thead>
<tr>
<th>state</th>
<th>Nevada</th>
<th>Ohio</th>
</tr>
</thead>

<tbody>
<tr>
<td>year</td>
<td></td>
<td></td>
</tr>

<tr>
<td>2000</td>
<td>NaN</td>
<td>1.5</td>
</tr>

<tr>
<td>2001</td>
<td>2.4</td>
<td>1.7</td>
</tr>

<tr>
<td>2002</td>
<td>2.9</td>
<td>3.6</td>
</tr>
</tbody>
</table>

<pre><code>True
False
</code></pre>

<p>与 python 里的 set 不同，pandas的 index 可以有重复的 labels：==为什么可以有重复的labels 呢？==</p>

<pre><code>dup_labels = pd.Index(['foo', 'foo', 'bar', 'bar'])
print(dup_labels)
</code></pre>

<p>输出：</p>

<pre><code>Index(['foo', 'foo', 'bar', 'bar'], dtype='object')
</code></pre>

<p>在这种重复的标签中选择的话，会选中所有相同的标签。</p>

<p>Index还有一些方法和属性：</p>

<p><img src="http://pacdb2bfr.bkt.clouddn.com/blog/image/180616/9iiikFcKll.png?imageslim" alt="mark" /></p>

    </div>

    
    

    
    

    <footer class="post-footer">
      

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02-python/02data/01-%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD%E5%AD%98%E5%82%A8%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/01-%E4%BB%A5%E6%96%87%E6%9C%AC%E6%A0%BC%E5%BC%8F%E8%AF%BB%E5%8F%96%E5%92%8C%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">01 以文本格式读取和写入数据</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/02-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/01-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%90%86%E8%AE%BA/02-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/04-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/05-%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/02-boosting/">
            <span class="next-text nav-default">02 Boosting</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="iteratelyd@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="http://github.com/iterateself" class="iconfont icon-github" title="github"></a>
      <a href="https://www.zhihu.com/people/thebegin/activities" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="https://www.douban.com/people/68028070/" class="iconfont icon-douban" title="douban"></a>
  <a href="http://iterate.site/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> site pv: <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
    <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> site uv: <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2018
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">iterateself</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>


<script type="text/javascript" src="/dist/even.min.js?v=3.2.0"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>








</body>
</html>
