<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>02 主要功能 - iterate self</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="iterateself" />
  <meta name="description" content="5.2 Essential Functionality（主要功能） 接下来我们介绍一些 pandas 中经常用到的一些功能，注意，这里并没有全部总结。要补充完整 1 Reindexin" />

  <meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.47.1" />


<link rel="canonical" href="http://iterate.site/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02-python/02data/03-pandas/02-%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">




<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<link href="/dist/even.min.css?v=3.2.0" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">




<meta property="og:title" content="02 主要功能" />
<meta property="og:description" content="5.2 Essential Functionality（主要功能） 接下来我们介绍一些 pandas 中经常用到的一些功能，注意，这里并没有全部总结。要补充完整 1 Reindexin" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://iterate.site/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02-python/02data/03-pandas/02-%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD/" /><meta property="article:published_time" content="2018-08-03T13:53:29&#43;00:00"/>
<meta property="article:modified_time" content="2018-08-03T13:53:29&#43;00:00"/>
<meta itemprop="name" content="02 主要功能">
<meta itemprop="description" content="5.2 Essential Functionality（主要功能） 接下来我们介绍一些 pandas 中经常用到的一些功能，注意，这里并没有全部总结。要补充完整 1 Reindexin">


<meta itemprop="datePublished" content="2018-08-03T13:53:29&#43;00:00" />
<meta itemprop="dateModified" content="2018-08-03T13:53:29&#43;00:00" />
<meta itemprop="wordCount" content="5924">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="02 主要功能"/>
<meta name="twitter:description" content="5.2 Essential Functionality（主要功能） 接下来我们介绍一些 pandas 中经常用到的一些功能，注意，这里并没有全部总结。要补充完整 1 Reindexin"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">iterate self</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">about</li>
      </a><a href="/catalog/">
        <li class="mobile-menu-item">目录</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">iterate self</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">about</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/catalog/">目录</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">02 主要功能</h1>

      <div class="post-meta">
        <span class="post-time"> 2018-08-03 </span>
        
        <span class="more-meta"> 5924 words </span>
        <span class="more-meta"> 12 mins read </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> times read </span>
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  
  <div class="post-toc-content">
    <nav id="TableOfContents">
<ul>
<li><a href="#5-2-essential-functionality-主要功能">5.2 Essential Functionality（主要功能）</a></li>
<li><a href="#1-reindexing-重新索引">1 Reindexing（重新索引）</a></li>
<li><a href="#2-dropping-entries-from-an-axis-按轴删除记录">2 Dropping Entries from an Axis (按轴删除记录)</a></li>
<li><a href="#3-indexing-selection-and-filtering-索引-选择-过滤">3 Indexing, Selection, and Filtering (索引，选择，过滤)</a>
<ul>
<li><a href="#selection-with-loc-and-iloc-用loc和iloc来选择">Selection with loc and iloc(用loc和iloc来选择)</a></li>
</ul></li>
<li><a href="#4-integer-indexes-整数索引">4 Integer Indexes（整数索引）</a></li>
<li><a href="#5-arithmetic-and-data-alignment-算数和数据对齐">5 Arithmetic and Data Alignment (算数和数据对齐)</a>
<ul>
<li>
<ul>
<li><a href="#arithmetic-methods-with-fill-values-带填充值的算数方法">Arithmetic methods with fill values (带填充值的算数方法)</a></li>
<li><a href="#operations-between-dataframe-and-series-dataframe和series之间的操作">Operations between DataFrame and Series (DataFrame和Series之间的操作)</a></li>
</ul></li>
</ul></li>
<li><a href="#6-function-application-and-mapping-函数应用和映射">6 Function Application and Mapping (函数应用和映射)</a></li>
<li><a href="#7-sorting-and-ranking-排序">7 Sorting and Ranking （排序）</a></li>
<li><a href="#8-axis-indexes-with-duplicate-labels-有重复label的轴索引">8 Axis Indexes with Duplicate Labels (有重复label的轴索引)</a></li>
</ul>
</nav>
  </div>
</div>

    
    

    
    <div class="post-content">
      

<h1 id="5-2-essential-functionality-主要功能">5.2 Essential Functionality（主要功能）</h1>

<p>接下来我们介绍一些 pandas 中经常用到的一些功能，<font color=red>注意，这里并没有全部总结。要补充完整</font></p>

<h1 id="1-reindexing-重新索引">1 Reindexing（重新索引）</h1>

<p><font color=red>一般我们在什么时候使用这个 reindex？</font></p>

<p>pandas中一个重要的方法是 reindex，意思是在创建 object 的时候遵照一个新的index。如下例：</p>

<pre><code class="language-python">import pandas as pd
obj = pd.Series([4.5, 7.2, -5.3, 3.6], index=['d', 'b', 'a', 'c'])
print(obj)
</code></pre>

<p>输出：</p>

<pre><code class="language-text">d    4.5
b    7.2
a   -5.3
c    3.6
dtype: float64
</code></pre>

<p>在 series 上调用 reindex 能更改index，如果没有对应index的话会引入缺失数据：</p>

<pre><code class="language-python">obj2 = obj.reindex(['a', 'b', 'c', 'd', 'e'])
print(obj2)
</code></pre>

<p>输出：</p>

<pre><code class="language-text">a   -5.3
b    7.2
c    3.6
d    4.5
e    NaN
dtype: float64
</code></pre>

<p>在处理时间序列这样的数据时，我们可能需要在 reindexing 的时候修改值。method 选项能做到这一点，比如设定 method 为 ffill:<font color=red>什么时候修改值？修改成什么？对于 null 值的处理吗？</font></p>

<pre><code class="language-python">obj3 = pd.Series(['bule', 'purple', 'yellow'], index=[0, 2, 4])
print(obj3)
obj3.reindex(range(6), method='ffill')
print(obj3)
</code></pre>

<p>输出：</p>

<pre><code class="language-text">0      bule
2    purple
4    yellow
dtype: object
0      bule
1      bule
2    purple
3    purple
4    yellow
5    yellow
dtype: object
</code></pre>

<p>对于DataFrame，reindex能更改 row index,或 column index。reindex the rows:</p>

<pre><code class="language-python">import numpy as np
frame = pd.DataFrame(np.arange(9).reshape(3, 3),
                     index=['a', 'c', 'd'],
                     columns=['Ohio', 'Texas', 'California'])
print(frame)
</code></pre>

<p>输出：
|      | Ohio | Texas | California |
| &mdash;- | &mdash;- | &mdash;&ndash; | &mdash;&mdash;&mdash;- |
| a    | 0    | 1     | 2          |
| c    | 3    | 4     | 5          |
| d    | 6    | 7     | 8          |</p>

<p>更改 rows index:</p>

<pre><code class="language-python">frame2 = frame.reindex(['a', 'b', 'c', 'd'])
print(frame2)
</code></pre>

<p>输出：</p>

<table>
<thead>
<tr>
<th></th>
<th>Ohio</th>
<th>Texas</th>
<th>California</th>
</tr>
</thead>

<tbody>
<tr>
<td>a</td>
<td>0.0</td>
<td>1.0</td>
<td>2.0</td>
</tr>

<tr>
<td>b</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
</tr>

<tr>
<td>c</td>
<td>3.0</td>
<td>4.0</td>
<td>5.0</td>
</tr>

<tr>
<td>d</td>
<td>6.0</td>
<td>7.0</td>
<td>8.0</td>
</tr>
</tbody>
</table>

<p>更改 columns index:<font color=red>这个地方注意一下，原来的列名对应的还是不变的。只是变更了顺序</font></p>

<pre><code class="language-python">states = ['Texas', 'Utah', 'California']
frame.reindex(columns=states)
print(frame)
</code></pre>

<p>输出：</p>

<table>
<thead>
<tr>
<th></th>
<th>Texas</th>
<th>Utah</th>
<th>California</th>
</tr>
</thead>

<tbody>
<tr>
<td>a</td>
<td>1</td>
<td>NaN</td>
<td>2</td>
</tr>

<tr>
<td>c</td>
<td>4</td>
<td>NaN</td>
<td>5</td>
</tr>

<tr>
<td>d</td>
<td>7</td>
<td>NaN</td>
<td>8</td>
</tr>
</tbody>
</table>

<p>reindex的参数：
<img src="http://pacdb2bfr.bkt.clouddn.com/blog/image/180623/CGjk2Ka5FE.png?imageslim" alt="mark" /></p>

<p>还可以使用 loc 更简洁的 reindex：<font color=red>什么意思？</font></p>

<pre><code class="language-python">frame.loc[['a', 'b', 'c', 'd'], states]
</code></pre>

<p>输出：</p>

<table>
<thead>
<tr>
<th></th>
<th>Texas</th>
<th>Utah</th>
<th>California</th>
</tr>
</thead>

<tbody>
<tr>
<td>a</td>
<td>1.0</td>
<td>NaN</td>
<td>2.0</td>
</tr>

<tr>
<td>b</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
</tr>

<tr>
<td>c</td>
<td>4.0</td>
<td>NaN</td>
<td>5.0</td>
</tr>

<tr>
<td>d</td>
<td>7.0</td>
<td>NaN</td>
<td>8.0</td>
</tr>
</tbody>
</table>

<h1 id="2-dropping-entries-from-an-axis-按轴删除记录">2 Dropping Entries from an Axis (按轴删除记录)</h1>

<p>对于 series ，drop 回返回一个新的 object，并删去你指定的 axis 的值：</p>

<pre><code class="language-python">obj = pd.Series(np.arange(5.), index=['a', 'b', 'c', 'd', 'e'])
print(obj)
</code></pre>

<p>输出：</p>

<pre><code class="language-text">a    0.0
b    1.0
c    2.0
d    3.0
e    4.0
dtype: float64
</code></pre>

<pre><code class="language-python">new_obj = obj.drop('c')
print(new_obj)
new_obj=obj.drop(['d', 'c'])
print(new_obj)
</code></pre>

<p>输出：</p>

<pre><code class="language-text">a    0.0
b    1.0
d    3.0
e    4.0
dtype: float64
a    0.0
b    1.0
e    4.0
dtype: float64
</code></pre>

<p>对于 DataFrame ，index 能按行或列的 axis 来删除：</p>

<pre><code class="language-python">data = pd.DataFrame(np.arange(16).reshape(4, 4),
                    index=['Ohio', 'Colorado', 'Utah', 'New York'],
                    columns=['one', 'two', 'three', 'four'])
print(data)
</code></pre>

<p>输出：</p>

<table>
<thead>
<tr>
<th></th>
<th>one</th>
<th>two</th>
<th>three</th>
<th>four</th>
</tr>
</thead>

<tbody>
<tr>
<td>Ohio</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
</tr>

<tr>
<td>Colorado</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
</tr>

<tr>
<td>Utah</td>
<td>8</td>
<td>9</td>
<td>10</td>
<td>11</td>
</tr>

<tr>
<td>New York</td>
<td>12</td>
<td>13</td>
<td>14</td>
<td>15</td>
</tr>
</tbody>
</table>

<p>行处理：如果a sequence of labels(一个标签序列)来调用drop，会删去row labels(axis 0):</p>

<pre><code class="language-python">data.drop(['Colorado', 'Ohio'])
</code></pre>

<p>输出：</p>

<table>
<thead>
<tr>
<th></th>
<th>one</th>
<th>two</th>
<th>three</th>
<th>four</th>
</tr>
</thead>

<tbody>
<tr>
<td>Utah</td>
<td>8</td>
<td>9</td>
<td>10</td>
<td>11</td>
</tr>

<tr>
<td>New York</td>
<td>12</td>
<td>13</td>
<td>14</td>
<td>15</td>
</tr>
</tbody>
</table>

<p>列处理：drop列的话，设定axis=1或axis=&lsquo;columns&rsquo;:</p>

<pre><code class="language-python">data.drop('two', axis=1)
</code></pre>

<p>输出：</p>

<table>
<thead>
<tr>
<th></th>
<th>one</th>
<th>three</th>
<th>four</th>
</tr>
</thead>

<tbody>
<tr>
<td>Ohio</td>
<td>0</td>
<td>2</td>
<td>3</td>
</tr>

<tr>
<td>Colorado</td>
<td>4</td>
<td>6</td>
<td>7</td>
</tr>

<tr>
<td>Utah</td>
<td>8</td>
<td>10</td>
<td>11</td>
</tr>

<tr>
<td>New York</td>
<td>12</td>
<td>14</td>
<td>15</td>
</tr>
</tbody>
</table>

<pre><code class="language-python">data.drop(['two', 'four'], axis='columns')
</code></pre>

<p>输出：</p>

<table>
<thead>
<tr>
<th></th>
<th>one</th>
<th>three</th>
</tr>
</thead>

<tbody>
<tr>
<td>Ohio</td>
<td>0</td>
<td>2</td>
</tr>

<tr>
<td>Colorado</td>
<td>4</td>
<td>6</td>
</tr>

<tr>
<td>Utah</td>
<td>8</td>
<td>10</td>
</tr>

<tr>
<td>New York</td>
<td>12</td>
<td>14</td>
</tr>
</tbody>
</table>

<p>drop 也可以不返回一个新的object，而是直接更改 series or dataframe in-place:<font color=red>嗯，这个是要知道的，inplace 才会替换</font></p>

<pre><code class="language-python">obj.drop('c', inplace=True)
print(obj)
</code></pre>

<p>输出：</p>

<pre><code>a    0.0
b    1.0
d    3.0
e    4.0
dtype: float64
</code></pre>

<h1 id="3-indexing-selection-and-filtering-索引-选择-过滤">3 Indexing, Selection, and Filtering (索引，选择，过滤)</h1>

<p>series indexing(obj[&hellip;]) 相当于 numpy 的 array indexing , 而且除了整数，还可以使用 series 的 index：</p>

<pre><code class="language-python">obj = pd.Series(np.arange(4.), index=['a', 'b', 'c', 'd'])
print(obj)
</code></pre>

<p>输出：</p>

<pre><code class="language-text">a    0.0
b    1.0
c    2.0
d    3.0
dtype: float64
</code></pre>

<p>下面这几种写法还是要注意下的。<font color=red>注意</font></p>

<pre><code class="language-python">print(obj['b'])
print(obj[1])# 嗯，这个还是不错的。
print(obj[2:4])
print(obj[['b', 'a', 'd']])# 注意这种写法，里面是一个list，
print(obj[[1, 3]])
print(obj[obj &lt; 2])# 这样也可以！
</code></pre>

<p>输出：</p>

<pre><code>1.0
1.0
c    2.0
d    3.0
dtype: float64
b    1.0
a    0.0
d    3.0
dtype: float64
b    1.0
d    3.0
dtype: float64
a    0.0
b    1.0
dtype: float64
</code></pre>

<p>用 label 来 slicing(切片)的时候，和 python 的切片不一样的在于，会包括尾节点：<font color=red>注意！这个与使用 index 来切片还是不同的。</font></p>

<pre><code class="language-python">obj['b':'c']
</code></pre>

<p>输出：</p>

<pre><code class="language-text">b    1.0
c    2.0
dtype: float64
</code></pre>

<p>可以直接给选中的label更改值：</p>

<pre><code class="language-python">obj['b':'c'] = 5
print(obj)
</code></pre>

<p>输出：</p>

<pre><code class="language-text">a    0.0
b    5.0
c    5.0
d    3.0
dtype: float64
</code></pre>

<p>而对于 DataFrame，indexing 可以通过一个值或序列，选中一个以上的列：</p>

<pre><code class="language-python">data = pd.DataFrame(np.arange(16).reshape((4, 4)),
                    index=['Ohio', 'Colorado', 'Utah', 'New York'],
                    columns=['one', 'two', 'three', 'four'])
print(data)
</code></pre>

<p>输出：</p>

<table>
<thead>
<tr>
<th></th>
<th>one</th>
<th>two</th>
<th>three</th>
<th>four</th>
</tr>
</thead>

<tbody>
<tr>
<td>Ohio</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
</tr>

<tr>
<td>Colorado</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
</tr>

<tr>
<td>Utah</td>
<td>8</td>
<td>9</td>
<td>10</td>
<td>11</td>
</tr>

<tr>
<td>New York</td>
<td>12</td>
<td>13</td>
<td>14</td>
<td>15</td>
</tr>
</tbody>
</table>

<pre><code class="language-python">data['two']
</code></pre>

<p>输出：</p>

<pre><code class="language-text">Ohio         1
Colorado     5
Utah         9
New York    13
Name: two, dtype: int64
</code></pre>

<pre><code class="language-python">data[['three', 'one']]
</code></pre>

<p>输出：</p>

<table>
<thead>
<tr>
<th></th>
<th>three</th>
<th>one</th>
</tr>
</thead>

<tbody>
<tr>
<td>Ohio</td>
<td>2</td>
<td>0</td>
</tr>

<tr>
<td>Colorado</td>
<td>6</td>
<td>4</td>
</tr>

<tr>
<td>Utah</td>
<td>10</td>
<td>8</td>
</tr>

<tr>
<td>New York</td>
<td>14</td>
<td>12</td>
</tr>
</tbody>
</table>

<p>dataframe 的 indexing 有一些比较特别的方式。比如通过布尔数组：</p>

<pre><code class="language-python">data[:2]
</code></pre>

<p>输出：</p>

<table>
<thead>
<tr>
<th></th>
<th>one</th>
<th>two</th>
<th>three</th>
<th>four</th>
</tr>
</thead>

<tbody>
<tr>
<td>Ohio</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
</tr>

<tr>
<td>Colorado</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
</tr>
</tbody>
</table>

<p><font color=red>这个没看懂？</font></p>

<pre><code class="language-python">data[data['three'] &gt; 5]
</code></pre>

<p>输出：</p>

<table>
<thead>
<tr>
<th></th>
<th>one</th>
<th>two</th>
<th>three</th>
<th>four</th>
</tr>
</thead>

<tbody>
<tr>
<td>Colorado</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
</tr>

<tr>
<td>Utah</td>
<td>8</td>
<td>9</td>
<td>10</td>
<td>11</td>
</tr>

<tr>
<td>New York</td>
<td>12</td>
<td>13</td>
<td>14</td>
<td>15</td>
</tr>
</tbody>
</table>

<p>行选择的语法格式 <code>data[:2]</code> 是很方便的。给 <code>[]</code> 里传入一个list的话，可以选择列。<font color=red>什么意思？</font></p>

<p>另一种方法是用 boolean dataframe:</p>

<pre><code class="language-python">data &lt; 5
</code></pre>

<p>输出：</p>

<table>
<thead>
<tr>
<th></th>
<th>one</th>
<th>two</th>
<th>three</th>
<th>four</th>
</tr>
</thead>

<tbody>
<tr>
<td>Ohio</td>
<td>True</td>
<td>True</td>
<td>True</td>
<td>True</td>
</tr>

<tr>
<td>Colorado</td>
<td>True</td>
<td>False</td>
<td>False</td>
<td>False</td>
</tr>

<tr>
<td>Utah</td>
<td>False</td>
<td>False</td>
<td>False</td>
<td>False</td>
</tr>

<tr>
<td>New York</td>
<td>False</td>
<td>False</td>
<td>False</td>
<td>False</td>
</tr>
</tbody>
</table>

<p><font color=red>原来还可以这样。</font></p>

<pre><code class="language-python">data[data &lt; 5] = 0
data
</code></pre>

<p>输出：</p>

<table>
<thead>
<tr>
<th></th>
<th>one</th>
<th>two</th>
<th>three</th>
<th>four</th>
</tr>
</thead>

<tbody>
<tr>
<td>Ohio</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>

<tr>
<td>Colorado</td>
<td>0</td>
<td>5</td>
<td>6</td>
<td>7</td>
</tr>

<tr>
<td>Utah</td>
<td>8</td>
<td>9</td>
<td>10</td>
<td>11</td>
</tr>

<tr>
<td>New York</td>
<td>12</td>
<td>13</td>
<td>14</td>
<td>15</td>
</tr>
</tbody>
</table>

<h2 id="selection-with-loc-and-iloc-用loc和iloc来选择">Selection with loc and iloc(用loc和iloc来选择)</h2>

<p><font color=red>loc 是什么的缩写？</font></p>

<p>对于label-indexing on rows, 我们介绍特别的索引符，loc and iloc. 这两个方法能通过 axis labels(loc) 或 integer(iloc) ，来选择行或列。
一个列子，选中一行多列 by label：</p>

<pre><code>data
</code></pre>

<p>输出：</p>

<table>
<thead>
<tr>
<th></th>
<th>one</th>
<th>two</th>
<th>three</th>
<th>four</th>
</tr>
</thead>

<tbody>
<tr>
<td>Ohio</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>

<tr>
<td>Colorado</td>
<td>0</td>
<td>5</td>
<td>6</td>
<td>7</td>
</tr>

<tr>
<td>Utah</td>
<td>8</td>
<td>9</td>
<td>10</td>
<td>11</td>
</tr>

<tr>
<td>New York</td>
<td>12</td>
<td>13</td>
<td>14</td>
<td>15</td>
</tr>
</tbody>
</table>

<p><font color=red>为什么行放在前面？</font></p>

<pre><code class="language-python">data.loc['Colorado', ['two', 'three']]
</code></pre>

<p>输出：</p>

<pre><code class="language-text">two      5
three    6
Name: Colorado, dtype: int64
</code></pre>

<p>同iloc实现相同的效果：</p>

<pre><code class="language-python">data.iloc[2, [3, 0, 1]]
</code></pre>

<p>输出：</p>

<pre><code class="language-text">four    11
one      8
two      9
Name: Utah, dtype: int64
</code></pre>

<pre><code class="language-python">data.iloc[2] # 一行
</code></pre>

<p>输出：</p>

<pre><code class="language-text">one       8
two       9
three    10
four     11
Name: Utah, dtype: int64
</code></pre>

<pre><code class="language-python">data.iloc[[1, 2], [3, 0, 1]]
</code></pre>

<p>输出：</p>

<table>
<thead>
<tr>
<th></th>
<th>four</th>
<th>one</th>
<th>two</th>
</tr>
</thead>

<tbody>
<tr>
<td>Colorado</td>
<td>7</td>
<td>0</td>
<td>5</td>
</tr>

<tr>
<td>Utah</td>
<td>11</td>
<td>8</td>
<td>9</td>
</tr>
</tbody>
</table>

<p>indexing 函数也能用于切片，不论是 single labels 或 lists of labels:</p>

<pre><code class="language-python">data.loc[:'Utah', 'two']
</code></pre>

<p>输出：</p>

<pre><code class="language-text">Ohio        0
Colorado    5
Utah        9
Name: two, dtype: int64
</code></pre>

<pre><code class="language-python">data.iloc[:, :3][data.three &gt; 5]
</code></pre>

<p><font color=red>竟然还可以这样！</font>
输出：</p>

<table>
<thead>
<tr>
<th></th>
<th>one</th>
<th>two</th>
<th>three</th>
</tr>
</thead>

<tbody>
<tr>
<td>Colorado</td>
<td>0</td>
<td>5</td>
<td>6</td>
</tr>

<tr>
<td>Utah</td>
<td>8</td>
<td>9</td>
<td>10</td>
</tr>

<tr>
<td>New York</td>
<td>12</td>
<td>13</td>
<td>14</td>
</tr>
</tbody>
</table>

<p>pandas中有很多用于选择和重新选择数据的方法：<font color=red>都是要整理的。</font>
<img src="http://pacdb2bfr.bkt.clouddn.com/blog/image/180623/7C1aeB3Ec6.png?imageslim" alt="mark" />
<img src="http://pacdb2bfr.bkt.clouddn.com/blog/image/180623/Efb0Ji2I1K.png?imageslim" alt="mark" /></p>

<p>注意：当设计padnas的时候，作者发现 frame[:, col] 这样的语法是比较冗长的，因为这是会被经常用到的一个功能。作者把一些 indexing 的功能（lable or integer）集成在了 ix 这个方法上。实际中，因为这种 label 和 integer 都可以用的方式很方便，于是 pandas team 设计了 loc 和 ilco 来实现 label-based 和 integer-based indexing.</p>

<p>虽然 ix indexing 依然错在，但是已经过时，不推荐使用。<font color=red>嗯，这个要知道</font></p>

<h1 id="4-integer-indexes-整数索引">4 Integer Indexes（整数索引）</h1>

<p>一些新手再用 integer 来 index 的时候，总是会被绊倒。因为这种方法和 python 用于 list 和 tuple 的 indexing 方法不同。</p>

<p>比如，你不希望下面的代码出现error：</p>

<pre><code class="language-python">ser = pd.Series(np.arange(3.))
print(ser)
</code></pre>

<p>输出：</p>

<pre><code class="language-text">0    0.0
1    1.0
2    2.0
dtype: float64
</code></pre>

<pre><code class="language-python">ser[-1]
</code></pre>

<p>输出：</p>

<pre><code class="language-text">---------------------------------------------------------------------------
KeyError                                  Traceback (most recent call last)
&lt;ipython-input-4-3cbe0b873a9e&gt; in &lt;module&gt;()
----&gt; 1 ser[-1]

E:\11.ProgramFiles\Anaconda3\lib\site-packages\pandas\core\series.py in __getitem__(self, key)
    601         key = com._apply_if_callable(key, self)
    602         try:
--&gt; 603             result = self.index.get_value(self, key)
    604
    605             if not is_scalar(result):

E:\11.ProgramFiles\Anaconda3\lib\site-packages\pandas\indexes\base.py in get_value(self, series, key)
   2167         try:
   2168             return self._engine.get_value(s, k,
-&gt; 2169                                           tz=getattr(series.dtype, 'tz', None))
   2170         except KeyError as e1:
   2171             if len(self) &gt; 0 and self.inferred_type in ['integer', 'boolean']:

pandas\index.pyx in pandas.index.IndexEngine.get_value (pandas\index.c:3557)()

pandas\index.pyx in pandas.index.IndexEngine.get_value (pandas\index.c:3240)()

pandas\index.pyx in pandas.index.IndexEngine.get_loc (pandas\index.c:4279)()

pandas\src\hashtable_class_helper.pxi in pandas.hashtable.Int64HashTable.get_item (pandas\hashtable.c:8564)()

pandas\src\hashtable_class_helper.pxi in pandas.hashtable.Int64HashTable.get_item (pandas\hashtable.c:8508)()

KeyError: -1
</code></pre>

<p>可以看到，pandas 在整数索引上可能会出错，因为这里我们的 index 包括 0，1，2，因此，你输入一个整数的时候，它并不知道你需要的是这个index，还是它的序号。</p>

<p>OK，但是，如果我们用非整数来做 index，那么 -1 就没有歧义了：</p>

<pre><code class="language-python">ser2 = pd.Series(np.arange(3.), index=['a', 'b', 'c'])
ser2[-1]
</code></pre>

<p>输出：</p>

<pre><code class="language-text">2.0
</code></pre>

<p>为了保持连贯性，如果 axis index 里包含 integer ，那么选择数据的时候，就会是 label-orented。 为了更精确地选择，我们还是推荐使用 <code>loc</code>(for label) 或 <code>ilco</code>(for integers):</p>

<pre><code class="language-python">ser
</code></pre>

<p>输出：</p>

<pre><code class="language-text">0    0.0
1    1.0
2    2.0
dtype: float64
</code></pre>

<pre><code class="language-python">ser[:1]
</code></pre>

<p>输出：</p>

<pre><code>0    0.0
dtype: float64
</code></pre>

<pre><code class="language-python">ser.loc[:1]
</code></pre>

<p>输出：<font color=red>注意：这个地方因为是 loc，因此是按照的它的index 的label 来切片的，而这样的切片是包含结尾的，因此是 0 和 1</font></p>

<pre><code class="language-text">0    0.0
1    1.0
dtype: float64
</code></pre>

<pre><code class="language-python">ser.iloc[:1]
</code></pre>

<p>输出：<font color=red>可见，这里用的是 iloc ，因此是正常的切片</font></p>

<pre><code class="language-text">0    0.0
dtype: float64
</code></pre>

<h1 id="5-arithmetic-and-data-alignment-算数和数据对齐">5 Arithmetic and Data Alignment (算数和数据对齐)</h1>

<p>pandas 一个有用的 feature 就是，不同 index 的 obejct 之间的算数计算。如果两个 object 相加，但他们各自的 index 并不相同，最后结果得到的 index 是这两个 index的合集：<font color=red>嗯，这个还是能理解的。</font></p>

<pre><code class="language-python">s1 = pd.Series([7.3, -2.5, 3.4, 1.5], index=['a', 'c', 'd', 'e'])
s2 = pd.Series([2.1, 3.6, -1.5, 4, 3.1], index=['a', 'c', 'e', 'f', 'g'])
s1
</code></pre>

<p>输出：</p>

<pre><code class="language-text">a    7.3
c   -2.5
d    3.4
e    1.5
dtype: float64
</code></pre>

<pre><code class="language-python">s2
</code></pre>

<p>输出：</p>

<pre><code class="language-text">a    2.1
c    3.6
e   -1.5
f    4.0
g    3.1
dtype: float64
</code></pre>

<pre><code class="language-python">s1 + s2
</code></pre>

<p>输出：<font color=red>如果一个有，一个没有，那么结果就是 NaN</font></p>

<pre><code class="language-text">a    9.4
c    1.1
d    NaN
e    0.0
f    NaN
g    NaN
dtype: float64
</code></pre>

<p>这种数据对齐的方式（internal data alignment）引入了很多缺失值在没有处理的位置上。这些缺失值会被用在之后的算数计算中。</p>

<p>在 DataFrame 中，数据对齐同时发生在行和列上：</p>

<pre><code class="language-python">df1 = pd.DataFrame(np.arange(9.).reshape((3, 3)), columns=list('bcd'),
                   index=['Ohio', 'Texas', 'Colorado'])
df2 = pd.DataFrame(np.arange(12.).reshape((4, 3)), columns=list('bde'),
                   index=['Utah', 'Ohio', 'Texas', 'Oregon'])
df1
</code></pre>

<p>输出：</p>

<table>
<thead>
<tr>
<th></th>
<th>b</th>
<th>c</th>
<th>d</th>
</tr>
</thead>

<tbody>
<tr>
<td>Ohio</td>
<td>0.0</td>
<td>1.0</td>
<td>2.0</td>
</tr>

<tr>
<td>Texas</td>
<td>3.0</td>
<td>4.0</td>
<td>5.0</td>
</tr>

<tr>
<td>Colorado</td>
<td>6.0</td>
<td>7.0</td>
<td>8.0</td>
</tr>
</tbody>
</table>

<pre><code class="language-python">df2
</code></pre>

<p>输出：</p>

<table>
<thead>
<tr>
<th></th>
<th>b</th>
<th>d</th>
<th>e</th>
</tr>
</thead>

<tbody>
<tr>
<td>Utah</td>
<td>0.0</td>
<td>1.0</td>
<td>2.0</td>
</tr>

<tr>
<td>Ohio</td>
<td>3.0</td>
<td>4.0</td>
<td>5.0</td>
</tr>

<tr>
<td>Texas</td>
<td>6.0</td>
<td>7.0</td>
<td>8.0</td>
</tr>

<tr>
<td>Oregon</td>
<td>9.0</td>
<td>10.0</td>
<td>11.0</td>
</tr>
</tbody>
</table>

<p>相加的结果就是两个DataFrame，行和列的合集：</p>

<pre><code class="language-python">df1 + df2
</code></pre>

<p>输出：</p>

<table>
<thead>
<tr>
<th></th>
<th>b</th>
<th>c</th>
<th>d</th>
<th>e</th>
</tr>
</thead>

<tbody>
<tr>
<td>Colorado</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
</tr>

<tr>
<td>Ohio</td>
<td>3.0</td>
<td>NaN</td>
<td>6.0</td>
<td>NaN</td>
</tr>

<tr>
<td>Oregon</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
</tr>

<tr>
<td>Texas</td>
<td>9.0</td>
<td>NaN</td>
<td>12.0</td>
<td>NaN</td>
</tr>

<tr>
<td>Utah</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
</tr>
</tbody>
</table>

<p>因为 &lsquo;c&rsquo; 和 &lsquo;e&rsquo; 列都不在两个DataFrame里，所有全是缺失值。对于行，即使有相同的，但列不一样的话也会是缺失值。<font color=red>嗯，这样的话有太多的缺失值了。有没有什么好的方法？</font></p>

<p>如果两个DataFrame相加，而且没有column和row，结果会全是null：</p>

<pre><code class="language-python">df1 = pd.DataFrame({'A': [1, 2]})
df2 = pd.DataFrame({'B': [3, 4]})
df1
</code></pre>

<p>输出：</p>

<table>
<thead>
<tr>
<th></th>
<th>A</th>
</tr>
</thead>

<tbody>
<tr>
<td>0</td>
<td>1</td>
</tr>

<tr>
<td>1</td>
<td>2</td>
</tr>
</tbody>
</table>

<pre><code class="language-python">df2
</code></pre>

<p>输出：</p>

<table>
<thead>
<tr>
<th></th>
<th>B</th>
</tr>
</thead>

<tbody>
<tr>
<td>0</td>
<td>3</td>
</tr>

<tr>
<td>1</td>
<td>4</td>
</tr>
</tbody>
</table>

<pre><code class="language-python">df1 - df2
</code></pre>

<p>输出：</p>

<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
</tr>
</thead>

<tbody>
<tr>
<td>0</td>
<td>NaN</td>
<td>NaN</td>
</tr>

<tr>
<td>1</td>
<td>NaN</td>
<td>NaN</td>
</tr>
</tbody>
</table>

<h3 id="arithmetic-methods-with-fill-values-带填充值的算数方法">Arithmetic methods with fill values (带填充值的算数方法)</h3>

<p>对于上面那些缺失值，我们想要填上 0：</p>

<pre><code class="language-python">df1 = pd.DataFrame(np.arange(12.).reshape((3, 4)),
                   columns=list('abcd'))
df2 = pd.DataFrame(np.arange(20.).reshape((4, 5)),
                   columns=list('abcde'))
df2.loc[1, 'b'] = np.nan
df1
</code></pre>

<p>输出：</p>

<table>
<thead>
<tr>
<th></th>
<th>a</th>
<th>b</th>
<th>c</th>
<th>d</th>
</tr>
</thead>

<tbody>
<tr>
<td>0</td>
<td>0.0</td>
<td>1.0</td>
<td>2.0</td>
<td>3.0</td>
</tr>

<tr>
<td>1</td>
<td>4.0</td>
<td>5.0</td>
<td>6.0</td>
<td>7.0</td>
</tr>

<tr>
<td>2</td>
<td>8.0</td>
<td>9.0</td>
<td>10.0</td>
<td>11.0</td>
</tr>
</tbody>
</table>

<pre><code class="language-python">df2
</code></pre>

<p>输出：</p>

<table>
<thead>
<tr>
<th></th>
<th>a</th>
<th>b</th>
<th>c</th>
<th>d</th>
<th>e</th>
</tr>
</thead>

<tbody>
<tr>
<td>0</td>
<td>0.0</td>
<td>1.0</td>
<td>2.0</td>
<td>3.0</td>
<td>4.0</td>
</tr>

<tr>
<td>1</td>
<td>5.0</td>
<td>NaN</td>
<td>7.0</td>
<td>8.0</td>
<td>9.0</td>
</tr>

<tr>
<td>2</td>
<td>10.0</td>
<td>11.0</td>
<td>12.0</td>
<td>13.0</td>
<td>14.0</td>
</tr>

<tr>
<td>3</td>
<td>15.0</td>
<td>16.0</td>
<td>17.0</td>
<td>18.0</td>
<td>19.0</td>
</tr>
</tbody>
</table>

<p>不使用添加方法的结果：</p>

<pre><code class="language-python">df1 + df2
</code></pre>

<p>输出：</p>

<table>
<thead>
<tr>
<th></th>
<th>a</th>
<th>b</th>
<th>c</th>
<th>d</th>
<th>e</th>
</tr>
</thead>

<tbody>
<tr>
<td>0</td>
<td>0.0</td>
<td>2.0</td>
<td>4.0</td>
<td>6.0</td>
<td>NaN</td>
</tr>

<tr>
<td>1</td>
<td>9.0</td>
<td>NaN</td>
<td>13.0</td>
<td>15.0</td>
<td>NaN</td>
</tr>

<tr>
<td>2</td>
<td>18.0</td>
<td>20.0</td>
<td>22.0</td>
<td>24.0</td>
<td>NaN</td>
</tr>

<tr>
<td>3</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
</tr>
</tbody>
</table>

<p>使用 fill_value 之后：<font color=red>这个 add 方法会改变 df1 吗？</font></p>

<pre><code class="language-python">df1.add(df2, fill_value=0)
</code></pre>

<p>输出：</p>

<table>
<thead>
<tr>
<th></th>
<th>a</th>
<th>b</th>
<th>c</th>
<th>d</th>
<th>e</th>
</tr>
</thead>

<tbody>
<tr>
<td>0</td>
<td>0.0</td>
<td>2.0</td>
<td>4.0</td>
<td>6.0</td>
<td>4.0</td>
</tr>

<tr>
<td>1</td>
<td>9.0</td>
<td>5.0</td>
<td>13.0</td>
<td>15.0</td>
<td>9.0</td>
</tr>

<tr>
<td>2</td>
<td>18.0</td>
<td>20.0</td>
<td>22.0</td>
<td>24.0</td>
<td>14.0</td>
</tr>

<tr>
<td>3</td>
<td>15.0</td>
<td>16.0</td>
<td>17.0</td>
<td>18.0</td>
<td>19.0</td>
</tr>
</tbody>
</table>

<p>下表中就有很多这样灵活的算数方法：
<img src="http://pacdb2bfr.bkt.clouddn.com/blog/image/180623/E42mHKch0G.png?imageslim" alt="mark" /></p>

<p>每一个都有一个配对的，以 r 开头，意思是反转，比如除法：</p>

<pre><code class="language-python">1 / df1
</code></pre>

<p>输出：</p>

<table>
<thead>
<tr>
<th></th>
<th>a</th>
<th>b</th>
<th>c</th>
<th>d</th>
</tr>
</thead>

<tbody>
<tr>
<td>0</td>
<td>inf</td>
<td>1.000000</td>
<td>0.500000</td>
<td>0.333333</td>
</tr>

<tr>
<td>1</td>
<td>0.250000</td>
<td>0.200000</td>
<td>0.166667</td>
<td>0.142857</td>
</tr>

<tr>
<td>2</td>
<td>0.125000</td>
<td>0.111111</td>
<td>0.100000</td>
<td>0.090909</td>
</tr>
</tbody>
</table>

<pre><code class="language-python">df1.rdiv(1)
</code></pre>

<p>输出：</p>

<table>
<thead>
<tr>
<th></th>
<th>a</th>
<th>b</th>
<th>c</th>
<th>d</th>
</tr>
</thead>

<tbody>
<tr>
<td>0</td>
<td>inf</td>
<td>1.000000</td>
<td>0.500000</td>
<td>0.333333</td>
</tr>

<tr>
<td>1</td>
<td>0.250000</td>
<td>0.200000</td>
<td>0.166667</td>
<td>0.142857</td>
</tr>

<tr>
<td>2</td>
<td>0.125000</td>
<td>0.111111</td>
<td>0.100000</td>
<td>0.090909</td>
</tr>
</tbody>
</table>

<p>在 reindex（重建索引）的时候，也可以使用 fill_value :<font color=red>这个在之前讲过了吧？</font></p>

<pre><code class="language-python">df1.reindex(columns=df2.columns, fill_value=0)
</code></pre>

<p>输出：</p>

<table>
<thead>
<tr>
<th></th>
<th>a</th>
<th>b</th>
<th>c</th>
<th>d</th>
<th>e</th>
</tr>
</thead>

<tbody>
<tr>
<td>0</td>
<td>0.0</td>
<td>1.0</td>
<td>2.0</td>
<td>3.0</td>
<td>0</td>
</tr>

<tr>
<td>1</td>
<td>4.0</td>
<td>5.0</td>
<td>6.0</td>
<td>7.0</td>
<td>0</td>
</tr>

<tr>
<td>2</td>
<td>8.0</td>
<td>9.0</td>
<td>10.0</td>
<td>11.0</td>
<td>0</td>
</tr>
</tbody>
</table>

<h3 id="operations-between-dataframe-and-series-dataframe和series之间的操作">Operations between DataFrame and Series (DataFrame和Series之间的操作)</h3>

<p>先举个numpy的例子帮助理解，可以考虑成一个二维数组和它的一行：</p>

<pre><code class="language-python">arr = np.arange(12.).reshape((3, 4))
arr
</code></pre>

<p>输出：</p>

<pre><code class="language-text">array([[  0.,   1.,   2.,   3.],
       [  4.,   5.,   6.,   7.],
       [  8.,   9.,  10.,  11.]])
</code></pre>

<pre><code class="language-python">arr[0]
</code></pre>

<p>输出：</p>

<pre><code class="language-text">array([ 0.,  1.,  2.,  3.])
</code></pre>

<p>一样
arr - arr[0]</p>

<pre><code>
输出：

```text
array([[ 0.,  0.,  0.,  0.],
       [ 4.,  4.,  4.,  4.],
       [ 8.,  8.,  8.,  8.]])
</code></pre>

<p>可以看到，这个减法是用在了每一行上。这种操作叫 broadcasting，在 Appendix A 有更详细的解释<font color=red>什么解释？为什么这种操作叫做 broadcasting？</font>。DataFrame和Series的操作也类似：</p>

<pre><code class="language-python">frame = pd.DataFrame(np.arange(12.).reshape((4, 3)),
                     columns=list('bde'),
                     index=['Utah', 'Ohio', 'Texas', 'Oregon'])
series = frame.iloc[0]
frame
</code></pre>

<p>输出：</p>

<table>
<thead>
<tr>
<th></th>
<th>b</th>
<th>d</th>
<th>e</th>
</tr>
</thead>

<tbody>
<tr>
<td>Utah</td>
<td>0.0</td>
<td>1.0</td>
<td>2.0</td>
</tr>

<tr>
<td>Ohio</td>
<td>3.0</td>
<td>4.0</td>
<td>5.0</td>
</tr>

<tr>
<td>Texas</td>
<td>6.0</td>
<td>7.0</td>
<td>8.0</td>
</tr>

<tr>
<td>Oregon</td>
<td>9.0</td>
<td>10.0</td>
<td>11.0</td>
</tr>
</tbody>
</table>

<pre><code class="language-python">series
</code></pre>

<p>输出：</p>

<pre><code class="language-text">b    0.0
d    1.0
e    2.0
Name: Utah, dtype: float64
</code></pre>

<p>可以理解为 series 的 index 与 dataframe 的列匹配，broadcasting down the rows (向下按行广播):<font color=red>嗯，按行广播</font></p>

<pre><code class="language-python">frame - series
</code></pre>

<p>输出：</p>

<table>
<thead>
<tr>
<th></th>
<th>b</th>
<th>d</th>
<th>e</th>
</tr>
</thead>

<tbody>
<tr>
<td>Utah</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
</tr>

<tr>
<td>Ohio</td>
<td>3.0</td>
<td>3.0</td>
<td>3.0</td>
</tr>

<tr>
<td>Texas</td>
<td>6.0</td>
<td>6.0</td>
<td>6.0</td>
</tr>

<tr>
<td>Oregon</td>
<td>9.0</td>
<td>9.0</td>
<td>9.0</td>
</tr>
</tbody>
</table>

<p>如果一个 index 既不在 DataFrame 的 column 中，也不再 series 里的 index 中，那么结果也是合集：</p>

<p><font color=red>这个地方没看懂，index 不是对应的行的吗？怎么加了之后放到列名里面了？</font></p>

<pre><code class="language-python">series2 = pd.Series(range(3), index=['b', 'e', 'f'])
frame + series2
</code></pre>

<p>输出：</p>

<table>
<thead>
<tr>
<th></th>
<th>b</th>
<th>d</th>
<th>e</th>
<th>f</th>
</tr>
</thead>

<tbody>
<tr>
<td>Utah</td>
<td>0.0</td>
<td>NaN</td>
<td>3.0</td>
<td>NaN</td>
</tr>

<tr>
<td>Ohio</td>
<td>3.0</td>
<td>NaN</td>
<td>6.0</td>
<td>NaN</td>
</tr>

<tr>
<td>Texas</td>
<td>6.0</td>
<td>NaN</td>
<td>9.0</td>
<td>NaN</td>
</tr>

<tr>
<td>Oregon</td>
<td>9.0</td>
<td>NaN</td>
<td>12.0</td>
<td>NaN</td>
</tr>
</tbody>
</table>

<p>如果想要广播列，去匹配行，必须要用到算数方法：</p>

<pre><code class="language-python">series3 = frame['d']
frame
</code></pre>

<p>输出：</p>

<table>
<thead>
<tr>
<th></th>
<th>b</th>
<th>d</th>
<th>e</th>
</tr>
</thead>

<tbody>
<tr>
<td>Utah</td>
<td>0.0</td>
<td>1.0</td>
<td>2.0</td>
</tr>

<tr>
<td>Ohio</td>
<td>3.0</td>
<td>4.0</td>
<td>5.0</td>
</tr>

<tr>
<td>Texas</td>
<td>6.0</td>
<td>7.0</td>
<td>8.0</td>
</tr>

<tr>
<td>Oregon</td>
<td>9.0</td>
<td>10.0</td>
<td>11.0</td>
</tr>
</tbody>
</table>

<pre><code class="language-python">series3
</code></pre>

<p>输出：</p>

<pre><code class="language-text">Utah       1.0
Ohio       4.0
Texas      7.0
Oregon    10.0
Name: d, dtype: float64
</code></pre>

<pre><code class="language-python">frame.sub(series3, axis='index')# 嗯，要标识出 index。
</code></pre>

<p>输出：</p>

<table>
<thead>
<tr>
<th></th>
<th>b</th>
<th>d</th>
<th>e</th>
</tr>
</thead>

<tbody>
<tr>
<td>Utah</td>
<td>-1.0</td>
<td>0.0</td>
<td>1.0</td>
</tr>

<tr>
<td>Ohio</td>
<td>-1.0</td>
<td>0.0</td>
<td>1.0</td>
</tr>

<tr>
<td>Texas</td>
<td>-1.0</td>
<td>0.0</td>
<td>1.0</td>
</tr>

<tr>
<td>Oregon</td>
<td>-1.0</td>
<td>0.0</td>
<td>1.0</td>
</tr>
</tbody>
</table>

<p>axis 参数就是用来匹配轴的。在这个例子里是匹配 dataframe 的 row index( <code>axis='index'</code> or <code>axis=0</code> )，然后再广播。</p>

<h1 id="6-function-application-and-mapping-函数应用和映射">6 Function Application and Mapping (函数应用和映射)</h1>

<p>numpy 的 ufuncs (element-wise数组方法) 也能用在 pandas 的 object 上：</p>

<pre><code class="language-python">frame = pd.DataFrame(np.random.randn(4, 3), columns=list('bde'),
                     index=['Utah', 'Ohio', 'Texas', 'Oregon'])
frame
</code></pre>

<p>输出：</p>

<table>
<thead>
<tr>
<th></th>
<th>b</th>
<th>d</th>
<th>e</th>
</tr>
</thead>

<tbody>
<tr>
<td>Utah</td>
<td>-0.810435</td>
<td>0.194448</td>
<td>-0.705901</td>
</tr>

<tr>
<td>Ohio</td>
<td>-0.886275</td>
<td>0.553640</td>
<td>1.066754</td>
</tr>

<tr>
<td>Texas</td>
<td>0.189898</td>
<td>-0.056108</td>
<td>-0.159926</td>
</tr>

<tr>
<td>Oregon</td>
<td>0.448303</td>
<td>0.439650</td>
<td>-1.351029</td>
</tr>
</tbody>
</table>

<pre><code class="language-python">np.abs(frame)
</code></pre>

<p>输出：</p>

<table>
<thead>
<tr>
<th></th>
<th>b</th>
<th>d</th>
<th>e</th>
</tr>
</thead>

<tbody>
<tr>
<td>Utah</td>
<td>0.810435</td>
<td>0.194448</td>
<td>0.705901</td>
</tr>

<tr>
<td>Ohio</td>
<td>0.886275</td>
<td>0.553640</td>
<td>1.066754</td>
</tr>

<tr>
<td>Texas</td>
<td>0.189898</td>
<td>0.056108</td>
<td>0.159926</td>
</tr>

<tr>
<td>Oregon</td>
<td>0.448303</td>
<td>0.439650</td>
<td>1.351029</td>
</tr>
</tbody>
</table>

<p>另一个常用的操作是把一个用在一维数组上的函数，应用在一行或一列上。要用到 DataFrame 中的 apply 函数：</p>

<p><font color=red>默认是用在每一列上面吗？</font></p>

<pre><code class="language-python">f = lambda x: x.max() - x.min()
frame.apply(f)
</code></pre>

<p>输出：</p>

<pre><code class="language-text">b    1.334579
d    0.609748
e    2.417783
dtype: float64
</code></pre>

<p>这里函数 f ，计算的是一个 series 中最大值和最小值的差，在 frame 中的每一列，这个函数被调用一次。作为结果的 series ，它的 index 就是 frame 的 column 。</p>

<p>如果你传入 <code>axis='column'</code> 用于apply，那么函数会被用在每一行：<font color=red>感觉这个还是比较容易弄混的，要清楚一下。</font></p>

<pre><code class="language-python">frame.apply(f, axis='columns')
</code></pre>

<p>输出：</p>

<pre><code class="language-text">Utah      1.004883
Ohio      1.953030
Texas     0.349825
Oregon    1.799333
dtype: float64
</code></pre>

<p>像是 sum, mean 这样的数组统计方法，DataFrame 中已经集成了，所以没必要用 apply 。<font color=red>那些事已经集成的？要总结下。</font></p>

<p>apply 不会返回标量，只会返回一个含有多个值的 series ：</p>

<pre><code class="language-python">def f(x):
    return pd.Series([x.min(), x.max()], index=['min', 'max'])
</code></pre>

<pre><code class="language-python">frame
</code></pre>

<p>输出：</p>

<table>
<thead>
<tr>
<th></th>
<th>b</th>
<th>d</th>
<th>e</th>
</tr>
</thead>

<tbody>
<tr>
<td>Utah</td>
<td>-0.810435</td>
<td>0.194448</td>
<td>-0.705901</td>
</tr>

<tr>
<td>Ohio</td>
<td>-0.886275</td>
<td>0.553640</td>
<td>1.066754</td>
</tr>

<tr>
<td>Texas</td>
<td>0.189898</td>
<td>-0.056108</td>
<td>-0.159926</td>
</tr>

<tr>
<td>Oregon</td>
<td>0.448303</td>
<td>0.439650</td>
<td>-1.351029</td>
</tr>
</tbody>
</table>

<p><font color=red>这个没看懂，为什么是这样的？</font></p>

<pre><code class="language-python">frame.apply(f)
</code></pre>

<p>输出：</p>

<table>
<thead>
<tr>
<th></th>
<th>b</th>
<th>d</th>
<th>e</th>
</tr>
</thead>

<tbody>
<tr>
<td>min</td>
<td>-0.886275</td>
<td>-0.056108</td>
<td>-1.351029</td>
</tr>

<tr>
<td>max</td>
<td>0.448303</td>
<td>0.553640</td>
<td>1.066754</td>
</tr>
</tbody>
</table>

<p>element-wise 的 python 函数也能用。
比如想要格式化frame中的浮点数，变为string。可以用apply map：</p>

<pre><code class="language-python">format = lambda x: '%.2f' % x
frame.applymap(format)
</code></pre>

<p>输出：</p>

<table>
<thead>
<tr>
<th></th>
<th>b</th>
<th>d</th>
<th>e</th>
</tr>
</thead>

<tbody>
<tr>
<td>Utah</td>
<td>-0.81</td>
<td>0.19</td>
<td>-0.71</td>
</tr>

<tr>
<td>Ohio</td>
<td>-0.89</td>
<td>0.55</td>
<td>1.07</td>
</tr>

<tr>
<td>Texas</td>
<td>0.19</td>
<td>-0.06</td>
<td>-0.16</td>
</tr>

<tr>
<td>Oregon</td>
<td>0.45</td>
<td>0.44</td>
<td>-1.35</td>
</tr>
</tbody>
</table>

<p>applymap 的做法是，series 有一个 map 函数，能用来实现 element-wise 函数：
<font color=red>这个是等价的吗？</font></p>

<pre><code class="language-python">frame['e'].map(format)
</code></pre>

<p>输出：</p>

<pre><code class="language-text">Utah      -0.71
Ohio       1.07
Texas     -0.16
Oregon    -1.35
Name: e, dtype: object
</code></pre>

<h1 id="7-sorting-and-ranking-排序">7 Sorting and Ranking （排序）</h1>

<p>按 row 或 column index 来排序的话，可以用 sort_index 方法，会返回一个新的 object ：</p>

<pre><code class="language-python">obj = pd.Series(range(4), index=['d', 'a', 'b', 'c'])
obj.sort_index()
</code></pre>

<p>输出：</p>

<pre><code>a    1
b    2
c    3
d    0
dtype: int64
</code></pre>

<p>在DataFrame，可以用index或其他axis来排序：</p>

<pre><code class="language-python">frame = pd.DataFrame(np.arange(8).reshape((2, 4)),
                     index=['three', 'one'],
                     columns=['d', 'a', 'b', 'c'])
frame
</code></pre>

<p>输出：</p>

<table>
<thead>
<tr>
<th></th>
<th>d</th>
<th>a</th>
<th>b</th>
<th>c</th>
</tr>
</thead>

<tbody>
<tr>
<td>three</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
</tr>

<tr>
<td>one</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
</tr>
</tbody>
</table>

<pre><code class="language-python">frame.sort_index()
</code></pre>

<p>输出：</p>

<table>
<thead>
<tr>
<th></th>
<th>d</th>
<th>a</th>
<th>b</th>
<th>c</th>
</tr>
</thead>

<tbody>
<tr>
<td>one</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
</tr>

<tr>
<td>three</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
</tr>
</tbody>
</table>

<pre><code class="language-python">frame.sort_index(axis=1)
</code></pre>

<p>输出：</p>

<table>
<thead>
<tr>
<th></th>
<th>a</th>
<th>b</th>
<th>c</th>
<th>d</th>
</tr>
</thead>

<tbody>
<tr>
<td>three</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>0</td>
</tr>

<tr>
<td>one</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>4</td>
</tr>
</tbody>
</table>

<p>默认是升序，可以设置降序：</p>

<pre><code class="language-python">frame.sort_index(axis=1, ascending=False)
</code></pre>

<p>输出：</p>

<table>
<thead>
<tr>
<th></th>
<th>d</th>
<th>c</th>
<th>b</th>
<th>a</th>
</tr>
</thead>

<tbody>
<tr>
<td>three</td>
<td>0</td>
<td>3</td>
<td>2</td>
<td>1</td>
</tr>

<tr>
<td>one</td>
<td>4</td>
<td>7</td>
<td>6</td>
<td>5</td>
</tr>
</tbody>
</table>

<p>如果想通过值来排序，可以用 sort_values 方法：</p>

<pre><code class="language-python">obj = pd.Series([4, 7, -3, 2])
obj.sort_values()
</code></pre>

<p>输出：</p>

<pre><code class="language-text">2   -3
3    2
0    4
1    7
dtype: int64
</code></pre>

<p>缺失值会被排在最后：</p>

<pre><code class="language-python">obj = pd.Series([4, np.nan, 7, np.nan, -3, 2])
obj.sort_values()
</code></pre>

<p>输出：</p>

<pre><code class="language-text">4   -3.0
5    2.0
0    4.0
2    7.0
1    NaN
3    NaN
dtype: float64
</code></pre>

<p>对于一个 DataFrame ，可以用一列或多列作为 sort keys 。这样的话，只需要把一列多多列的名字导入到 sort_values 即可：</p>

<pre><code class="language-python">frame = pd.DataFrame({'b': [4, 7, -3, 2], 'a': [0, 1, 0, 1]})
frame
</code></pre>

<p>输出：</p>

<table>
<thead>
<tr>
<th></th>
<th>a</th>
<th>b</th>
</tr>
</thead>

<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>4</td>
</tr>

<tr>
<td>1</td>
<td>1</td>
<td>7</td>
</tr>

<tr>
<td>2</td>
<td>0</td>
<td>-3</td>
</tr>

<tr>
<td>3</td>
<td>1</td>
<td>2</td>
</tr>
</tbody>
</table>

<pre><code class="language-python">frame.sort_values(by='b')
</code></pre>

<p>输出：</p>

<table>
<thead>
<tr>
<th></th>
<th>a</th>
<th>b</th>
</tr>
</thead>

<tbody>
<tr>
<td>2</td>
<td>0</td>
<td>-3</td>
</tr>

<tr>
<td>3</td>
<td>1</td>
<td>2</td>
</tr>

<tr>
<td>0</td>
<td>0</td>
<td>4</td>
</tr>

<tr>
<td>1</td>
<td>1</td>
<td>7</td>
</tr>
</tbody>
</table>

<p>多列排序的话，传入一个list of names：</p>

<pre><code class="language-python">frame.sort_values(by=['a', 'b'])
</code></pre>

<p>输出：</p>

<table>
<thead>
<tr>
<th></th>
<th>a</th>
<th>b</th>
</tr>
</thead>

<tbody>
<tr>
<td>2</td>
<td>0</td>
<td>-3</td>
</tr>

<tr>
<td>0</td>
<td>0</td>
<td>4</td>
</tr>

<tr>
<td>3</td>
<td>1</td>
<td>2</td>
</tr>

<tr>
<td>1</td>
<td>1</td>
<td>7</td>
</tr>
</tbody>
</table>

<p>ranking（排名）是给有效的数据分配数字。rank 方法能用于 series 和 DataFrame，rank方法默认会给每个 group 一个 mean rank（平均排名）。rank 表示在这个数在原来的 Series 中排第几名，有相同的数，取其排名平均（默认）作为值：</p>

<pre><code class="language-python">obj = pd.Series([7, -5, 7, 4, 2, 0, 4])
obj
</code></pre>

<p>输出：</p>

<pre><code class="language-text">0    7
1   -5
2    7
3    4
4    2
5    0
6    4
dtype: int64
</code></pre>

<pre><code class="language-python">obj.sort_values()
</code></pre>

<p>输出：</p>

<pre><code class="language-text">1   -5
5    0
4    2
3    4
6    4
0    7
2    7
dtype: int64
</code></pre>

<pre><code class="language-python">obj.rank()
</code></pre>

<p>输出：</p>

<pre><code class="language-text">0    6.5
1    1.0
2    6.5
3    4.5
4    3.0
5    2.0
6    4.5
dtype: float64
</code></pre>

<p>说明如下：在 obj 中，7 和 7 的排名分别是第六名和第七名，因此排名取平均得6.5，即在每个7出现的地方填上6.5。4 和 4 的排名是第 4 名和第五名，取平均得4.5。<font color=red>嗯</font></p>

<p>rank 也可以根据数据被观测到的顺序来设定：</p>

<pre><code class="language-python">obj
</code></pre>

<p>输出：</p>

<pre><code class="language-text">0    7
1   -5
2    7
3    4
4    2
5    0
6    4
dtype: int64
</code></pre>

<pre><code class="language-python">obj.rank(method='first')
</code></pre>

<p>输出：</p>

<pre><code>0    6.0
1    1.0
2    7.0
3    4.0
4    3.0
5    2.0
6    5.0
dtype: float64
</code></pre>

<p>说明一下：这里没有给 0 和 2 (指两个数字7) 赋予average rank 6.5，而是给第一个看到的7（label 0）设置 rank 为6，第二个看到的7（label 2）设置rank为7。<font color=red>嗯，是这样，OK</font></p>

<p>也可以设置降序：</p>

<pre><code class="language-python"># Assign tie values the maximum rank in the group
obj.rank(ascending=False, method='max')
</code></pre>

<p>输出：</p>

<pre><code class="language-text">0    2.0
1    7.0
2    2.0
3    4.0
4    5.0
5    6.0
6    4.0
dtype: float64
</code></pre>

<p>说明一下：ascending = False，因此两个7分别排第一第二名，由于是 max ，因此取最大值 2 。</p>

<p>dataframe 可以根据行或列来计算rank:</p>

<pre><code class="language-python">frame = pd.DataFrame({'b': [4.3, 7, -3, 2],
                      'a': [0, 1, 0, 1],
                      'c': [-2, 5, 8, -2.5]})
frame
</code></pre>

<p>输出：</p>

<table>
<thead>
<tr>
<th></th>
<th>a</th>
<th>b</th>
<th>c</th>
</tr>
</thead>

<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>4.3</td>
<td>-2.0</td>
</tr>

<tr>
<td>1</td>
<td>1</td>
<td>7.0</td>
<td>5.0</td>
</tr>

<tr>
<td>2</td>
<td>0</td>
<td>-3.0</td>
<td>8.0</td>
</tr>

<tr>
<td>3</td>
<td>1</td>
<td>2.0</td>
<td>-2.5</td>
</tr>
</tbody>
</table>

<pre><code class="language-python">frame.rank(axis='columns') # columns表示列与列之间的排序（即每一行里数据间的排序）
</code></pre>

<p>输出：</p>

<table>
<thead>
<tr>
<th></th>
<th>a</th>
<th>b</th>
<th>c</th>
</tr>
</thead>

<tbody>
<tr>
<td>0</td>
<td>2.0</td>
<td>3.0</td>
<td>1.0</td>
</tr>

<tr>
<td>1</td>
<td>1.0</td>
<td>3.0</td>
<td>2.0</td>
</tr>

<tr>
<td>2</td>
<td>2.0</td>
<td>1.0</td>
<td>3.0</td>
</tr>

<tr>
<td>3</td>
<td>2.0</td>
<td>3.0</td>
<td>1.0</td>
</tr>
</tbody>
</table>

<p>说明：columns表示列与列之间的排序（即每一行里数据间的排序） <font color=red>嗯，还是不错的。</font>
<img src="http://pacdb2bfr.bkt.clouddn.com/blog/image/180803/K33lEhe243.png?imageslim" alt="mark" /></p>

<h1 id="8-axis-indexes-with-duplicate-labels-有重复label的轴索引">8 Axis Indexes with Duplicate Labels (有重复label的轴索引)</h1>

<p>我们看到的所有例子都有 unique axis labels (index values), 唯一的轴标签（索引值）。一些 pandas 函数（reindex）,需要label是唯一的，但这并是不强制的。比如下面有一个重复的索引：<font color=red>reindex 是需要label 是唯一的吗？再确认下 reindex 到底对于label 是怎么对应的？</font></p>

<pre><code class="language-python">obj = pd.Series(range(5), index=['a', 'a', 'b', 'b', 'c'])
obj
</code></pre>

<p>输出：</p>

<pre><code class="language-text">a    0
a    1
b    2
b    3
c    4
dtype: int64
</code></pre>

<p>index 的 is_unique 特性能告诉我们 label 是否是唯一的：</p>

<pre><code class="language-python">obj.index.is_unique
</code></pre>

<p>输出：</p>

<pre><code class="language-text">False
</code></pre>

<p>数据选择对于重复 label 则表现有点不同。如果一个 label 有多个值，那么就会返回一个 series , 如果是 label 只对应一个值的话，会返回一个标量：<font color=red>还可以这样！</font></p>

<pre><code class="language-python">obj['a']
</code></pre>

<p>输出：</p>

<pre><code class="language-text">a    0
a    1
dtype: int64
</code></pre>

<pre><code class="language-python">obj['c']
</code></pre>

<p>输出：</p>

<pre><code class="language-text">4
</code></pre>

<p>这个选择的逻辑也应用于DataFrame：</p>

<pre><code class="language-python">df = pd.DataFrame(np.random.randn(4, 3), index=['a', 'a', 'b', 'b'])
df
</code></pre>

<p>输出：</p>

<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
</tr>
</thead>

<tbody>
<tr>
<td>a</td>
<td>-0.314526</td>
<td>-1.313861</td>
<td>0.823529</td>
</tr>

<tr>
<td>a</td>
<td>0.994028</td>
<td>-0.442338</td>
<td>-0.846985</td>
</tr>

<tr>
<td>b</td>
<td>-1.340453</td>
<td>-0.031612</td>
<td>0.044791</td>
</tr>

<tr>
<td>b</td>
<td>-0.919341</td>
<td>-0.409164</td>
<td>-1.297257</td>
</tr>
</tbody>
</table>

<pre><code class="language-python">df.loc['b']
</code></pre>

<p>输出：</p>

<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
</tr>
</thead>

<tbody>
<tr>
<td>b</td>
<td>-1.340453</td>
<td>-0.031612</td>
<td>0.044791</td>
</tr>

<tr>
<td>b</td>
<td>-0.919341</td>
<td>-0.409164</td>
<td>-1.297257</td>
</tr>
</tbody>
</table>

    </div>

    
    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">iterateself</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">2018-08-03</span>
  </p>
  
  
</div>

    
    

    <footer class="post-footer">
      

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02-python/02data/python-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-02-%E5%BC%95%E8%A8%80/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Python 数据分析 02 引言</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02-python/01%E5%9F%BA%E7%A1%80/python-%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/">
            <span class="next-text nav-default">Python 循环语句</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="iteratelyd@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="http://github.com/iterateself" class="iconfont icon-github" title="github"></a>
      <a href="https://www.zhihu.com/people/thebegin/activities" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="https://www.douban.com/people/68028070/" class="iconfont icon-douban" title="douban"></a>
  <a href="http://iterate.site/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> site pv: <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
    <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> site uv: <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2018
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">iterateself</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>


<script type="text/javascript" src="/dist/even.min.js?v=3.2.0"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>








</body>
</html>
