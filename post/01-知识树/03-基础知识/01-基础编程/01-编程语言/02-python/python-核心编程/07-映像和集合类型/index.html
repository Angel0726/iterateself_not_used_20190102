<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>07 映像和集合类型 - iterate self</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="iterateself" />
  <meta name="description" content="本章中，我们来讨论Python语言中的映射类型和集合类型。和前面的章节一样，我们首先做一 个介绍，然后在来讨论可用操作符，工厂函数、内建函数(" />

  <meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.47.1" />


<link rel="canonical" href="http://iterate.site/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02-python/python-%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/07-%E6%98%A0%E5%83%8F%E5%92%8C%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">




<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<link href="/dist/even.min.css?v=3.2.0" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">




<meta property="og:title" content="07 映像和集合类型" />
<meta property="og:description" content="本章中，我们来讨论Python语言中的映射类型和集合类型。和前面的章节一样，我们首先做一 个介绍，然后在来讨论可用操作符，工厂函数、内建函数(" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://iterate.site/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02-python/python-%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/07-%E6%98%A0%E5%83%8F%E5%92%8C%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B/" /><meta property="article:published_time" content="2018-06-26T21:19:54&#43;00:00"/>
<meta property="article:modified_time" content="2018-06-26T21:19:54&#43;00:00"/>
<meta itemprop="name" content="07 映像和集合类型">
<meta itemprop="description" content="本章中，我们来讨论Python语言中的映射类型和集合类型。和前面的章节一样，我们首先做一 个介绍，然后在来讨论可用操作符，工厂函数、内建函数(">


<meta itemprop="datePublished" content="2018-06-26T21:19:54&#43;00:00" />
<meta itemprop="dateModified" content="2018-06-26T21:19:54&#43;00:00" />
<meta itemprop="wordCount" content="9147">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="07 映像和集合类型"/>
<meta name="twitter:description" content="本章中，我们来讨论Python语言中的映射类型和集合类型。和前面的章节一样，我们首先做一 个介绍，然后在来讨论可用操作符，工厂函数、内建函数("/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">iterate self</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">about</li>
      </a><a href="/catalog/">
        <li class="mobile-menu-item">目录</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">iterate self</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">about</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/catalog/">目录</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">07 映像和集合类型</h1>

      <div class="post-meta">
        <span class="post-time"> 2018-06-26 </span>
        
        <span class="more-meta"> 9147 words </span>
        <span class="more-meta"> 19 mins read </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> times read </span>
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  
  <div class="post-toc-content">
    <nav id="TableOfContents">
<ul>
<li>
<ul>
<li>
<ul>
<li><a href="#7-6集合类型">7.6集合类型</a></li>
<li><a href="#7-6集合类型-1">7.6集合类型</a>
<ul>
<li><a href="#如何创建集合类型和给集合赋值">如何创建集合类型和给集合赋值</a></li>
<li><a href="#如何访问集合中的值">如何访问集合中的值</a></li>
<li><a href="#如何更新集合-用各种集合内建的方法和操作符添加和删除集合的成员">如何更新集合 用各种集合内建的方法和操作符添加和删除集合的成员</a></li>
<li><a href="#如何删除集合中的成员和集合">如何删除集合中的成员和集合</a></li>
</ul></li>
<li><a href="#7-7-集合类型操作符">7.7 集合类型操作符</a></li>
<li><a href="#7-7-1标准类型操作符-所有的集合类型">7.7.1标准类型操作符(所有的集合类型)</a>
<ul>
<li><a href="#成员关系-in-not-in">成员关系 (in, not in)</a></li>
<li><a href="#集合等价-不等价">集合等价/不等价</a></li>
<li><a href="#子集-超集">子集/超集</a></li>
</ul></li>
<li><a href="#7-7-2集合类型操作符-所有的集合类型">7.7.2集合类型操作符(所有的集合类型)</a>
<ul>
<li><a href="#交集">交集（ &amp; ）</a></li>
<li><a href="#差补-相对补集">差补/相对补集（ - ）</a></li>
<li><a href="#混合集合类型操作">混合集合类型操作</a></li>
</ul></li>
<li><a href="#7-7-3集合类型操作符-仅适用于可变集合">7.7.3集合类型操作符(仅适用于可变集合)</a>
<ul>
<li><a href="#union-update">(Union) Update ( |=)</a></li>
<li><a href="#保留-交集更新">保留/交集更新( &amp;= )</a></li>
<li><a href="#差更新">差更新(-=)</a></li>
<li><a href="#对称差分更新">对称差分更新(&ldquo;=)</a></li>
</ul></li>
<li><a href="#7-8-内建函数">7.8 内建函数</a>
<ul>
<li><a href="#len">len()</a></li>
<li><a href="#s-set-u">&gt;&gt;&gt; s = set(u)</a></li>
<li><a href="#6">6</a></li>
</ul></li>
<li><a href="#7-8-2集合类型工厂函数">7.8.2集合类型工厂函数</a>
<ul>
<li><a href="#set-and-frozenset">set() and frozenset()</a></li>
</ul></li>
<li><a href="#7-9-集合类型内建方法">7.9 集合类型内建方法</a></li>
<li><a href="#7-9-1方法-所有的集合方法">7.9.1方法(所有的集合方法)</a></li>
<li><a href="#7-9-2方法-仅适用于可变集合">7.9.2方法(仅适用于可变集合)</a></li>
<li><a href="#7-9-3操作符和内建方法比较">7.9.3操作符和内建方法比较</a></li>
<li><a href="#7-10-操作符-函数-方法">7.10 操作符、函数/方法</a></li>
<li><a href="#7-11-相关模块">7.11 相关模块</a></li>
<li><a href="#7-12-练习">7.12 练习</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
  </div>
</div>

    
    

    
    <div class="post-content">
      

<p>本章中，我们来讨论Python语言中的映射类型和集合类型。和前面的章节一样，我们首先做一 个介绍，然后在来讨论可用操作符，工厂函数、内建函数(BIF)和方法。然后我们再来看看每种数据 类型的详细用法。</p>

<p>Edit By Vheavens</p>

<p>Enter choice: D</p>

<p>You picked: [q]</p>

<h3 id="7-6集合类型">7.6集合类型</h3>

<p>数学上，把set称做由不同的元素组成的集合，集合(set)的成员通常被称做集合元素(set elements)。Python把这个概念引入到它的集合类型对象里。集合对象是一组无序排列的可哈希的值。 是的，集合成员可以做字典中的键。数学集合转为Python的集合对象很有效，集合关系测试和union、 intersection等操作符在Python里也同样如我们所预想地那样工作。</p>

<p>和其他容器类型一样，集合支持用 in 和 not in 操作符检查成员， 由 len() 内建函数得到集 合的基数(大小)，用for循环迭代集合的成员。但是因为集合本身是无序的，你不可以为集合创建 索引或执行切片(slice)操作，也没有键(keys)可用来获取集合中元素的值。</p>

<p>集合(sets)有两种不同的类型，可变集合(set)和不可变集合(frozenset)。如你所想，对可 变集合(set)你可以添加和删除元素，对不可变集合(frozenset)则不允许这样做。请注意，可变 集合(set)不是可哈希的，因此既不能用做字典的键也不能做其他集合中的元素。不可变集合</p>

<p>(frozenset)则正好相反，即，他们有哈希值，能被用做字典的键或是作为集合中的一个成员。</p>

<p>集合(Sets)最早出现在Python2.3版本中，通过集合(sets)模块来创建，并通过ImmutableSet 类和Set类进行访问。而后来，大家都认为把它们作为内建的数据类型是个更好的主意，因此这些 类被用C重写改进后包含进Python2.4。关于集合类型和这些类改进的更多内容，可阅读此文获得详 情：PEP 218，链接地址：<a href="http://python.org/peps/pep-0218.html">http://python.org/peps/pep-0218.html</a>.</p>

<p>虽然现在集合类型已经是Python的基本数据类型了，但它经常会以用户自定义类的形式出现在 各种Python程序中，就像复数一样(复数从Python1.4版本起成为python的一个数据类型)，这样 重复的劳动已数不胜数了。在现在的Python版本之前，(即使集合类型对许多人的程序来说并不是 最理想的数据结构，)许多人仍然试图给列表和字典这样的Python标准类型添加集合功能，这样可 以把它们作为真正集合类型的代理来使用。因此现在的使用者有包括“真正”集合类型在内的多种 选择。</p>

<p>在我们详细讲述Python的集合对象之前，我们必须理解Python中的一些数学符号(见表7.3)， 这样对术语和功能有一个清晰的了解。</p>

<p>表 7.3 集合操作符和关系符号</p>

<p><img src="07Python38c3160b-762.jpg" alt="img" /></p>

<p>数学符号    Python符号</p>

<p><img src="07Python38c3160b-764.jpg" alt="img" /></p>

<p><img src="07Python38c3160b-765.jpg" alt="img" /></p>

<p><img src="07Python38c3160b-766.jpg" alt="img" /></p>

<p><img src="07Python38c3160b-767.jpg" alt="img" /></p>

<p><img src="07Python38c3160b-768.jpg" alt="img" /></p>

<p>说明</p>

<table>
<thead>
<tr>
<th>e</th>
<th>in</th>
<th>是&hellip;的成员</th>
</tr>
</thead>

<tbody>
<tr>
<td></td>
<td>not in</td>
<td>不是&hellip;的成员</td>
</tr>

<tr>
<td></td>
<td></td>
<td>等于</td>
</tr>

<tr>
<td></td>
<td>!=</td>
<td>不等于</td>
</tr>

<tr>
<td>(=</td>
<td>&lt;</td>
<td>是&hellip;的(产格)子集</td>
</tr>

<tr>
<td></td>
<td>&lt;=</td>
<td>是&hellip;的子集(包括非严格子集)</td>
</tr>

<tr>
<td>=&gt;</td>
<td>&gt;</td>
<td>是&hellip;的(产格)超集</td>
</tr>

<tr>
<td>□</td>
<td></td>
<td>是&hellip;的超集(包括非严格超集)</td>
</tr>

<tr>
<td>n</td>
<td>&amp;</td>
<td>交集合集</td>
</tr>

<tr>
<td>or </td>
<td></td>
<td>差补或相对补集</td>
</tr>

<tr>
<td>A</td>
<td>A</td>
<td>对称差分</td>
</tr>
</tbody>
</table>

<h3 id="7-6集合类型-1">7.6集合类型</h3>

<h4 id="如何创建集合类型和给集合赋值">如何创建集合类型和给集合赋值</h4>

<p>集合与列表( [ ] )和字典( { } ) 不同，没有特别的语法格式。列表和字典可以分别用他们自 己的工厂方法 list() 和 dict() 创建，这也是集合被创建的唯一方法 - 用集合的工厂方法 set() 和 frozenset():</p>

<p>&gt;&gt;&gt; s = set(&lsquo;cheeseshop&rsquo;)</p>

<p>&gt;&gt;&gt; s</p>

<p>，/ r? ?    ，    ，    ，t ，    ，    ，    ，    ， j 1 </p>

<p>set([&lsquo;c&rsquo;， &lsquo;e&rsquo;， &lsquo;h&rsquo;， &lsquo;o&rsquo;， &lsquo;p&rsquo;， &rsquo;s&rsquo;])</p>

<p>&gt;&gt;&gt; t = frozenset(&lsquo;bookshop&rsquo;)</p>

<p>&gt;&gt;&gt; t</p>

<p>frozenset([&lsquo;b&rsquo;， &lsquo;h&rsquo;， &lsquo;k&rsquo;， &lsquo;o&rsquo;， &lsquo;p&rsquo;， &rsquo;s&rsquo;]) &gt;&gt;&gt; type(s)</p>

<p><type 'set'></p>

<p>&gt;&gt;&gt; type(t)</p>

<p><type 'frozenset'></p>

<p>&gt;&gt;&gt; len(s)</p>

<p>6</p>

<p>&gt;&gt;&gt; len(s) == len(t)</p>

<p><img src="07Python38c3160b-769.jpg" alt="img" /></p>

<p><img src="07Python38c3160b-770.jpg" alt="img" /></p>

<p>True</p>

<p>&gt;&gt;&gt; s == t</p>

<p>False</p>

<h4 id="如何访问集合中的值">如何访问集合中的值</h4>

<p>你可以遍历查看集合成员或检查某项元素是否是一个集合中的成员</p>

<p>&gt;&gt;&gt; &lsquo;k&rsquo; in s</p>

<p>False</p>

<p>&gt;&gt;&gt; &lsquo;k&rsquo; in t</p>

<p>True</p>

<p>&gt;&gt;&gt; &lsquo;c&rsquo; not in t</p>

<p>True</p>

<p>&gt;&gt;&gt; for i in s:</p>

<p>&hellip; print i</p>

<p><img src="07Python38c3160b-771.jpg" alt="img" /></p>

<p>c</p>

<p><img src="07Python38c3160b-772.jpg" alt="img" /></p>

<p>e</p>

<p>h</p>

<p>o</p>

<p>p</p>

<p>s</p>

<h4 id="如何更新集合-用各种集合内建的方法和操作符添加和删除集合的成员">如何更新集合 用各种集合内建的方法和操作符添加和删除集合的成员</h4>

<p>&gt;&gt;&gt; s.add(&lsquo;z&rsquo;)</p>

<p>&gt;&gt;&gt; s</p>

<p>set([&lsquo;c&rsquo;, &lsquo;e&rsquo;, &lsquo;h&rsquo;, &lsquo;o &gt;&gt;&gt; s.update(&lsquo;pypi&rsquo;) &gt;&gt;&gt; s</p>

<p>丄 / r，    ，    ，    ，    ，    •，    1    &gt;</p>

<p>set([&lsquo;c&rsquo;, &lsquo;e&rsquo;, &lsquo;i&rsquo;, &lsquo;h&rsquo; &gt;&gt;&gt; s.remove(&lsquo;z&rsquo;)</p>

<p>&gt;&gt;&gt; s</p>

<p>丄 / r，    ，    ，    ，    ，    •，    1    &gt;</p>

<p>set([&lsquo;c&rsquo;, &lsquo;e&rsquo;, &lsquo;i&rsquo;, &lsquo;h&rsquo;</p>

<p>&gt;&gt;&gt; s -= set(&lsquo;pypi&rsquo;) &gt;&gt;&gt; s</p>

<p>，，    ，，    ，，刁 </p>

<p>&lsquo;p&rsquo;, &rsquo;s&rsquo;, &lsquo;z&rsquo;])</p>

<p>，， ，， ，， ，，</p>

<p>&lsquo;p&rsquo;, &rsquo;s&rsquo;, &lsquo;y&rsquo;, &lsquo;z&rsquo;])</p>

<p>，， ，， ，，</p>

<p>&lsquo;p&rsquo;, &rsquo;s&rsquo;, &lsquo;y&rsquo;])</p>

<p><img src="07Python38c3160b-773.jpg" alt="img" /></p>

<p>set([&lsquo;c&rsquo;, &lsquo;e&rsquo;, &lsquo;h&rsquo;, &lsquo;o&rsquo;, &rsquo;s&rsquo;])</p>

<p>我们之前提到过，只有可变集合能被修改。试图修改不可变集合会引发异常。</p>

<p>&gt;&gt;&gt; t.add(&lsquo;z&rsquo;)</p>

<p>Traceback (most recent call last):</p>

<p>File &ldquo;<stdin>&rdquo;, line 1, in ?</p>

<p>AttributeError: &lsquo;frozenset&rsquo; object has no attribute &lsquo;add&rsquo;</p>

<h4 id="如何删除集合中的成员和集合">如何删除集合中的成员和集合</h4>

<p>前面我们看到如何删除集合成员。如果如何删除集合本身，可以像删除任何Python对象一样， 令集合超出它的作用范围，或调用del将他们直接清除出当前的名字空间。如果它的引用计数为零，</p>

<p>也会被标记以便被垃圾回收。</p>

<p>&gt;&gt;&gt; del s &gt;&gt;&gt;</p>

<p><img src="07Python38c3160b-775.jpg" alt="img" /></p>

<h3 id="7-7-集合类型操作符">7.7 集合类型操作符</h3>

<p><img src="07Python38c3160b-776.jpg" alt="img" /></p>

<p><img src="07Python38c3160b-777.jpg" alt="img" /></p>

<h3 id="7-7-1标准类型操作符-所有的集合类型">7.7.1标准类型操作符(所有的集合类型)</h3>

<h4 id="成员关系-in-not-in">成员关系 (in, not in)</h4>

<p>就序列而言，Python中的in和not in操作符决定某个元素是否是一个集合中的成员。</p>

<p>&gt;&gt;&gt; s = set(&lsquo;cheeseshop&rsquo;)</p>

<p>&gt;&gt;&gt; t = frozenset(&lsquo;bookshop&rsquo;)</p>

<p>&gt;&gt;&gt; &lsquo;k&rsquo; in s</p>

<p>False</p>

<p>&gt;&gt;&gt; &lsquo;k&rsquo; in t</p>

<p>True</p>

<p>&gt;&gt;&gt; &lsquo;c&rsquo; not in t</p>

<p>True</p>

<h4 id="集合等价-不等价">集合等价/不等价</h4>

<p><img src="07Python38c3160b-778.jpg" alt="img" /></p>

<p>等价/不等价被用于在相同或不同的集合之间做比较。两个集合相等是指，对每个集合而言，当</p>

<p>且仅当其中一个集合中的每个成员同时也是另一个集合中的成员。</p>

<p>你也可以说每个集合必须是另一个集合的一个子集，S卩，s &lt;=t和s &gt;=t的值均为真(True), 或(s &lt;= t and s&gt;= t)的值为真(True)。集合等价/不等价与集合的类型或集合成员的顺序无关，</p>

<p>只与集合的元素有关。</p>

<p>&gt;&gt;&gt; s == t False</p>

<p>&gt;&gt;&gt; s != t True</p>

<p>&gt;&gt;&gt; u = frozenset(s)</p>

<p>&gt;&gt;&gt; s == u True</p>

<p>&gt;&gt;&gt; set(&lsquo;posh&rsquo;) == set(&lsquo;shop&rsquo;)</p>

<p>True</p>

<h4 id="子集-超集">子集/超集</h4>

<p>Sets用Python的比较操作符检查某集合是否是其他集合的超集或子集。“小于”符号(〈，〈=) 用来判断子集，“大于”符号( &gt;，&gt;=)用来判断超集。</p>

<p>“小于”和“大于”意味着两个集合在比较时不能相等。等于号允许非严格定义的子集和超 集。</p>

<p>Sets 支持严格( 〈 )子集和非严格 ( 〈= ) 子集， 也支持严格( &gt; )超集和非严格 ( &gt;= ) 超集。只有当第一个集合是第二个集合的严格子集时，我们才称第一个集合“小于”第二个集合， 同理，只有当第一个集合是第二个集合的严格超集时，我们才称第一个集合“大于”第二个集合。</p>

<p>&gt;&gt;&gt; set(&lsquo;shop&rsquo;) 〈 set(&lsquo;cheeseshop&rsquo;)</p>

<p>True</p>

<p>&gt;&gt;&gt; set(&lsquo;bookshop&rsquo;) &gt;= set(&lsquo;shop&rsquo;)</p>

<p>True</p>

<h3 id="7-7-2集合类型操作符-所有的集合类型">7.7.2集合类型操作符(所有的集合类型)</h3>

<p>联合( | )</p>

<p>联合(union)操作和集合的OR(又称可兼析取(inclusive disjunction))其实是等价的，两个集 合的联合是一个新集合，该集合中的每个元素都至少是其中一个集合的成员，卩，属于两个集合其 中之一的成员。联合符号有一个等价的方法，unionO.</p>

<p>&gt;&gt;&gt; s | t</p>

<p>set（［’c’， ’b’， ’e’， ’h’， ’k’， ’o’， ’p’， ’s’］）</p>

<h4 id="交集">交集（ &amp; ）</h4>

<p>你可以把交集操作比做集合的AND（或合取）操作。两个集合的交集是一个新集合，该集合中的每 个元素同时是两个集合中的成员，即，属于两个集合的成员。交集符号有一个等价的方法， intersection（）.</p>

<p>&gt;&gt;&gt; s &amp; t</p>

<p>set（［’h’， ’s’， ’o’， ’p’］</p>

<h4 id="差补-相对补集">差补/相对补集（ - ）</h4>

<p>两个集合（s和t）的差补或相对补集是指一个集合C，该集合中的元素，只属于集合s，而不属 于集合t。差符号有一个等价的方法，differenceO.</p>

<p>&gt;&gt;&gt; s - t</p>

<p>set（［’c’， ’e’］）</p>

<p>对称差分（&rdquo;）    丄</p>

<p>和其他的布尔集合操作相似，对称差分是集合的XOR（又称”异或“ （exclusive disjunction））. _</p>

<p>两个集合（s和t）的对称差分是指另外一个集合C，该集合中的元素，只能是属于集合s或者集合t 的成员，不能同时属于两个集合。对称差分有一个等价的方法，symmetric_difference（）.</p>

<p>&gt;&gt;&gt; s &lsquo; t</p>

<p>set（［’k’， ’b’， ’e’， ’c’］）</p>

<h4 id="混合集合类型操作">混合集合类型操作</h4>

<p>上面的示例中，左边的s是可变集合，而右边的t是一个不可变集合.注意上面使用集合操作 运算符所产生的仍然是可变集合，但是如果左右操作数的顺序反过来，结果就不一样了:</p>

<p>&gt;&gt;&gt; t | s</p>

<p>frozenset（［’c’， ’b’， ’e’， ’h’， ’k’， ’o’， ’p’， ’s’］）</p>

<p>&gt;&gt;&gt; t s</p>

<p>frozenset（［’c’， ’b’， ’e’， ’k’］）</p>

<p>&gt;&gt;&gt; t - s frozenset（［’k’， ’b’］）</p>

<p>如果左右两个操作数的类型相同，既都是可变集合或不可变集合， 则所产生的结果类型是相同</p>

<p>的，但如果左右两个操作数的类型不相同（左操作数是set，右操作数是frozenset，或相反情况），</p>

<p>则所产生的结果类型与左操作数的类型相同，上例中可以证明这一点。还要注意，加号不是集合类</p>

<p>型的运算符:</p>

<p>&gt;&gt;&gt; v = s + t</p>

<p>Traceback (most recent call last):</p>

<p>File &ldquo;<stdin>&rdquo;, line 1, in ?</p>

<p>TypeError: unsupported operand type(s) for +: &lsquo;set&rsquo; and &lsquo;set&rsquo;</p>

<p>&gt;&gt;&gt; v = s | t</p>

<p>&gt;&gt;&gt; v</p>

<p>set([&lsquo;c&rsquo;, &lsquo;b&rsquo;, &lsquo;e&rsquo;, &lsquo;h&rsquo;, &lsquo;k&rsquo;, &lsquo;o&rsquo;, &lsquo;p&rsquo;, &rsquo;s&rsquo;])</p>

<p>&gt;&gt;&gt; len(v)</p>

<p>8</p>

<p>&gt;&gt;&gt; s &lt; v</p>

<p>True</p>

<h3 id="7-7-3集合类型操作符-仅适用于可变集合">7.7.3集合类型操作符(仅适用于可变集合)</h3>

<h4 id="union-update">(Union) Update ( |=)</h4>

<p>这个更新方法从已存在的集合中添加(可能多个)成员，此方法和updateO等价.</p>

<p>»&gt; s = setCcheeseshop&rsquo;</p>

<p>&gt;&gt;&gt; u = frozenset(s)</p>

<p>&gt;&gt;&gt; s |= set(&lsquo;pypi&rsquo;)</p>

<p>&gt;&gt;&gt; s</p>

<p>set([&lsquo;c&rsquo;, &lsquo;e&rsquo;, &lsquo;i&rsquo;, &lsquo;h&rsquo;, &lsquo;o&rsquo;, &lsquo;p&rsquo;, &rsquo;s&rsquo;, &lsquo;y&rsquo;])</p>

<h4 id="保留-交集更新">保留/交集更新( &amp;= )</h4>

<p>保留(或交集更新)操作保留与其他集合的共有成员。此方法和intersection_update()等价.</p>

<p>&gt;&gt;&gt; s = set(u)</p>

<p>&gt;&gt;&gt; s &amp;= set(&lsquo;shop&rsquo;)</p>

<p>&gt;&gt;&gt; s</p>

<p>set([&lsquo;h&rsquo;, &rsquo;s&rsquo;, &lsquo;o&rsquo;, &lsquo;p&rsquo;])</p>

<h4 id="差更新">差更新(-=)</h4>

<p>对集合s和t进行差更新操作s-=t，差更新操作会返回一个集合，该集合中的成员是集合s去 除掉集合t中元素后剩余的元素。此方法和difference_update()等价.</p>

<p>&gt;&gt;&gt; s = set(u)</p>

<p>&gt;&gt;&gt; s -= set(&lsquo;shop&rsquo;)</p>

<p>&gt;&gt;&gt; s</p>

<p>set([&lsquo;c&rsquo;， &lsquo;e&rsquo;])</p>

<h4 id="对称差分更新">对称差分更新(&ldquo;=)</h4>

<p>对集合s和t进行对称差分更新操作(s~=t)，对称差分更新操作会返回一个集合，该集合中的成 员仅是原集合s或仅是另一集合t中的成员。此方法和symmetric_difference_update()等价.</p>

<p>&gt;&gt;&gt; s = set(u)</p>

<p>&gt;&gt;&gt; t = frozenset(&lsquo;bookshop&rsquo;)</p>

<p>&gt;&gt;&gt; s t</p>

<p>&gt;&gt;&gt; s</p>

<p>set([&lsquo;c&rsquo;， &lsquo;b&rsquo;， &lsquo;e&rsquo;， &lsquo;k&rsquo;])</p>

<h3 id="7-8-内建函数">7.8 内建函数</h3>

<p><img src="07Python38c3160b-786.jpg" alt="img" /></p>

<p>7.8.1标准类型函数</p>

<p><img src="07Python38c3160b-787.jpg" alt="img" /></p>

<h4 id="len">len()</h4>

<p>把集合作为参数传递给内建函数len()，返回集合的基数(或元素的个数)。</p>

<h4 id="s-set-u">&gt;&gt;&gt; s = set(u)</h4>

<p>&gt;&gt;&gt; s</p>

<p>set([&lsquo;p&rsquo;， &lsquo;c&rsquo;， &lsquo;e&rsquo;， &lsquo;h&rsquo;， &rsquo;s&rsquo;， &lsquo;o&rsquo;]) &gt;&gt;&gt; len(s)</p>

<h4 id="6">6</h4>

<h3 id="7-8-2集合类型工厂函数">7.8.2集合类型工厂函数</h3>

<h4 id="set-and-frozenset">set() and frozenset()</h4>

<p>set()和frozensetO工厂函数分别用来生成可变和不可变的集合。如果不提供任何参数，默认 会生成空集合。如果提供一个参数，则该参数必须是可迭代的，卩，一个序列，或迭代器，或支持 迭代的一个对象，例如：一个文件或一个字典。</p>

<p><img src="07Python38c3160b-788.jpg" alt="img" /></p>

<p><img src="07Python38c3160b-789.jpg" alt="img" /></p>

<p>&gt;&gt;&gt; set()</p>

<p>set([])</p>

<p>&gt;&gt;&gt; set([])</p>

<p>set([])</p>

<p>&gt;&gt;&gt; set(())</p>

<p>set([])</p>

<p>&gt;&gt;&gt; set(&lsquo;shop&rsquo;)</p>

<p>set([&lsquo;h&rsquo;， &rsquo;s&rsquo;， &lsquo;o&rsquo;， &lsquo;p&rsquo;])</p>

<p>&gt;&gt;&gt;</p>

<p>&gt;&gt;&gt; frozenset([&lsquo;foo&rsquo;， &lsquo;bar&rsquo;]) frozenset([&lsquo;foo&rsquo;， &lsquo;bar&rsquo;])</p>

<p>&gt;&gt;&gt;</p>

<p>&gt;&gt;&gt; f = open(&lsquo;numbers&rsquo;， &lsquo;w&rsquo;)</p>

<p>&gt;&gt;&gt; for i in range(5):</p>

<p>&hellip; f.write(&lsquo;%d\n&rsquo; % i)</p>

<p>&gt;&gt;&gt; f.close()</p>

<p>&gt;&gt;&gt; f = open(&lsquo;numbers&rsquo;， &lsquo;r&rsquo;)</p>

<p>&gt;&gt;&gt; set(f)</p>

<p><img src="07Python38c3160b-790.jpg" alt="img" /></p>

<p>set([&lsquo;0\n&rsquo;， &lsquo;3\n&rsquo;， &lsquo;1\n&rsquo;， &lsquo;4\n&rsquo;， &lsquo;2\n&rsquo;])</p>

<p>&gt;&gt;&gt; f.close()</p>

<h3 id="7-9-集合类型内建方法">7.9 集合类型内建方法</h3>

<h3 id="7-9-1方法-所有的集合方法">7.9.1方法(所有的集合方法)</h3>

<p>我们已看到很多和内建方法等价的操作符，表 7.4 做了小结：</p>

<p>内建方法copy()没有等价的操作符。和同名的字典方法一样，copy()方法比用像set()， frozensetO，或dict()这样的工厂方法复制对象的副本要快。</p>

<p>表7.4 集合类型方法</p>

<p>方法名称    操作</p>

<p>s.issubset(t)</p>

<p>s.issuperset(t)</p>

<p>s.union(t)</p>

<p>s.intersection(t)</p>

<p>如果s是t的子集，则返回True，否则返回False 如果t是s的超集，则返回True，否则返回False 返回一个新集合，该集合是s和t的并集</p>

<p>返回一个新集合，该集合是s和t的交集</p>

<p><img src="07Python38c3160b-791.jpg" alt="img" /></p>

<p>s.difference(t)    返回一个新集合，该集合是s的成员，但不是t的成员</p>

<p>s.symmetric_difference(t)返回一个新集合，该集合是s或t的成员，但不是s和t共有的</p>

<p>成员</p>

<p>s.copy()    返回一个新集合，它是集合s的浅复制</p>

<h3 id="7-9-2方法-仅适用于可变集合">7.9.2方法(仅适用于可变集合)</h3>

<p>表 7.5 总结了所有可变集合的内建方法，和上面的方法相似，我们已经看过许多和它们等价的 操作符。</p>

<p>新的方法有 add(), remove(), discard(), pop(), clear(). 这些接受对象的方法，参数必 须是可哈希的。</p>

<h3 id="7-9-3操作符和内建方法比较">7.9.3操作符和内建方法比较</h3>

<p><img src="07Python38c3160b-793.jpg" alt="img" /></p>

<p>像你看到的， 很多内建的方法几乎和操作符等价。我们说&rdquo;几乎等价&rdquo;，意思是它们间是有一个 重要区别：当用操作符时，操作符两边的操作数必须是集合。在使用内建方法时，对象也可以是 迭代类型的。为什么要用这种方式来实现呢？ Python的文档里写明：采用易懂的 set(’abc’).intersection(’cbs’)可以避免用 set(’abc’)[and] ’cbs’ 这样蓉易出错的构建方 _ 法。</p>

<p>表 7.5 可变集合类型的方法</p>

<p>方法名</p>

<p>s.update(t)</p>

<p>s.intersection_update(t)</p>

<p>s.difference_update(t)</p>

<p>操作</p>

<p>用t中的元素修改s,即，s现在包含s或t的成员 s中的成员是共同属于s和t的元素。 s中的成员是属于s但不包含在t中的元素</p>

<p>s.symmetric_difference_update(t) s中的成员更新为那些包含在s或t中，但不</p>

<p>s.add(obj)</p>

<p>s.remove(obj)</p>

<p>s.discard(obj)</p>

<p>s.pop()</p>

<p>s.clear()</p>

<p>和t共有的元素 在集合s中添加对象obj</p>

<p>从集合s中删除对象obj;如果obj不是集合s中的元素(obj not in s)，将引发KeyError错误</p>

<p>如果obj是集合s中的元素，从集合s中删除对象obj;</p>

<p>删除集合s中的任意一个对象，并返回它 删除集合s中的所有元素</p>

<h3 id="7-10-操作符-函数-方法">7.10 操作符、函数/方法</h3>

<p><img src="07Python38c3160b-794.jpg" alt="img" /></p>

<p><img src="07Python38c3160b-795.jpg" alt="img" /></p>

<p><img src="07Python38c3160b-796.jpg" alt="img" /></p>

<p><img src="07Python38c3160b-797.jpg" alt="img" /></p>

<p><img src="07Python38c3160b-798.jpg" alt="img" /></p>

<p><img src="07Python38c3160b-799.jpg" alt="img" /></p>

<p>集合类型总结表</p>

<p>表 7.6 中，我们总结了所有的集合类型的操作符、函数和方法</p>

<h3 id="7-11-相关模块">7.11 相关模块</h3>

<p>集合（set）模块从2.3版本引进，可继承Set或ImmuteablSet来生成子类。虽然从Python2.4 起使用集合类型，但是集合模块不会弃用。</p>

<p><img src="07Python38c3160b-800.jpg" alt="img" /></p>

<table>
<thead>
<tr>
<th>表7.6 集合类型操作符、函数和方法</th>
<th></th>
<th></th>
</tr>
</thead>

<tbody>
<tr>
<td>函数/方法名</td>
<td>等价运算符</td>
<td>说明</td>
</tr>

<tr>
<td>所有集合类型len（s）</td>
<td></td>
<td>集合基数：集合s中元素的个数</td>
</tr>

<tr>
<td>set([obj])</td>
<td></td>
<td>可变集合工厂函数；obj必须是支持迭代的，由obj中</td>
</tr>

<tr>
<td>frozenset([obj])</td>
<td></td>
<td>的元素创建集合，否则创建一个空集合 不可变集合工厂函数；执行方式和setO方法相同，</td>
</tr>

<tr>
<td></td>
<td>obj in s</td>
<td>但它返回的是不可变集合 成员测试：obj是s中的一个元素吗？</td>
</tr>

<tr>
<td></td>
<td>obj not in s</td>
<td>非成员测试：obj不是s中的一个元素吗？</td>
</tr>

<tr>
<td></td>
<td>s == t</td>
<td>等价测试：测试s和t是否具有相同的元素？</td>
</tr>

<tr>
<td></td>
<td>s != t</td>
<td>不等价测试: 与==相反</td>
</tr>

<tr>
<td></td>
<td>s 〈 t</td>
<td>（严格意义上）子集测试；s != t而且s中所有</td>
</tr>

<tr>
<td>s.issubset(t)</td>
<td>s 〈= t</td>
<td>的元素都是t的成员子集测试（允许不严格意义上的子集）：s中所有的元素</td>
</tr>

<tr>
<td></td>
<td>s &gt; t</td>
<td>都是t的成员（严格意义上）超集测试：s != t而且t中所有的元素</td>
</tr>

<tr>
<td>s.issuperset(t)</td>
<td>s &gt;= t</td>
<td>都是s的成员超集测试（允许不严格意义上的超集）：t中所有的元素</td>
</tr>

<tr>
<td>s.union(t)</td>
<td>s | t</td>
<td>都是s的成员合并操作：s或t中的元素</td>
</tr>

<tr>
<td>s.intersec- tion(t)    s &amp; t</td>
<td>交集操作：s和t中的元素</td>
<td></td>
</tr>

<tr>
<td>s.difference(t)</td>
<td>s - t</td>
<td>差分操作：s中的元素，而不是t中的元素</td>
</tr>

<tr>
<td>s.symmetric_difference(t)s &ldquo; t</td>
<td>对称差分操作：s或t中的元素，但不是s和t共有</td>
<td></td>
</tr>

<tr>
<td>s.copy()</td>
<td></td>
<td>的元素复制操作:返回s的（浅复制）副本</td>
</tr>
</tbody>
</table>

<p>Table 7.6 集合类型，函数和方法（继续）</p>

<p><img src="07Python38c3160b-801.jpg" alt="img" /></p>

<p><img src="07Python38c3160b-802.jpg" alt="img" /></p>

<p><img src="07Python38c3160b-803.jpg" alt="img" /></p>

<p>函数/方法名字</p>

<p>仅用于可变集合</p>

<p>s.update(t)</p>

<p>操作符</p>

<p>等价描述</p>

<p>|= t</p>

<p>s.intersection_update(t) s &amp;= t s.difference<em>update(t) s -= t s.symmetric</em></p>

<p>difference</p>

<p>update(t)</p>

<p>(Union)修改操作：将t中的成员添加s 交集修改操作：s中仅包括s和t中共有的成员</p>

<p>差修改操作：s中包括仅属于s但不属于t的成员</p>

<p>s.add(obj)</p>

<p>s.remove(obj)</p>

<p>s.discard(obj)</p>

<p>s.pop()</p>

<p>s.clear()</p>

<p>对称差分修改操作：s中包括仅属于s或仅属于t的 成员</p>

<p>加操作：将obj添加到s</p>

<p>删除操作：将obj从s中删除；如果s中不存在 obj，将引发 KeyError</p>

<p>丢弃操作: remove() 的 友 好 版 本 - 如 果s    中存在obj，</p>

<p>从s中删除它</p>

<p>Pop操作：移除并返回s中的任意一个元素 清除操作：移除s中的所有元素</p>

<p>以下是一些你可能认为有用的在线参考文章：</p>

<p><a href="http://en.wikipedia.org/wiki/Set">http://en.wikipedia.org/wiki/Set</a> <a href="http://www.geocities.com/basicmathsets/set.htmlhttp://www.math.uah.edu/stat/foundations/Sets.xhtml">http://www.geocities.com/basicmathsets/set.htmlhttp://www.math.uah.edu/stat/foundations/Sets.xhtml</a></p>

<p><img src="07Python38c3160b-805.jpg" alt="img" /></p>

<h3 id="7-12-练习">7.12 练习</h3>

<p>7-1. 字典方法。哪个字典方法可以用来把两个字典合并到一起？</p>

<p>7-2. 字典的键。我们知道字典的值可以是任意的Python对象，那字典的键又如何呢？请试 着将除数字和字符串以外的其他不同类型的对象作为字典的键，看一看，哪些类型可以，哪些不行？ 对那些不能作字典的键的对象类型，你认为是什么原因呢？</p>

<p>7-3. 字典和列表的方法。</p>

<p>(a)    创建一个字典，并把这个字典中的键按照字母顺序显示出来。</p>

<p>(b)    现在根据已按照字母顺序排序好的键，显示出这个字典中的键和值。</p>

<p>&copy;    同(b)，但这次是根据已按照字母顺序排序好的字典的值，显示出这个字典中的键和值。(注 意：对字典和哈希表来说，这样做一般没有什么实际意义，因为大多数访问和排序(如果需要)都是 基于字典的键，这里只把它作为一个练习。)</p>

<p>7-4.    建立字典。给定两个长度相同的列表，比如说，列表［1，2，3，&hellip;］和［&rsquo;abc&rsquo;，’def&rsquo;，</p>

<p>&lsquo;ghi&rsquo;，&hellip;］，用这两个列表里的所有数据组成一个字典，像这样：{1:&lsquo;abc&rsquo;，2: &lsquo;def&rsquo;，3: ’ ghi&rsquo;，&hellip;}</p>

<p><img src="07Python38c3160b-806.jpg" alt="img" /></p>

<p>7-5. userpw2.py.下面的问题和例题7.1中管理名字-密码的键值对数据的程序有关。</p>

<p>(a)修改那个脚本，使它能记录用户上次的登录日期和时间(用time模块)，并与用户密码一起</p>

<p>保存起来。程序的界面有要求用户输入用户名和密码的提示。无论户名是否成功登录，都应有提示， 在户名成功登录后，应更新相应用户的上次登录时间戳。如果本次登录与上次登录在时间上相差不 超过4个小时，则通知该用户： “You already logged in at: <last_ login_timestamp>.”</p>

<p>(b)    添加一个“管理”菜单，其中有以下两项:(1)删除一个用户 (2)显示系统中所有用户的名 字和他们的密码的清单。</p>

<p>&copy;    口令目前没有加密。请添加一段对口令加密的代码(请参考crypt, rotor,或其它加密模块)</p>

<p>(d)    为程序添加图形界面，例如，用Tkinter写。</p>

<p>(e)    要求用户名不区分大小写。</p>

<p>(f)    加强对用户名的限制，不允许符号和空白符。</p>

<p>(g)    合并“新用户”和‘‘老用户”两个选项。如果一个新用户试图用一个不存在的用户名登录， 询问该用户是否是新用户，如果回答是肯定的，就创建该帐户。否则，按照老用户的方式登录。</p>

<p>7-6. 列表和字典。创建一个简单的股票证券投资数据系统。其中应至少包含四项数据：股市 行情显示器符号，所持有的股票，购买价格及当前价位 - 你可以随意添加其他数据项，比如收益率， 52周最高指数、最低指数，等等。</p>

<p>用户每次输入各列的数据构成一个输出行。每行数据构成一个列表。还有一个总列表，包括了 所有行的数据。数据输入完毕后，提示用户选择一列数据项进行排序。把该数据项抽取出来作为字 典的键，字典的值就是该键对应行的值的列表。提醒读者：被选择用来排序的数据项必须是非重复 的键，否则就会丢失数据，因为字典不允许一个键有多个值。</p>

<p><img src="07Python38c3160b-808.jpg" alt="img" /></p>

<p>你还可以选择其他计算输出，比如，盈亏比率，目前证券资产价值等。</p>

<p>7-7. 颠倒字典中的键和值。用一个字典做输入，输出另一个字典，用前者的键做值，前者的 值做键。</p>

<p>7-8. 人力资源。创建一个简单的雇员姓名和编号的程序。让用户输入一组雇员姓名和编号。 你的程序可以提供按照姓名排序输出的功能，雇员姓名显示在前面，后面是对应的雇员编号。附加 题：添加一项功能，按照雇员编号的顺序输出数据。</p>

<p>7-9. 翻译</p>

<p>(a)编写一个字符翻译程序(功能类似于Unix中的tr命令)。我们将这个函数叫做tr()它有 三个字符串做参数: 源字符串、目的字符串、基本字符串，语法定义如下：</p>

<p>def tr(srcstr, dststr, string)</p>

<p>srcstr的内容是你打算“翻译”的字符集合，dsrstr是翻译后得到的字符集合，而string是 你打算进行翻译操作的字符串。举例来说，如果 srcstr == &lsquo;abc&rsquo;, dststr == &lsquo;mno&rsquo;, string == ’abcdef’，那么 tr()的输出将是&rsquo;mnodef&rsquo;.注意这里 len(srcstr) == len(dststr).</p>

<p>在这个练习里，你可以使用内建函数chr()和ord(),但它们并不一定是解决这个问题所必不 可少的函数。</p>

<p>(b) 在这个函数里增加一个标志符参数，来处理不区分大小写的翻译问题。</p>

<p><img src="07Python38c3160b-810.jpg" alt="img" /></p>

<p>&copy;修改你的程序，使它能够处理删除字符的操作。字符串srcstr中不能够映射到字符串dststr 中字符的多余字符都将被过滤掉。换句话说，这些字符没有映射到dststr字符串中的任何字符，因 此就从函数返回的字符里被过滤掉了。举例来说：如果 srcstr == &lsquo;abcdef&rsquo;， dststr == &lsquo;mno&rsquo;， string == &lsquo;abcdefghi&rsquo;，那么 tr()将输出&rsquo;mnoghi&rsquo;.注意这里 len(srcstr) &gt;= len(dststr).</p>

<p>7-10. 加密。</p>

<p>(a)    用上一个练习的思路编写一个〃rot13&rdquo;翻译器。&rdquo;rot13&rdquo;是一个古老而又简单的加密方法， 它把字母表中的每个字母用其后的第13个字母来代替。字母表中前半部分字母将被映射到后半部分， 而后半部分字母将被映射到前半部分，大小写保持不变。举例来说，’a&rsquo;将被替换为’n’，’X’将被替 换为&rsquo;K&rsquo;;数字和符号不进行翻译。</p>

<p>(b)    在你的解决方案的基础上加一个应用程序，让它提示用户输入准备加密的字符串(这个算法 同时也可以对加密后的字符串进行解密)，如下所示:</p>

<p>% rot13.py</p>

<p>Enter string to rot13: This is a short sentence. Your string to en/decrypt was is a short sentence.].</p>

<p>[This</p>

<p>[Guvf</p>

<p>The rot13 string is: [Guvf vf n fubeg fragrapr.].</p>

<p>%</p>

<p><img src="07Python38c3160b-811.jpg" alt="img" /></p>

<p>% rot13.py</p>

<p>Enter string to rot13: Guvf vf n fubeg fragrapr. Your string to en/decrypt was vf n fubeg fragrapr.].</p>

<p>The rot13 string is: [This is a short sentence.].</p>

<p>7-11. 定义。什么组成字典中合法的键? 举例说明字典中合法的键和非法的键。</p>

<p>7-12. 定义。</p>

<p>(a)    在数学上，什么是集合？</p>

<p>(b)    在Python中，关于集合类型的定义是什么？</p>

<p>7-13. 随机数。修改练习5-17的代码：使用random模块中的randintO或randrangeO方 法生成一个随机数集合：从0到9(包括9)中随机选择，生成1到10个随机数。这些数字组成集合 A(A可以是可变集合，也可以不是)。同理，按此方法生成集合B。每次新生成集合A和B后，显示</p>

<p>结果 A | B 和 A &amp; B</p>

<p>7-14. 用户验证。修改前面的练习，要求用户输入A | B和A&amp; B的结果，并告诉用户他(或 她)的答案是否正确，而不是将A | B和A&amp;B的结果直接显示出来。如果用户回答错误，允许他(或 她)修改解决方案，然后重新验证用户输入的答案。如果用户三次提交的答案均不正确，程序将显示 正确结果。</p>

<p>附加题：运用你关于集合的知识，创建某个集合的潜在子集，并询问用户此潜在子集是否真是</p>

<p>该集合的子集，要求和主程序一样有显示更正和答案的功能。</p>

<p><img src="07Python38c3160b-813.jpg" alt="img" /></p>

<p>7-15. 编写计算器。这个练习取材于<a href="http://math.hws.edu/在线免费Java教材中的练习">http://math.hws.edu/在线免费Java教材中的练习</a> 12.2。编写一个程序允许用户选择两个集合:A和B，及运算操作符。例如，in，not in，&amp;，|，~，＜， 〈=，＞，＞=，==，！=，等.（你自己定义集合的输入语法，它们并不一定要像Java示例中那样用方括 号括住。）解析输入的字符串，按照用户选择的运算进行操作。你写的程序代码应该比Java版本的 该程序更简洁。</p>

    </div>

    
    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">iterateself</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">2018-06-26</span>
  </p>
  
  
</div>

    
    

    <footer class="post-footer">
      

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02-python/python-%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/06-%E5%BA%8F%E5%88%97%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%A5%96/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">06 序列：字符串、列表和元祖</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02-python/python-%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/08-%E6%9D%A1%E4%BB%B6%E5%92%8C%E5%BE%AA%E7%8E%AF/">
            <span class="next-text nav-default">08 条件和循环</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="iteratelyd@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="http://github.com/iterateself" class="iconfont icon-github" title="github"></a>
      <a href="https://www.zhihu.com/people/thebegin/activities" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="https://www.douban.com/people/68028070/" class="iconfont icon-douban" title="douban"></a>
  <a href="http://iterate.site/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> site pv: <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
    <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> site uv: <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2018
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">iterateself</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>


<script type="text/javascript" src="/dist/even.min.js?v=3.2.0"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>








</body>
</html>
