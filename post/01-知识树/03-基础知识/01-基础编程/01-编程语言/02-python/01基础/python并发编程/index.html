<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>python并发编程 - 迭代自己</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="iterateself" />
  <meta name="description" content="author: evo comments: true date: 2018-03-22 15:58:01&#43;00:00 layout: post link: http://106.15.37.116/2018/03/22/python-threading-multiprocessing/ slug: python-threading-multiprocessing title: python并发编程 wordpress_id: 589 categories: - 随想与反思 tags: - &amp;lsquo;@todo&amp;rsquo; - python 缘由： 之前看过，但是没有总结，又忘记了，因此总结下。 要点： 1.进" />

  <meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.47.1" />


<link rel="canonical" href="http://iterate.site/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02-python/01%E5%9F%BA%E7%A1%80/python%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">




<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<link href="/dist/even.min.css?v=3.2.0" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">




<meta property="og:title" content="python并发编程" />
<meta property="og:description" content="author: evo comments: true date: 2018-03-22 15:58:01&#43;00:00 layout: post link: http://106.15.37.116/2018/03/22/python-threading-multiprocessing/ slug: python-threading-multiprocessing title: python并发编程 wordpress_id: 589 categories: - 随想与反思 tags: - &lsquo;@todo&rsquo; - python 缘由： 之前看过，但是没有总结，又忘记了，因此总结下。 要点： 1.进" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://iterate.site/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02-python/01%E5%9F%BA%E7%A1%80/python%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" /><meta property="article:published_time" content="2018-06-18T18:07:33&#43;00:00"/>
<meta property="article:modified_time" content="2018-06-18T18:07:33&#43;00:00"/>
<meta itemprop="name" content="python并发编程">
<meta itemprop="description" content="author: evo comments: true date: 2018-03-22 15:58:01&#43;00:00 layout: post link: http://106.15.37.116/2018/03/22/python-threading-multiprocessing/ slug: python-threading-multiprocessing title: python并发编程 wordpress_id: 589 categories: - 随想与反思 tags: - &lsquo;@todo&rsquo; - python 缘由： 之前看过，但是没有总结，又忘记了，因此总结下。 要点： 1.进">


<meta itemprop="datePublished" content="2018-06-18T18:07:33&#43;00:00" />
<meta itemprop="dateModified" content="2018-06-18T18:07:33&#43;00:00" />
<meta itemprop="wordCount" content="2139">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="python并发编程"/>
<meta name="twitter:description" content="author: evo comments: true date: 2018-03-22 15:58:01&#43;00:00 layout: post link: http://106.15.37.116/2018/03/22/python-threading-multiprocessing/ slug: python-threading-multiprocessing title: python并发编程 wordpress_id: 589 categories: - 随想与反思 tags: - &lsquo;@todo&rsquo; - python 缘由： 之前看过，但是没有总结，又忘记了，因此总结下。 要点： 1.进"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">迭代自己</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">主页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a><a href="/catalog/">
        <li class="mobile-menu-item">目录</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">迭代自己</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">主页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/catalog/">目录</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">python并发编程</h1>

      <div class="post-meta">
        <span class="post-time"> 2018-06-18 </span>
        
        <span class="more-meta"> 2139 words </span>
        <span class="more-meta"> 5 mins read </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> times read </span>
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  
  <div class="post-toc-content">
    <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#python">- python</a></li>
<li><a href="#缘由">缘由：</a></li>
<li><a href="#要点">要点：</a>
<ul>
<li><a href="#1-进程与线程的基本概念">1.进程与线程的基本概念：</a></li>
<li><a href="#2-python中的gil-以及因此而出现的multiprocessing库">2.python中的GIL，以及因此而出现的multiprocessing库</a></li>
<li><a href="#3-线程的实例">3.线程的实例：</a></li>
<li><a href="#4-使用multiprocessing-来执行多进程">4.使用multiprocessing 来执行多进程</a></li>
<li><a href="#5-进程间通讯queue">5.进程间通讯Queue</a></li>
<li><a href="#6-进程池pool">6.进程池pool</a></li>
<li><a href="#7-thread与process的对比">7.thread与process的对比：</a></li>
<li><a href="#8-fork操作">8.fork操作</a></li>
</ul></li>
<li><a href="#comment">COMMENT：</a></li>
</ul></li>
</ul>
</nav>
  </div>
</div>

    
    

    
    <div class="post-content">
      

<hr />

<p>author: evo
comments: true
date: 2018-03-22 15:58:01+00:00
layout: post
link: <a href="http://106.15.37.116/2018/03/22/python-threading-multiprocessing/">http://106.15.37.116/2018/03/22/python-threading-multiprocessing/</a>
slug: python-threading-multiprocessing
title: python并发编程
wordpress_id: 589
categories:
- 随想与反思
tags:
- &lsquo;@todo&rsquo;</p>

<h2 id="python">- python</h2>

<!-- more -->

<h2 id="缘由">缘由：</h2>

<p>之前看过，但是没有总结，又忘记了，因此总结下。</p>

<h2 id="要点">要点：</h2>

<h3 id="1-进程与线程的基本概念">1.进程与线程的基本概念：</h3>

<p>进程：程序的一次执行（程序装载入内存，系统分配资源运行）。</p>

<ul>
<li>每个进程有自己的内存空间、数据栈等，只能使用进程间通讯，而不能直接共享信息。</li>
</ul>

<p>线程：所有线程运行在同一个进程中，共享相同的运行环境。</p>

<ul>
<li><p>每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。</p></li>

<li><p>线程的运行可以被抢占（中断），或暂时被挂起（睡眠），让其他线程运行（让步）。</p></li>

<li><p>一个进程中的各个线程间共享同一片数据空间。</p></li>
</ul>

<h3 id="2-python中的gil-以及因此而出现的multiprocessing库">2.python中的GIL，以及因此而出现的multiprocessing库</h3>

<p>GIL全称全局解释器锁 Global Interpreter Lock，<strong>GIL并不是Python的特性，它是在实现Python解析器(CPython)时所引入的一个概念。（还是没明白？）</strong>GIL是一把全局排他锁，<strong>同一时刻只有一个线程在运行。</strong></p>

<p>毫无疑问全局锁的存在会对多线程的效率有不小影响。甚至就几乎等于Python是个单线程的程序。</p>

<p>multiprocessing库的出现很大程度上是为了弥补thread库因为GIL而低效的缺陷。它完整的复制了一套thread所提供的接口方便迁移。唯一的不同就是<strong>它使用了多进程而不是多线程。每个进程有自己的独立的GIL，因此也不会出现进程之间的GIL争抢。</strong></p>

<h3 id="3-线程的实例">3.线程的实例：</h3>

<p>顺序执行两个单线程：</p>

<pre><code class="language-python">from threading import Thread
import time
</code></pre>

<p>​</p>

<pre><code class="language-python">def my_counter():
    i = 0
    for _ in range(100000000):
        i = i + 1
    return True
</code></pre>

<p>​</p>

<pre><code class="language-python">def main():
    thread_array = {}
    start_time = time.time()
    for tid in range(2):
        t = Thread(target=my_counter)  # 设定线程
        t.start()
        t.join()  # wait until the thread terminates
    end_time = time.time()
    print(&quot;Total time: {}&quot;.format(end_time - start_time))
</code></pre>

<p>​</p>

<pre><code class="language-python">if __name__ == '__main__':
    main()
</code></pre>

<p>输出：</p>

<pre><code>Total time: 16.03777527809143
</code></pre>

<p>执行两个并发线程：</p>

<pre><code>from threading import Thread
import time
</code></pre>

<p>​<br />
    def my_counter():
        i = 0
        for _ in range(100000000):
            i = i + 1
        return True</p>

<p>​<br />
    def main():
        thread_array = {}
        start_time = time.time()
        for tid in range(2):
            t = Thread(target=my_counter)  # 设定线程
            t.start()
            thread_array[tid] = t
        for tid in range(2):
            thread_array[tid].join()
        end_time = time.time()
        print(&ldquo;Total time: {}&ldquo;.format(end_time - start_time))</p>

<p>​<br />
    if <strong>name</strong> == &lsquo;<strong>main</strong>&lsquo;:
        main()</p>

<p>输出：</p>

<pre><code>Total time: 16.30307173728943
</code></pre>

<p>注：可见，在python中使用thread实际上没有起到节省时间的作用。</p>

<h3 id="4-使用multiprocessing-来执行多进程">4.使用multiprocessing 来执行多进程</h3>

<p>简单的使用：</p>

<pre><code>from multiprocessing import Process
import time
def f(n):
    time.sleep(1)
    print(n*n)

if __name__ == '__main__':
    for i in range(10):
        p=Process(target=f,args=[i,])
        p.start()
</code></pre>

<p>注：这个程序如果用单进程写则需要执行10秒以上的时间，而用多进程则启动10个进程并行执行，只需要用1秒多的时间。<strong>但是感觉这个例子还是有点太简单了。有没有更加全面的。</strong></p>

<h3 id="5-进程间通讯queue">5.进程间通讯Queue</h3>

<pre><code>from multiprocessing import Process, Queue
import time
</code></pre>

<p>​<br />
    def write(q):
        for i in [&lsquo;a&rsquo;, &lsquo;b&rsquo;, &lsquo;c&rsquo;, &rsquo;d&rsquo;, &lsquo;e&rsquo;]:
            print(&lsquo;Put %s to queue&rsquo; % i)
            q.put(i)
            time.sleep(0.5)</p>

<p>​<br />
    def read(q):
        while True:
            v = q.get(True)
            print(&lsquo;get %s from queue&rsquo; % v)
            if (v == &lsquo;e&rsquo;):
                break</p>

<p>​<br />
    if <strong>name</strong> == &lsquo;<strong>main</strong>&lsquo;:
        # QUESTION普通的队列可以传到不同的进程里面吗？还是一定要是Process里面的？
        q = Queue()
        pw = Process(target=write, args=[q, ])
        pr = Process(target=read, args=[q, ])
        pw.start()
        pr.start()
        # 然后不停的读
        pr.join()
        pr.terminate()</p>

<p>输出：</p>

<pre><code>Put a to queue
get a from queue
Put b to queue
get b from queue
Put c to queue
get c from queue
Put d to queue
get d from queue
Put e to queue
get e from queue
</code></pre>

<p>注：<strong>除了queue之外还提供了哪些类型？</strong></p>

<h3 id="6-进程池pool">6.进程池pool</h3>

<pre><code>from multiprocessing import Pool
import time
</code></pre>

<p>​<br />
    def func(x):
        print(x * x)
        time.sleep(2)
        return x * x</p>

<p>​<br />
    if <strong>name</strong> == &lsquo;<strong>main</strong>&lsquo;:</p>

<pre><code>    pool = Pool(processes=5)  # 定义启动的进程数量
    result_list = []
    for i in range(10):
        # 以异步并行的方式启动进程，
        res = pool.apply_async(func, [i, ])  # 如果是async的，res是一个applyResult，如果不是async，res就是func的返回值
        print('-------:', i, res)
        result_list.append(res)

    pool.close()  # 为什么这个地方是close？
    pool.join()
    for res in result_list:
        print('result', (res.get(timeout=5)))  # get是什么？
</code></pre>

<p>输出：</p>

<pre><code>-------: 0 &lt;multiprocessing.pool.ApplyResult object at 0x0000024BE2369D30&gt;
0
-------: 1 &lt;multiprocessing.pool.ApplyResult object at 0x0000024BE2369E10&gt;
-------: 2 &lt;multiprocessing.pool.ApplyResult object at 0x0000024BE2369EB8&gt;
-------: 3 &lt;multiprocessing.pool.ApplyResult object at 0x0000024BE2369F60&gt;
-------: 4 &lt;multiprocessing.pool.ApplyResult object at 0x0000024BE2369FD0&gt;
-------: 5 &lt;multiprocessing.pool.ApplyResult object at 0x0000024BE23890F0&gt;
-------: 6 &lt;multiprocessing.pool.ApplyResult object at 0x0000024BE2389198&gt;
-------: 7 &lt;multiprocessing.pool.ApplyResult object at 0x0000024BE2389240&gt;
-------: 8 &lt;multiprocessing.pool.ApplyResult object at 0x0000024BE23892E8&gt;
-------: 9 &lt;multiprocessing.pool.ApplyResult object at 0x0000024BE2389390&gt;
1
4
9
16
25
36
49
64
81
result 0
result 1
result 4
result 9
result 16
result 25
result 36
result 49
result 64
result 81
</code></pre>

<p>注：<strong>关于pool，上面的pool.close()是什么意思？而且pool一般在什么情况下使用？</strong></p>

<h3 id="7-thread与process的对比">7.thread与process的对比：</h3>

<pre><code>from multiprocessing import Process
import threading
import time

lock = threading.Lock()  # threading的lock的使用
</code></pre>

<p>​<br />
    def run(info_list, n):
        lock.acquire()
        info_list.append(n)
        lock.release()
        print(&lsquo;%s&rsquo; % info_list)</p>

<p>​<br />
    if <strong>name</strong> == &lsquo;<strong>main</strong>&lsquo;:
        info = []
        print(&lsquo;&mdash;processing&mdash;&rsquo;)
        for i in range(10):
            # target为子进程执行的函数，args为需要给函数传递的参数
            # 可见对于进程来说，当info在进程的函数中被修改的时候，实际上修改的并不是主进程的info，看来只能通过multiprocess的Queue才行
            p = Process(target=run, args=[info, i])
            p.start()
            p.join()
        time.sleep(1)
        print(&lsquo;&mdash;threading&mdash;-&rsquo;)
        for i in range(10):
            # 而therad可以看出，每次修改的实际上就是主进程的info
            p = threading.Thread(target=run, args=[info, i])
            p.start()
            p.join()</p>

<p>输出：</p>

<pre><code>---processing---
[0]
[1]
[2]
[3]
[4]
[5]
[6]
[7]
[8]
[9]
---threading----
[0]
[0, 1]
[0, 1, 2]
[0, 1, 2, 3]
[0, 1, 2, 3, 4]
[0, 1, 2, 3, 4, 5]
[0, 1, 2, 3, 4, 5, 6]
[0, 1, 2, 3, 4, 5, 6, 7]
[0, 1, 2, 3, 4, 5, 6, 7, 8]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>

<p>可见：对于process来说，当info在进程的函数中被修改的时候，实际上修改的并不是主进程的info，看来只能通过multiprocessing的Queue才能完成进程间的沟通。而对于therad来说，每次修改的实际上就是主进程的info。</p>

<p>注：<strong>对于lock还需要了解下</strong></p>

<h3 id="8-fork操作">8.fork操作</h3>

<p>调用一次，返回两次。因为操作系统自动把当前进程（称为父进程）复制了一份（称为子进程），然后分别在父进程和子进程内返回。</p>

<p>子进程永远返回0，而父进程返回子进程的ID。子进程只需要调用getppid()就可以拿到父进程的ID。</p>

<pre><code>import os

print('Process (%s) start...' % os.getpid())
pid = os.fork()
if pid == 0:
    print('I am child process (%s) and my parent is (%s)' % (os.getpid(), os.getppid()))
else:
    print('I (%s) just created a child process (%s).' % (os.getpid(), pid))
</code></pre>

<p>注：这个在windows下报错：AttributeError: module &lsquo;os&rsquo; has no attribute &lsquo;fork&rsquo;  <strong>视频中说在linux下可以的，要试下，而且fork到底是什么功能？快速在子进程和父进程之间进行切换和调用？如果windows上没有fork，又替代的吗？</strong></p>

<h2 id="comment">COMMENT：</h2>

<p><strong>感觉进程还是又很多需要知道的，要进行补充</strong></p>

    </div>

    
    

    
    

    <footer class="post-footer">
      

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/05-%E5%9F%BA%E7%A1%80%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/03-%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/js/prettify-%E4%BD%BF%E7%94%A8/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Prettify 使用</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/02-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E4%B8%8E%E8%AE%A1%E7%AE%97/%E6%95%B0%E6%8D%AE%E5%BA%93/sqlite-%E5%A4%8D%E5%88%B6%E8%A1%A8/">
            <span class="next-text nav-default">Sqlite 复制表</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="iteratelyd@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="http://github.com/iterateself" class="iconfont icon-github" title="github"></a>
      <a href="https://www.zhihu.com/people/thebegin/activities" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="https://www.douban.com/people/68028070/" class="iconfont icon-douban" title="douban"></a>
  <a href="http://iterate.site/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> site pv: <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
    <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> site uv: <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2018
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">iterateself</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>


<script type="text/javascript" src="/dist/even.min.js?v=3.2.0"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>








</body>
</html>
