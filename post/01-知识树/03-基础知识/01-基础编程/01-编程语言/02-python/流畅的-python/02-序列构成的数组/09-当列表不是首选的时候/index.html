<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>09 当列表不是首选的时候 - 迭代自己</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="iterateself" />
  <meta name="description" content="2.9 当列表不是首选时 虽然列表既灵活又简单，但面对各类需求时，我们可能会有更好的选择。比如，要存放 1000万个浮点数的话，数组（array）的效" />

  <meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.47.1" />


<link rel="canonical" href="http://iterate.site/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02-python/%E6%B5%81%E7%95%85%E7%9A%84-python/02-%E5%BA%8F%E5%88%97%E6%9E%84%E6%88%90%E7%9A%84%E6%95%B0%E7%BB%84/09-%E5%BD%93%E5%88%97%E8%A1%A8%E4%B8%8D%E6%98%AF%E9%A6%96%E9%80%89%E7%9A%84%E6%97%B6%E5%80%99/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">




<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<link href="/dist/even.min.css?v=3.2.0" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">




<meta property="og:title" content="09 当列表不是首选的时候" />
<meta property="og:description" content="2.9 当列表不是首选时 虽然列表既灵活又简单，但面对各类需求时，我们可能会有更好的选择。比如，要存放 1000万个浮点数的话，数组（array）的效" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://iterate.site/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02-python/%E6%B5%81%E7%95%85%E7%9A%84-python/02-%E5%BA%8F%E5%88%97%E6%9E%84%E6%88%90%E7%9A%84%E6%95%B0%E7%BB%84/09-%E5%BD%93%E5%88%97%E8%A1%A8%E4%B8%8D%E6%98%AF%E9%A6%96%E9%80%89%E7%9A%84%E6%97%B6%E5%80%99/" /><meta property="article:published_time" content="2018-07-11T15:00:11&#43;00:00"/>
<meta property="article:modified_time" content="2018-07-11T15:00:11&#43;00:00"/>
<meta itemprop="name" content="09 当列表不是首选的时候">
<meta itemprop="description" content="2.9 当列表不是首选时 虽然列表既灵活又简单，但面对各类需求时，我们可能会有更好的选择。比如，要存放 1000万个浮点数的话，数组（array）的效">


<meta itemprop="datePublished" content="2018-07-11T15:00:11&#43;00:00" />
<meta itemprop="dateModified" content="2018-07-11T15:00:11&#43;00:00" />
<meta itemprop="wordCount" content="6439">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="09 当列表不是首选的时候"/>
<meta name="twitter:description" content="2.9 当列表不是首选时 虽然列表既灵活又简单，但面对各类需求时，我们可能会有更好的选择。比如，要存放 1000万个浮点数的话，数组（array）的效"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">迭代自己</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">最近</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a><a href="/catalog/">
        <li class="mobile-menu-item">完整目录</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">迭代自己</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">最近</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/catalog/">完整目录</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">09 当列表不是首选的时候</h1>

      <div class="post-meta">
        <span class="post-time"> 2018-07-11 </span>
        
        <span class="more-meta"> 6439 words </span>
        <span class="more-meta"> 13 mins read </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> times read </span>
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  
  <div class="post-toc-content">
    <nav id="TableOfContents">
<ul>
<li>
<ul>
<li>
<ul>
<li><a href="#2-9-当列表不是首选时">2.9 当列表不是首选时</a>
<ul>
<li><a href="#从-python-3-4-开始-数组类型不再支持诸如-list-sort-这种就地排序方法-要给-数组排序的话-得用-sorted-函数新建一个数组">从 Python 3.4 开始，数组类型不再支持诸如 list.sort() 这种就地排序方法。要给 数组排序的话，得用 sorted 函数新建一个数组：</a></li>
<li><a href="#❸当试图对一个己满-len-d-d-maxlen-的队列做尾部添加操作的时候-它头部-的元素会被删除掉-注意在下一行里-元素-0-被删除了">❸当试图对一个己满（len（d） == d.maxlen）的队列做尾部添加操作的时候，它头部 的元素会被删除掉。注意在下一行里，元素 0 被删除了。</a></li>
<li><a href="#表2-3总结了列表和双向队列这两个类型的方法-object类包含的方法除外">表2-3总结了列表和双向队列这两个类型的方法（object类包含的方法除外）。</a></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</nav>
  </div>
</div>

    
    

    
    <div class="post-content">
      

<h3 id="2-9-当列表不是首选时">2.9 当列表不是首选时</h3>

<p>虽然列表既灵活又简单，但面对各类需求时，我们可能会有更好的选择。比如，要存放</p>

<p>1000万个浮点数的话，数组（array）的效率要高得多，因为数组在背后存的并不是</p>

<p>float 对象，而是数字的机器翻译，也就是字节表述。这一点就跟 C 语言中的数组一</p>

<p>样。再比如说，如果需要频繁对序列做先进先出的操作，deque （双端队列）的速度应该</p>

<p>会更快。</p>

<p>如果在你的代码里，包含操作（比如检查一个元素是否出现在一个集合中）的 频率很高，用set （集合）会更合适。set专为检查元素是否存在做过优化。但是它 并不是序列，因为 set 是无序的。第 3 章会详细讨论它。</p>

<p>本章余下的内容都是关于在某些情况下可以替换列表的数据类型的，让我们从数组开始。</p>

<p>2.9.1 数组</p>

<p>如果我们需要一个只包含数字的列表，那么 array.array 比 list 更高效。数组支持所 有跟可变序列有关的操作，包括.pop、 .insert和.extend。另外，数组还提供从文件 读取和存入文件的更快的方法，如 .frombytes 和 .tofile。</p>

<p>Python 数组跟 C 语言数组一样精简。创建数组需要一个类型码，这个类型码用来表示在 底层的C语言应该存放怎样的数据类型。比如b类型码代表的是有符号的字符（signed char），因此array（&rsquo;b&rsquo;）创建出的数组就只能存放一个字节大小的整数，范围从-128 到 127，这样在序列很大的时候，我们能节省很多空间。而且 Python 不会允许你在数组里 存放除指定类型之外的数据。</p>

<p>示例 2-20 展示了从创建一个有 1000 万个随机浮点数的数组开始，到如何把这个数组存放 到文件里，再到如何从文件读取这个数组。</p>

<p>示例 2-20 一个浮点型数组的创建、存入文件和从文件读取的过程</p>

<p>&gt;&gt;&gt; from array import array O</p>

<p>&gt;&gt;&gt; from random import random</p>

<p>&gt;&gt;&gt; floats = array(&rsquo;d&rsquo;, (random() for i in range(10**7)))    ©</p>

<p>&gt;&gt;&gt; floats[-1] ©</p>

<p>0.07802343889111107</p>

<p>&gt;&gt;&gt; fp = open(&lsquo;floats.bin&rsquo;, &lsquo;wb&rsquo;)</p>

<p>&gt;&gt;&gt; floats.tofile(fp) ©</p>

<p>&gt;&gt;&gt; fp.close()</p>

<p>&gt;&gt;&gt; floats2 = array(&rsquo;d&rsquo;) ❺</p>

<p>&gt;&gt;&gt; fp = open(&lsquo;floats.bin&rsquo;, &lsquo;rb&rsquo;)</p>

<p>&gt;&gt;&gt; floats2.fromfile(fp, 10**7)    ©</p>

<p>&gt;&gt;&gt; fp.close()</p>

<p>&gt;&gt;&gt; floats2[-1] ©</p>

<p>0.07802343889111107</p>

<p>&gt;&gt;&gt; floats2 == floats ❻</p>

<p>❶ 引入 array 类型。</p>

<p>❷利用一个可迭代对象来建立一个双精度浮点数组（类型码是&rsquo;d&rsquo;），这里我们用的可 迭代对象是一个生成器表达式。</p>

<p>❸ 查看数组的最后一个元素。</p>

<p>❹ 把数组存入一个二进制文件里。</p>

<p>❺ 新建一个双精度浮点空数组。</p>

<p>❻ 把 1000 万个浮点数从二进制文件里读取出来。</p>

<p>❼ 查看新数组的最后一个元素。</p>

<p>❽ 检查两个数组的内容是不是完全一样。</p>

<p>从上面的代码我们能得出结论， array.tofile 和 array.fromfile 用起来很简单。把 这段代码跑一跑，你还会发现它的速度也很快。一个小试验告诉我，用 array.fromfile 从一个二进制文件里读出 1000 万个双精度浮点数只需要 0.1 秒，这比从文本文件里读取 的速度要快 60 倍，因为后者会使用内置的 float 方法把每一行文字转换成浮点数。另 外，使用 array.tofile 写入到二进制文件，比以每行一个浮点数的方式把所有数字写 入到文本文件要快 7 倍。另外， 1000 万个这样的数在二进制文件里只占用 80 000 000 个 字节（每个浮点数占用 8 个字节，不需要任何额外空间），如果是文本文件的话，我们需 要 181 515 739 个字节。</p>

<p>另外一个快速序列化数字类型的方法是使用 pickle （<a href="https://docs.python.org/3/library/pickle.html">https://docs+python+org/3/library/pickle+html</a>）模块。pickle.dump 处理浮点</p>

<p>数组的速度几乎跟 array.tofile 一样快。不过前者可以处理几乎所有的内置数字 类型，包含复数、嵌套集合，甚至用户自定义的类。前提是这些类没有什么特别复杂</p>

<p>的实现。</p>

<p>还有一些特殊的数字数组，用来表示二进制数据，比如光栅图像。里面涉及的 bytes 和 bytearry 类型会在第 4 章提及。</p>

<p>表 2-2 对数组和列表的功能做了一些总结。</p>

<p>表2-2：列表和数组的属性和方法（不包含过期的数组方法以及那些由对象实现的方</p>

<p>法）</p>

<table>
<thead>
<tr>
<th></th>
<th>列表</th>
<th>数组</th>
<th></th>
</tr>
</thead>

<tbody>
<tr>
<td></td>
<td>n</td>
<td>n</td>
<td></td>
</tr>
</tbody>
</table>

<table>
<thead>
<tr>
<th>s.<strong>add(s2)</strong></th>
<th></th>
<th></th>
<th>s + s2 ，拼接</th>
</tr>
</thead>

<tbody>
<tr>
<td>s.<strong>iadd(s2)</strong></td>
<td>•</td>
<td>•</td>
<td>s += s2，就地拼接</td>
</tr>

<tr>
<td>s.append(e)</td>
<td>•</td>
<td>•</td>
<td>在尾部添加一个元素</td>
</tr>

<tr>
<td>s.byteswap</td>
<td></td>
<td>•</td>
<td>翻转数组内每个元素的字节序列，转换字节序</td>
</tr>

<tr>
<td>s.clear()</td>
<td>•</td>
<td></td>
<td>删除所有元素</td>
</tr>

<tr>
<td>s.<strong>contains</strong>(e)</td>
<td>•</td>
<td>•</td>
<td>s是否含有e</td>
</tr>

<tr>
<td>s.copy()</td>
<td>•</td>
<td></td>
<td>对列表浅复制</td>
</tr>

<tr>
<td>s.<strong>copy</strong>()</td>
<td></td>
<td>•</td>
<td>对 copy.copy 的支持</td>
</tr>

<tr>
<td>s.count(e)</td>
<td>•</td>
<td>•</td>
<td>s中e出现的次数</td>
</tr>

<tr>
<td>s.<strong>deepcopy</strong>()</td>
<td></td>
<td>•</td>
<td>对 copy.de epcopy 的支持</td>
</tr>

<tr>
<td>s.<strong>delitem</strong>(p)</td>
<td>•</td>
<td>•</td>
<td>删除位置p的元素</td>
</tr>

<tr>
<td>s.extend(it)</td>
<td>•</td>
<td>•</td>
<td>将可迭代对象it里的元素添加到尾部</td>
</tr>

<tr>
<td>s.frombytes(b)</td>
<td></td>
<td>•</td>
<td>将压缩成机器值的字节序列读出来添加到尾部</td>
</tr>

<tr>
<td>s.fromfile(f, n)</td>
<td></td>
<td>•</td>
<td>将二进制文件f内含有机器值读出来添加到尾部，最多添加n项</td>
</tr>

<tr>
<td>s.fromlist(l)</td>
<td></td>
<td>•</td>
<td>将列表里的元素添加到尾部，如果其中任何一个元素导致了 TypeError 异常，那么所有的添加都会取消</td>
</tr>

<tr>
<td>s.<strong>getitem</strong>(p)</td>
<td>•</td>
<td>•</td>
<td>s[p]，读取位置p的元素</td>
</tr>

<tr>
<td>s.index(e)</td>
<td>•</td>
<td>•</td>
<td>找到e在序列中第一次出现的位置</td>
</tr>

<tr>
<td>s.insert(p, e)</td>
<td>•</td>
<td>•</td>
<td>在位于p的元素之前插入元素e</td>
</tr>

<tr>
<td>s.itemsize</td>
<td></td>
<td>•</td>
<td>数组中每个元素的长度是几个字节</td>
</tr>
</tbody>
</table>

<table>
<thead>
<tr>
<th>s.<strong>iter</strong>()</th>
<th>•</th>
<th>•</th>
<th>返回迭代器</th>
</tr>
</thead>

<tbody>
<tr>
<td>s.<strong>len</strong>()</td>
<td>•</td>
<td>•</td>
<td>len(s)，序列的长度</td>
</tr>

<tr>
<td>s.<strong>mul</strong>(n)</td>
<td>•</td>
<td>•</td>
<td>s * n，重复拼接</td>
</tr>

<tr>
<td>s.<strong>imul</strong>(n)</td>
<td>•</td>
<td>•</td>
<td>s *= n，就地重复拼接</td>
</tr>

<tr>
<td>s.<strong>rmul</strong>(n)</td>
<td>•</td>
<td>•</td>
<td>n * s，反向重复拼接*</td>
</tr>

<tr>
<td>s.pop([p])</td>
<td>•</td>
<td>•</td>
<td>删除位于p的值并返回这个值，p的默认值是最后一个元素的位置</td>
</tr>

<tr>
<td>s.remove(e)</td>
<td>•</td>
<td>•</td>
<td>删除序列里第一次出现的e元素</td>
</tr>

<tr>
<td>s.reverse()</td>
<td>•</td>
<td>•</td>
<td>就地调转序列中元素的位置</td>
</tr>

<tr>
<td>s.<strong>reversed</strong>()</td>
<td>•</td>
<td></td>
<td>返回一个从尾部开始扫描元素的迭代器</td>
</tr>

<tr>
<td>s.<strong>setitem</strong>(p, e)</td>
<td>•</td>
<td>•</td>
<td>s[p] = e，把位于p位置的元素替换成e</td>
</tr>

<tr>
<td>s.sort([key],[revers])</td>
<td>•</td>
<td></td>
<td>就地排序序列，可选参数有 key 和 reverse</td>
</tr>

<tr>
<td>s.tobytes()</td>
<td></td>
<td>•</td>
<td>把所有元素的机器值用bytes对象的形式返回</td>
</tr>

<tr>
<td>s.tofile(f)</td>
<td></td>
<td>•</td>
<td>把所有元素以机器值的形式写入一个文件</td>
</tr>

<tr>
<td>s.tolist()</td>
<td></td>
<td>•</td>
<td>把数组转换成列表，列表里的元素类型是数字对象</td>
</tr>

<tr>
<td>s.typecode</td>
<td></td>
<td>•</td>
<td>返回只有一个字符的字符串，代表数组元素在C语言中的类型</td>
</tr>
</tbody>
</table>

<ul>
<li>第 13 章会讲反向运算符</li>
</ul>

<h4 id="从-python-3-4-开始-数组类型不再支持诸如-list-sort-这种就地排序方法-要给-数组排序的话-得用-sorted-函数新建一个数组">从 Python 3.4 开始，数组类型不再支持诸如 list.sort() 这种就地排序方法。要给 数组排序的话，得用 sorted 函数新建一个数组：</h4>

<p>a = array.array(a.typecode, sorted(a))</p>

<p>想要在不打乱次序的情况下为数组添加新的元素， bisect.insort 还是能派上用场 （就像 2.8.2 节中所展示的）。</p>

<p>如果你总是跟数组打交道，却没有听过memoryview，那就太遗憾了。下面就来谈谈 memoryview。</p>

<p>2.9.2 内存视图</p>

<p>memoryview 是一个内置类，它能让用户在不复制内容的情况下操作同一个数组的不同切 片。 memoryview 的概念受到了 NumPy 的启发（参见 2.9.3 节）。 Travis Oliphant 是 NumPy 的主要作者，他在回答“ When should a memoryview be</p>

<p>used?” （<a href="http://stackoverflow.com/questions/4845418/when-should-a-memoryview-be-used/）这">http://stackoverflow.com/questions/4845418/when-should-a-memoryview-be-used/）这</a></p>

<p>个问题时是这样说的：</p>

<p>内存视图其实是泛化和去数学化的 NumPy 数组。它让你在不需要复制内容的前提 下，在数据结构之间共享内存。其中数据结构可以是任何形式，比如 PIL 图片、</p>

<p>SQLite 数据库和 NumPy 的数组，等等。这个功能在处理大型数据集合的时候非常重 要。</p>

<p>memoryview.cast 的概念跟数组模块类似，能用不同的方式读写同一块内存数据，而且</p>

<p>内容字节不会随意移动。这听上去又跟 C 语言中类型转换的概念差不</p>

<p>多。 memoryview.cast 会把同一块内存里的内容打包成一个全新的 memoryview 对象给 你。</p>

<p>在示例 2-21 里，我们利用 memoryview 精准地修改了一个数组的某个字节，这个数组的</p>

<p>元素是 16 位二进制整数。</p>

<p>示例 2-21 通过改变数组中的一个字节来更新数组里某个元素的值</p>

<p>&gt;&gt;&gt; numbers = array.array(&lsquo;h&rsquo;, [-2, -1, 0, 1, 2])</p>

<p>&gt;&gt;&gt; memv = memoryview(numbers) O</p>

<p>&gt;&gt;&gt; len(memv)</p>

<p>5</p>

<p>&gt;&gt;&gt; memv[0] ©</p>

<p>-2</p>

<p>&gt;&gt;&gt; memv_oct = memv.cast(&lsquo;B&rsquo;) &amp;</p>

<p>&gt;&gt;&gt; memv_oct.tolist()    ©</p>

<p>[254, 255, 255, 255, 0, 0, 1, 0, 2, 0]</p>

<p>&gt;&gt;&gt; memv_oct[5] = 4 ❺</p>

<p>&gt;&gt;&gt; numbers</p>

<p>array(&lsquo;h&rsquo;, [-2,-1, 1024, 1, 2])    ©</p>

<p>❶利用含有5个短整型有符号整数的数组（类型码是’h&rsquo;）创建一个memoryview。 ❷ memv 里的 5 个元素跟数组里的没有区别。</p>

<p>❸创建一个memv_oct，这一次是把memv里的内容转换成’B&rsquo;类型，也就是无符号字 符。</p>

<p>❹ 以列表的形式查看 memv_oct 的内容。</p>

<p>❺ 把位于位置 5 的字节赋值成 4。</p>

<p>❻ 因为我们把占 2 个字节的整数的高位字节改成了 4，所以这个有符号整数的值就变成</p>

<p>了 1024 。</p>

<p>在第 4 章的示例 4-4 中，我们还可以看到如何利用 memoryview 和 struct 来操作二进制 序列。</p>

<p>另外，如果利用数组来做高级的数字处理是你的日常工作，那么 NumPy 和 SciPy 应该是 你的常用武器。下面就是对这两个库的简单介绍。</p>

<p>2.9.3 NumPy 和 SciPy</p>

<p>整本书我都在强调如何最大限度地利用 Python 标准库。但是 NumPy 和 SciPy 的优秀让我 觉得偶尔跑个题来谈谈它们也是很值得的。</p>

<p>凭借着 NumPy 和 SciPy 提供的高阶数组和矩阵操作， Python 成为科学计算应用的主流语</p>

<p>言。NumPy实现了多维同质数组(homogeneous array)和矩阵，这些数据结构不但能处理 数字，还能存放其他由用户定义的记录。通过NumPy，用户能对这些数据结构里的元素</p>

<p>进行高效的操作。</p>

<p>SciPy 是基于 NumPy 的另一个库，它提供了很多跟科学计算有关的算法，专为线性代数、 数值积分和统计学而设计。 SciPy 的高效和可靠性归功于其背后的 C 和 Fortran 代码，而 这些跟计算有关的部分都源自于Netlib库(<a href="http://www.netlib.org">http://www+netlib.org</a>)。换句话说，SciPy把 基于 C 和 Fortran 的工业级数学计算功能用交互式且高度抽象的 Python 包装起来，让科学</p>

<p>家如鱼得水。</p>

<p>示例 2-22 是一个很简短的演示，从中可以窥见一些 NumPy 二维数组的基本操作。</p>

<p>示例 2-22 对 numpy.ndarray 的行和列进行基本操作</p>

<p>&gt;&gt;&gt; import numpy</p>

<p>&gt;&gt;&gt; a = numpy.arange(12)</p>

<p>&gt;&gt;&gt; a</p>

<p>array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) &gt;&gt;&gt; type(a)</p>

<p><class 'numpy.ndarray'></p>

<p>&gt;&gt;&gt; a.shape ©</p>

<p>(12,)</p>

<p>&gt;&gt;&gt; a.shape = 3, 4    ©</p>

<p>&gt;&gt;&gt; a</p>

<table>
<thead>
<tr>
<th>array([[</th>
<th>0,</th>
<th>1,</th>
<th>2,</th>
<th>3],</th>
</tr>
</thead>

<tbody>
<tr>
<td>[</td>
<td>4,</td>
<td>5,</td>
<td>6,</td>
<td>7],</td>
</tr>

<tr>
<td>[</td>
<td>8,</td>
<td>9,</td>
<td>10,</td>
<td>11]])</td>
</tr>

<tr>
<td>&gt;&gt;&gt; a[2]</td>
<td>❺</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

<p>[ 1, 5, 9],</p>

<p>[ 2, 6, 10],</p>

<p>[ 3, 7, 11]])</p>

<p>❶ 安装 NumPy 之后，导入它（ NumPy 并不是 Python 标准库的一部分）。</p>

<p>❷新建一个0~11的整数的numpy.ndarry，然后把它打印出来。</p>

<p>❸ 看看数组的维度，它是一个一维的、有 12 个元素的数组。</p>

<p>❹ 把数组变成二维的，然后把它打印出来看看。</p>

<p>❺ 打印出第 2 行。</p>

<p>❻ 打印第 2 行第 1 列的元素。</p>

<p>❼ 把第 1 列打印出来。</p>

<p>❽ 把行和列交换，就得到了一个新数组。</p>

<p>NumPy 也可以对 numpy.ndarray 中的元素进行抽象的读取、保存和其他操作</p>

<p>&gt;&gt;&gt; import numpy</p>

<p>&gt;&gt;&gt; floats = numpy.loadtxt(&lsquo;floats-10M-lines.txt&rsquo;) O &gt;&gt;&gt; floats[-3:] ©</p>

<p>array([ 3016362.69195522, 535281.10514262, 4566560.44373946]) &gt;&gt;&gt; floats *= .5    ©</p>

<p>&gt;&gt;&gt; floats[-3:]</p>

<p>array([ 1508181.34597761, 267640.55257131, 2283280.22186973]) &gt;&gt;&gt; from time import perf_counter as pc ©</p>

<p>&gt;&gt;&gt; t0 = pc(); floats /= 3; pc() - t0 ❺</p>

<p>0.03690556302899495</p>

<p>&gt;&gt;&gt; numpy.save(&lsquo;floats-10M&rsquo;, floats) ©</p>

<p>&gt;&gt;&gt; floats2 = numpy.load(&lsquo;floats-10M.npy&rsquo;, &lsquo;r+&rsquo;)    ©</p>

<p>&gt;&gt;&gt; floats2 *= 6</p>

<p>&gt;&gt;&gt; floats2[-3:] ©</p>

<p>memmap([3016362.69195522, 535281.10514262, 4566560.44373946])</p>

<p>❶ 从文本文件里读取 1000 万个浮点数。</p>

<p>❷ 利用序列切片来读取其中的最后 3 个数。</p>

<p>❸ 把数组里的每个数都乘以 0.5，然后再看看最后 3 个数。</p>

<p>❹导入精度和性能都比较高的计时器（Python3+3及更新的版本中都有这个库）。</p>

<p>❺ 把每个元素都除以 3，可以看到处理 1000 万个浮点数所需的时间还不足 40 毫秒。</p>

<p>❻ 把数组存入后缀为 .npy 的二进制文件。</p>

<p>❼ 将上面的数据导入到另外一个数组里，这次 load 方法利用了一种叫作内存映射的机</p>

<p>制，它让我们在内存不足的情况下仍然可以对数组做切片。</p>

<p>❽ 把数组里每个数乘以 6 之后，再检视一下数组的最后 3 个数。</p>

<p>NumPy和SciPy的安装可能会比较费劲。在“Installing the SciPy</p>

<p>Stack’ （<a href="http://www.scipy.org/install.html）页面，SciPy.org">http://www.scipy.org/install.html）页面，SciPy.org</a> 建议找一个科学计算 Python 的分发渠道帮忙，比如Anacoda、Enthought Canopy、WinPython，等等。常见的 GNU/Linux版本的用户应该可以在他们自己的包管理系统中找到NumPy和SciPy。例 如，在 Debian 或者 Ubuntu 上面，用户可以通过下面的命令一键安装：</p>

<p>$ sudo apt-get install python-numpy python-scipy</p>

<p>以上的内容仅仅是九牛一毛。 NumPy 和 SciPy 都是异常强大的库，也是其他一些很有用的 工具的基石。Pandas （<a href="http://pandas.pydata.org">http://pandas.pydata.org</a>）和 Blaze （<a href="http://blaze.pydata.org">http://blaze.pydata.org</a>）数据分析 库就以它们为基础，提供了高效的且能存储非数值类数据的数组类型，和读写常见数据文 件格式（例如csv、xls、SQL转储和HDF5）的功能。因此，要详细介绍NumPy和SciPy 的话，不写成几本书是不可能的。虽然本书不在此列，但是如果要对 Python 的序列类型 做一个概览，恐怕没有人能忽略 NumPy。</p>

<p>在介绍完扁平序列（包括标准数组和 NumPy 数组）之后，让我们把目光投向 Python 中可 以取代列表的另外一种数据结构：队列。</p>

<p>2.9.4 双向队列和其他形式的队列</p>

<p>利用 .append 和 .pop 方法，我们可以把列表当作栈或者队列来用（比如，把 .append 和 .pop（0） 合起来用，就能模拟栈的“先进先出”的特点）。但是删除列表的第一个元素</p>

<p>（抑或是在第一个元素之前添加一个元素）之类的操作是很耗时的，因为这些操作会牵扯</p>

<p>到移动列表里的所有元素。</p>

<p>collections.deque 类（双向队列）是一个线程安全、可以快速从两端添加或者删除元 素的数据类型。而且如果想要有一种数据类型来存放“最近用到的几个元素”， deque 也是 一个很好的选择。这是因为在新建一个双向队列的时候，你可以指定这个队列的大小，如</p>

<p>果这个队列满员了，还可以从反向端删除过期的元素，然后在尾端添加新的元素。示例</p>

<p>2-23 中有几个双向队列的典型操作。</p>

<p>示例 2-23 使用双向队列</p>

<p>&gt;&gt;&gt; dq = deque(range(10), maxlen=10) O &gt;&gt;&gt; dq</p>

<p>deque([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], maxlen=10)</p>

<p>&gt;&gt;&gt; dq.rotate(3) ©</p>

<p>&gt;&gt;&gt; dq</p>

<p>deque([7, 8, 9, 0, 1, 2, 3, 4, 5, 6], maxlen=10)</p>

<p>&gt;&gt;&gt; dq.rotate(-4)</p>

<p>&gt;&gt;&gt; dq</p>

<p>deque([1, 2, 3, 4, 5, 6, 7, 8, 9, 0], maxlen=10)</p>

<p>&gt;&gt;&gt; dq.appendleft(-1) ©</p>

<p>&gt;&gt;&gt; dq</p>

<p>deque([-1, 1, 2, 3, 4, 5, 6, 7, 8, 9], maxlen=10)</p>

<p>&gt;&gt;&gt; dq.extend([11, 22, 33]) ©</p>

<p>&gt;&gt;&gt; dq</p>

<p>deque([3, 4, 5, 6, 7, 8, 9, 11, 22, 33], maxlen=10) &gt;&gt;&gt; dq.extendleft([10, 20, 30, 40]) ❺</p>

<p>&gt;&gt;&gt; dq</p>

<p>deque([40, 30, 20, 10, 3, 4, 5, 6, 7, 8], maxlen=10)</p>

<p>❶ maxlen 是一个可选参数，代表这个队列可以容纳的元素的数量，而且一旦设定，这个</p>

<p>属性就不能修改了。</p>

<p>❷队列的旋转操作接受一个参数n，当n &gt; 0时，队列的最右边的《个元素会被移动到 队列的左边。当 n &lt; 0 时，最左边的 n 个元素会被移动到右边。</p>

<p><a href="#footnote1">1</a></p>

<p>有读者提出，如果写成t[2].extend([50, 60])就能避免这个异常。确实是这样，但这个例子是为了展示这种奇怪 的现象而专门写的。</p>

<p>示例2-15没人料到的结果：t[2]被改动了，但是也有异常抛出</p>

<p>&gt;&gt;&gt; t = (1, 2, [30, 40])</p>

<p>&gt;&gt;&gt; t[2] += [50, 60]</p>

<p>Traceback (most recent call last):</p>

<p>File &ldquo;<stdin>&rdquo;, line 1, in <module></p>

<p>TypeError: &lsquo;tuple&rsquo; object does not support item assignment</p>

<p>&gt;&gt;&gt; t</p>

<p>(1, 2, [30, 40, 50, 60])</p>

<h4 id="❸当试图对一个己满-len-d-d-maxlen-的队列做尾部添加操作的时候-它头部-的元素会被删除掉-注意在下一行里-元素-0-被删除了">❸当试图对一个己满（len（d） == d.maxlen）的队列做尾部添加操作的时候，它头部 的元素会被删除掉。注意在下一行里，元素 0 被删除了。</h4>

<p>❹ 在尾部添加 3 个元素的操作会挤掉 -1、1 和 2。</p>

<p>❺ extendleft（iter） 方法会把迭代器里的元素逐个添加到双向队列的左边，因此迭代 器里的元素会逆序出现在队列里。</p>

<h4 id="表2-3总结了列表和双向队列这两个类型的方法-object类包含的方法除外">表2-3总结了列表和双向队列这两个类型的方法（object类包含的方法除外）。</h4>

<p>双向队列实现了大部分列表所拥有的方法，也有一些额外的符合自身设计的方法，比如说 popleft和rotate。但是为了实现这些方法，双向队列也付出了一些代价，从队列中间 删除元素的操作会慢一些，因为它只对在头尾的操作进行了优化。</p>

<p>append 和 popleft 都是原子操作，也就说是 deque 可以在多线程程序中安全地当作先</p>

<p>进先出的栈使用，而使用者不需要担心资源锁的问题。</p>

<p>表2-3：列表和双向队列的方法（不包括由对象实现的方法）</p>

<table>
<thead>
<tr>
<th></th>
<th>列表</th>
<th>双向队列</th>
<th></th>
</tr>
</thead>

<tbody>
<tr>
<td>s.<strong>add</strong> ( s2)</td>
<td>•</td>
<td></td>
<td>s + s2，拼接</td>
</tr>

<tr>
<td>s.<strong>iadd</strong> ( s2)</td>
<td>•</td>
<td>•</td>
<td>s += s2，就地拼接</td>
</tr>
</tbody>
</table>

<table>
<thead>
<tr>
<th>s.append(e)</th>
<th>•</th>
<th>•</th>
<th>添加一个元素到最右侧（到最后一个元素之后）</th>
</tr>
</thead>

<tbody>
<tr>
<td>s.appendleft(e)</td>
<td></td>
<td>•</td>
<td>添加一个元素到最左侧（到第一个元素之前）</td>
</tr>

<tr>
<td>s.cl ear()</td>
<td>•</td>
<td>•</td>
<td>删除所有元素</td>
</tr>

<tr>
<td>s.<strong>contains</strong>(e)</td>
<td>•</td>
<td></td>
<td>s是否含有e</td>
</tr>

<tr>
<td>s.copy()</td>
<td>•</td>
<td></td>
<td>对列表浅复制</td>
</tr>

<tr>
<td>s.<strong>copy</strong>()</td>
<td></td>
<td>•</td>
<td>对copy.copy （浅复制）的支持</td>
</tr>

<tr>
<td>s.count(e)</td>
<td>•</td>
<td>•</td>
<td>s中e出现的次数</td>
</tr>

<tr>
<td>s.<strong>delitem</strong>(p)</td>
<td>•</td>
<td>•</td>
<td>把位置p的元素移除</td>
</tr>

<tr>
<td>s.extend(i)</td>
<td>•</td>
<td>•</td>
<td>将可迭代对象i中的元素添加到尾部</td>
</tr>

<tr>
<td>s.extendleft(i)</td>
<td></td>
<td>•</td>
<td>将可迭代对象i中的元素添加到头部</td>
</tr>

<tr>
<td>s.<strong>getitem</strong>(p)</td>
<td>•</td>
<td>•</td>
<td>s[p]，读取位置p的元素</td>
</tr>

<tr>
<td>s.index(e)</td>
<td>•</td>
<td></td>
<td>找到e在序列中第一次出现的位置</td>
</tr>

<tr>
<td>s.insert(p, e)</td>
<td>•</td>
<td></td>
<td>在位于p的元素之前插入元素e</td>
</tr>

<tr>
<td>s.<strong>iter</strong>()</td>
<td>•</td>
<td>•</td>
<td>返回迭代器</td>
</tr>

<tr>
<td>s.<strong>len</strong>()</td>
<td>•</td>
<td>•</td>
<td>len（s），序列的长度</td>
</tr>

<tr>
<td>s.<strong>mul</strong>(n)</td>
<td>•</td>
<td></td>
<td>s * n，重复拼接</td>
</tr>

<tr>
<td>s.__ imul__(n)</td>
<td>•</td>
<td></td>
<td>s *= n，就地重复拼接</td>
</tr>

<tr>
<td>s.<strong>rmul</strong>(n)</td>
<td>•</td>
<td></td>
<td>n * s，反向重复拼接*</td>
</tr>

<tr>
<td>s.pop()</td>
<td>•</td>
<td>•</td>
<td>移除最后一个元素并返回它的值#</td>
</tr>
</tbody>
</table>

<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>

<tbody>
<tr>
<td>s.popleft()</td>
<td></td>
<td>•</td>
<td>移除第一个元素并返回它的值</td>
</tr>

<tr>
<td>s.remove(e)</td>
<td>•</td>
<td>•</td>
<td>移除序列里第一次出现的e元素</td>
</tr>

<tr>
<td>s.reverse()</td>
<td>•</td>
<td>•</td>
<td>调转序列中元素的位置</td>
</tr>

<tr>
<td>s.<strong>reversed</strong>( )</td>
<td>•</td>
<td>•</td>
<td>返回一个从尾部开始扫描元素的迭代器</td>
</tr>

<tr>
<td>s.rotate(n)</td>
<td></td>
<td>•</td>
<td>把n个元素从队列的一端移到另一端</td>
</tr>

<tr>
<td>s.<strong>setitem</strong>( p, e)</td>
<td>•</td>
<td>•</td>
<td>s[p] = e，把位于p位置的元素替换成e</td>
</tr>

<tr>
<td>s.sort([key], [revers])</td>
<td>•</td>
<td></td>
<td>就地排序序列，可选参数有key和reverse</td>
</tr>
</tbody>
</table>

<p>*    第 13 章会讲反向运算符。</p>

<p>#    a_list.pop(p) 这个操作只能用于列表，双向队列的这个方法不接收参数。</p>

<p>除了 deque 之外，还有些其他的 Python 标准库也有对队列的实现。</p>

<p>queue</p>

<p>提供了同步(线程安全)类Queue、LifoQueue和PriorityQueue，不同的线程可 以利用这些数据类型来交换信息。这三个类的构造方法都有一个可选参数maxsize，它 接收正整数作为输入值，用来限定队列的大小。但是在满员的时候，这些类不会扔掉旧的 元素来腾出位置。相反，如果队列满了，它就会被锁住，直到另外的线程移除了某个元素 而腾出了位置。这一特性让这些类很适合用来控制活跃线程的数量。</p>

<p>multiprocessing</p>

<p>这个包实现了自己的Queue，它跟queue.Queue类似，是设计给进程间通信用的。 同时还有一个专门的 multiprocessing.JoinableQueue 类型，可以让任务管理变得更 方便。</p>

<p>asyncio</p>

<p>Python 3+4 新提供的包，里面有 Queue、 LifoQueue、 PriorityQueue 和 JoinableQueue，这些类受到queue和multiprocessing模块的影响，但是为异步编</p>

<p>程里的任务管理提供了专门的便利。</p>

<p>heapq</p>

<p>跟上面三个模块不同的是， heapq 没有队列类，而是提供了 heappush 和 heappop</p>

<p>方法，让用户可以把可变序列当作堆队列或者优先队列来使用。</p>

<p>到了这里，我们对列表之外的类的介绍也就告一段落了，是时候阶段性地总结一下对序列 类型的探索了。注意我们还没有提到str （字符串）和二进制序列，它们将在第4章中专</p>

<p>门介绍。</p>

    </div>

    
    

    
    

    <footer class="post-footer">
      

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02-python/%E6%B5%81%E7%95%85%E7%9A%84-python/02-%E5%BA%8F%E5%88%97%E6%9E%84%E6%88%90%E7%9A%84%E6%95%B0%E7%BB%84/10-%E5%B0%8F%E7%BB%93%E4%B8%8E%E5%BB%B6%E4%BC%B8%E9%98%85%E8%AF%BB/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">10 小结与延伸阅读</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02-python/%E6%B5%81%E7%95%85%E7%9A%84-python/01-python-%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B/05-%E5%B0%8F%E7%BB%93%E4%B8%8E%E5%BB%B6%E4%BC%B8%E9%98%85%E8%AF%BB/">
            <span class="next-text nav-default">05 小结与延伸阅读</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="iteratelyd@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="http://github.com/iterateself" class="iconfont icon-github" title="github"></a>
      <a href="https://www.zhihu.com/people/thebegin/activities" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="https://www.douban.com/people/68028070/" class="iconfont icon-douban" title="douban"></a>
  <a href="http://iterate.site/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> site pv: <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
    <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> site uv: <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2018
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">iterateself</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>


<script type="text/javascript" src="/dist/even.min.js?v=3.2.0"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>








</body>
</html>
