<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>21 类元编程 - iterate self</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="iterateself" />
  <meta name="description" content="第 21 章 类元编程 （元类）是深奥的知识， 99% 的用户都无需关注。如果你想知道是否需要使用元 类，我告诉你，不需要（真正需要使用元类的人确信他们需要，无" />

  <meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.47.1" />


<link rel="canonical" href="http://iterate.site/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02-python/%E6%B5%81%E7%95%85%E7%9A%84-python/21-%E7%B1%BB%E5%85%83%E7%BC%96%E7%A8%8B/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">




<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<link href="/dist/even.min.css?v=3.2.0" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">




<meta property="og:title" content="21 类元编程" />
<meta property="og:description" content="第 21 章 类元编程 （元类）是深奥的知识， 99% 的用户都无需关注。如果你想知道是否需要使用元 类，我告诉你，不需要（真正需要使用元类的人确信他们需要，无" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://iterate.site/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02-python/%E6%B5%81%E7%95%85%E7%9A%84-python/21-%E7%B1%BB%E5%85%83%E7%BC%96%E7%A8%8B/" /><meta property="article:published_time" content="2018-06-26T21:37:42&#43;00:00"/>
<meta property="article:modified_time" content="2018-06-26T21:37:42&#43;00:00"/>
<meta itemprop="name" content="21 类元编程">
<meta itemprop="description" content="第 21 章 类元编程 （元类）是深奥的知识， 99% 的用户都无需关注。如果你想知道是否需要使用元 类，我告诉你，不需要（真正需要使用元类的人确信他们需要，无">


<meta itemprop="datePublished" content="2018-06-26T21:37:42&#43;00:00" />
<meta itemprop="dateModified" content="2018-06-26T21:37:42&#43;00:00" />
<meta itemprop="wordCount" content="13491">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="21 类元编程"/>
<meta name="twitter:description" content="第 21 章 类元编程 （元类）是深奥的知识， 99% 的用户都无需关注。如果你想知道是否需要使用元 类，我告诉你，不需要（真正需要使用元类的人确信他们需要，无"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">iterate self</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">about</li>
      </a><a href="/catalog/">
        <li class="mobile-menu-item">目录</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">iterate self</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">about</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/catalog/">目录</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">21 类元编程</h1>

      <div class="post-meta">
        <span class="post-time"> 2018-06-26 </span>
        
        <span class="more-meta"> 13491 words </span>
        <span class="more-meta"> 27 mins read </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> times read </span>
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  
  <div class="post-toc-content">
    <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#第-21-章-类元编程">第 21 章 类元编程</a>
<ul>
<li><a href="#21-1-类工厂函数">21.1 类工厂函数</a>
<ul>
<li><a href="#本书多次提到标准库中的一个类工厂函数-collections-namedtuple-我们把一个">本书多次提到标准库中的一个类工厂函数-collections.namedtuple。我们把一个</a></li>
<li><a href="#有时-我觉得应该有类似的工厂函数-用于创建可变对象-假设我在编写一个宠物店应用">有时，我觉得应该有类似的工厂函数，用于创建可变对象。假设我在编写一个宠物店应用</a></li>
<li><a href="#无趣-各个字段名称出现了三次-写了这么多样板代码-甚至字符串表示形式都不友">无趣+ + + + + +各个字段名称出现了三次。写了这么多样板代码，甚至字符串表示形式都不友</a></li>
<li><a href="#参考collections-namedtuple-下面我们创建一个record-factory函数-即时创建">参考collections.namedtuple，下面我们创建一个record_factory函数，即时创建</a></li>
<li><a href="#❶-这个工厂函数的签名与-namedtuple-类似-先写类名-后面跟着写在一个字符串里的-多个属性名-使用空格或逗号分开">❶ 这个工厂函数的签名与 namedtuple 类似：先写类名，后面跟着写在一个字符串里的 多个属性名，使用空格或逗号分开。</a></li>
<li><a href="#❷-友好的字符串表示形式">❷ 友好的字符串表示形式。</a></li>
<li><a href="#❸-实例是可迭代的对象-因此赋值时可以便利地拆包">❸ 实例是可迭代的对象，因此赋值时可以便利地拆包。</a></li>
<li><a href="#❹-传给-format-等函数时也可以拆包">❹ 传给 format 等函数时也可以拆包。</a></li>
<li><a href="#❺-记录实例是可变的对象">❺ 记录实例是可变的对象。</a></li>
<li><a href="#示例21-2-record-factory-py-一个简单的类工厂函数">示例21-2 record_factory+ py: 一个简单的类工厂函数</a></li>
<li><a href="#❶这里体现了鸭子类型-尝试在逗号或空格处拆分field-names-如果失败-那么假定-field-names-本就是可迭代的对象-一个元素对应一个属性名">❶这里体现了鸭子类型：尝试在逗号或空格处拆分field_names；如果失败，那么假定 field_names 本就是可迭代的对象，一个元素对应一个属性名。</a></li>
<li><a href="#❷-使用属性名构建元组-这将成为新建类的-slots-属性-此外-这么做还设定了拆">❷ 使用属性名构建元组，这将成为新建类的 <strong>slots</strong> 属性；此外，这么做还设定了拆</a></li>
<li><a href="#❸-这个函数将成为新建类的-init-方法-参数有位置参数和-或-关键字参数">❸ 这个函数将成为新建类的 <strong>init</strong> 方法。参数有位置参数和(或)关键字参数。</a></li>
<li><a href="#❹-实现-iter-函数-把类的实例变成可迭代的对象-按照-slots-设定的顺序产-出字段值">❹ 实现 <strong>iter</strong> 函数，把类的实例变成可迭代的对象；按照 <strong>slots</strong> 设定的顺序产 出字段值。</a></li>
</ul></li>
<li><a href="#21-2-定制描述符的类装饰器">21.2 定制描述符的类装饰器</a></li>
<li><a href="#21-3-导入时和运行时比较">21.3 导入时和运行时比较</a>
<ul>
<li><a href="#示例21-6-evaltime-py-按顺序写出输出的序号标记-n">示例21-6 evaltime+py：按顺序写出输出的序号标记&lt;[N]&gt;</a></li>
<li><a href="#示例-21-7-evalsupport-py-evaltime-py-导入的模块">示例 21-7 evalsupport+py： evaltime+py 导入的模块</a></li>
<li><a href="#01-场景1的解答">01+ 场景1的解答</a></li>
</ul></li>
<li><a href="#21-4-元类基础知识">21.4 元类基础知识</a>
<ul>
<li><a href="#同样-请拿出纸和笔-按顺序写出下述两个场景中输出的序号标记-n-场景-3">同样，请拿出纸和笔，按顺序写出下述两个场景中输出的序号标记 &lt;[N]&gt;。 场景 3</a></li>
<li><a href="#编写元类时-通常会把self参数改成cls-例如-在上述元类的-init-方法中-把第一个参数命名为-cls-能清楚地表明要构建的实例是类">编写元类时，通常会把self参数改成cls。例如，在上述元类的 <strong>init</strong> 方法中，把第一个参数命名为 cls 能清楚地表明要构建的实例是类。</a></li>
<li><a href="#02-场景4的解答">02. 场景4的解答</a></li>
<li><a href="#❶-装饰器依附到-classthree-类上之后-method-y-方法被替换成-inner-1-方-法">❶ 装饰器依附到 ClassThree 类上之后， method_y 方法被替换成 inner_1 方 法……</a></li>
</ul></li>
<li><a href="#21-5-定制描述符的元类">21.5 定制描述符的元类</a>
<ul>
<li><a href="#示例21-14-bulkfood-v7-py-有元类的支持-继承model-entity类即可">示例21-14 bulkfood_v7.py：有元类的支持，继承model.Entity类即可</a></li>
<li><a href="#o-lineitem-是-model-entity-的子类">O LineItem 是 model.Entity 的子类。</a></li>
<li><a href="#❶在超类-在这里是type-上调用-init-方法">❶在超类（在这里是type）上调用_init__方法。</a></li>
</ul></li>
<li><a href="#21-6-元类的特殊方法-prepare">21.6 元类的特殊方法 <strong>prepare</strong></a></li>
<li><a href="#21-7-类作为对象">21.7 类作为对象</a></li>
<li><a href="#21-8-本章小结">21.8 本章小结</a></li>
<li><a href="#21-9延伸阅读">21.9延伸阅读</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
  </div>
</div>

    
    

    
    <div class="post-content">
      

<h2 id="第-21-章-类元编程">第 21 章 类元编程</h2>

<p>（元类）是深奥的知识， 99% 的用户都无需关注。如果你想知道是否需要使用元 类，我告诉你，不需要（真正需要使用元类的人确信他们需要，无需解释原因）。 1</p>

<p>——Tim Peters</p>

<p>Timsort 算法的发明者，活跃的 Python 贡献者</p>

<p><a href="https://mail.python.org/pipermail/python-list/2002-December/134521.html">1</a><a href="https://mail.python.org/pipermail/python-list/2002-December/134521.html">摘自 comp.lang.python 邮件列表中对“Acrimony in c.lp.”话题的回复（https://malpython.org/pipemai/python-list/2002-</a>December/134521.html）。前言中引述的那句话也是出自这篇发布于2002年12月23日的消息。TimBot在那天获得了</p>

<p>灵感。</p>

<p>类元编程是指在运行时创建或定制类的技艺。在 Python 中，类是一等对象，因此任何时 候都可以使用函数新建类，而无需使用 class 关键字。类装饰器也是函数，不过能够审 查、修改，甚至把被装饰的类替换成其他类。最后，元类是类元编程最高级的工具：使用 元类可以创建具有某种特质的全新类种，例如我们见过的抽象基类。</p>

<p>元类功能强大，但是难以掌握。类装饰器能使用更简单的方式解决很多问题。其实， Python 2.6 引入类装饰器之后，元类很难使用真实的代码说明，因此我不会像前面的章节 那样再举引导示例。</p>

<p>本章还会谈及导入时和运行时的区别——这是有效使用 Python 元编程的重要基础。</p>

<p>这是一个令人兴奋的话题，很容易让人忘乎所以。因此，进入本章的正文之前，我必</p>

<p>须告诫你：</p>

<p>除非开发框架，否则不要编写元类——然而，为了寻找乐趣，或者练习相关的概念，</p>

<p>可以这么做。</p>

<p>首先，本章探讨如何在运行时创建类。</p>

<h3 id="21-1-类工厂函数">21.1 类工厂函数</h3>

<h4 id="本书多次提到标准库中的一个类工厂函数-collections-namedtuple-我们把一个">本书多次提到标准库中的一个类工厂函数-collections.namedtuple。我们把一个</h4>

<p>类名和几个属性名传给这个函数，它会创建一个 tuple 的子类，其中的元素通过名称获 取，还为调试提供了友好的字符串表示形式（<strong>repr</strong>）。</p>

<h4 id="有时-我觉得应该有类似的工厂函数-用于创建可变对象-假设我在编写一个宠物店应用">有时，我觉得应该有类似的工厂函数，用于创建可变对象。假设我在编写一个宠物店应用</h4>

<p>程序，我想把狗的数据当作简单的记录处理。编写下面的样板代码让人厌烦：</p>

<p>class Dog:</p>

<p>def <strong>init</strong>(self, name, weight, owner): self.name = name self.weight = weight self.owner = owner</p>

<h4 id="无趣-各个字段名称出现了三次-写了这么多样板代码-甚至字符串表示形式都不友">无趣+ + + + + +各个字段名称出现了三次。写了这么多样板代码，甚至字符串表示形式都不友</h4>

<p>好：</p>

<p>&gt;&gt;&gt; rex = Dog(&lsquo;Rex&rsquo;, 30, &lsquo;Bob&rsquo;) &gt;&gt;&gt; rex</p>

<p><main.Dog object at 0x2865bac></p>

<h4 id="参考collections-namedtuple-下面我们创建一个record-factory函数-即时创建">参考collections.namedtuple，下面我们创建一个record_factory函数，即时创建</h4>

<p>简单的类（如Dog）。这个函数的用法如示例21-1。</p>

<p>示例 21-1 测试 record_factory 函数，一个简单的类工厂函数</p>

<p>&gt;&gt;&gt; Dog = record_factory(&lsquo;Dog&rsquo;, &lsquo;name weight owner&rsquo;) O &gt;&gt;&gt; rex = Dog(&lsquo;Rex&rsquo;, 30, &lsquo;Bob&rsquo;)</p>

<p>&gt;&gt;&gt; rex ©</p>

<p>Dog(name=&lsquo;Rex&rsquo;, weight=30, owner=&lsquo;Bob&rsquo;)</p>

<p>&gt;&gt;&gt; name, weight, _ = rex ©</p>

<p>&gt;&gt;&gt; name, weight (&lsquo;Rex&rsquo;, 30)</p>

<p>&gt;&gt;&gt; &ldquo;{2}&rsquo;s dog weighs {1}kg&rdquo;.format(*rex) ©</p>

<p>&ldquo;Bob&rsquo;s dog weighs 30kg&rdquo;</p>

<p>&gt;&gt;&gt; rex.weight = 32    ❺</p>

<p>&gt;&gt;&gt; rex</p>

<p>Dog(name=&lsquo;Rex&rsquo;, weight=32, owner=&lsquo;Bob&rsquo;)</p>

<p>&gt;&gt;&gt; Dog._<em>mro</em>    ©</p>

<p>(<class 'factories.Dog'>, <class 'object'>)</p>

<h4 id="❶-这个工厂函数的签名与-namedtuple-类似-先写类名-后面跟着写在一个字符串里的-多个属性名-使用空格或逗号分开">❶ 这个工厂函数的签名与 namedtuple 类似：先写类名，后面跟着写在一个字符串里的 多个属性名，使用空格或逗号分开。</h4>

<h4 id="❷-友好的字符串表示形式">❷ 友好的字符串表示形式。</h4>

<h4 id="❸-实例是可迭代的对象-因此赋值时可以便利地拆包">❸ 实例是可迭代的对象，因此赋值时可以便利地拆包。</h4>

<h4 id="❹-传给-format-等函数时也可以拆包">❹ 传给 format 等函数时也可以拆包。</h4>

<h4 id="❺-记录实例是可变的对象">❺ 记录实例是可变的对象。</h4>

<p>❻新建的类继承自object，与我们的工厂函数没有关系。 record_factory 函数的代码在示例 21-2 中。 2</p>

<p>2感谢我的朋友J+S+ Bueno的建议。</p>

<h4 id="示例21-2-record-factory-py-一个简单的类工厂函数">示例21-2 record_factory+ py: 一个简单的类工厂函数</h4>

<p>def record_factory(cls_name, field_names): try:</p>

<p>field_names = field_names.replace(.split() O except AttributeError: # 不能调用.replace或.split方法</p>

<p>pass #假定field_names本就是标识符组成的序列 field_names = tuple(field_names) ©</p>

<p>def <strong>init</strong>(self, *args, **kwargs):    ©</p>

<p>attrs = dict(zip(self.<strong>slots</strong>, args)) attrs.update(kwargs)</p>

<p>for name, value in attrs.items(): setattr(self, name, value)</p>

<p>def <strong>iter</strong>(self): ©</p>

<p>for name in self.<strong>slots</strong>: yield getattr(self, name)</p>

<p>def <strong>repr</strong>(self):❺</p>

<p>values = &lsquo;, &lsquo;.join(&rsquo;{}={!r}&lsquo;.format(*i) for i</p>

<p>in zip(self.<strong>slots</strong>, self)) return &lsquo;{}({})&rsquo;.format(self.<strong>class</strong>.<strong>name</strong>, values)</p>

<p>cls_attrs = dict(<strong>slots</strong> = field_names, ©</p>

<p><strong>init</strong> = <strong>init</strong>,</p>

<p><strong>iter</strong> = <strong>iter</strong>,</p>

<p><strong>repr</strong> = <strong>repr</strong>)</p>

<p>return type(cls_name, (object,), cls_attrs) &amp;</p>

<h4 id="❶这里体现了鸭子类型-尝试在逗号或空格处拆分field-names-如果失败-那么假定-field-names-本就是可迭代的对象-一个元素对应一个属性名">❶这里体现了鸭子类型：尝试在逗号或空格处拆分field_names；如果失败，那么假定 field_names 本就是可迭代的对象，一个元素对应一个属性名。</h4>

<h4 id="❷-使用属性名构建元组-这将成为新建类的-slots-属性-此外-这么做还设定了拆">❷ 使用属性名构建元组，这将成为新建类的 <strong>slots</strong> 属性；此外，这么做还设定了拆</h4>

<p>包和字符串表示形式中各字段的顺序。</p>

<h4 id="❸-这个函数将成为新建类的-init-方法-参数有位置参数和-或-关键字参数">❸ 这个函数将成为新建类的 <strong>init</strong> 方法。参数有位置参数和(或)关键字参数。</h4>

<h4 id="❹-实现-iter-函数-把类的实例变成可迭代的对象-按照-slots-设定的顺序产-出字段值">❹ 实现 <strong>iter</strong> 函数，把类的实例变成可迭代的对象；按照 <strong>slots</strong> 设定的顺序产 出字段值。</h4>

<p>❺ 迭代 <strong>slots</strong> 和 self ，生成友好的字符串表示形式。</p>

<p>❻ 组建类属性字典。</p>

<p>❼ 调用 type 构造方法，构建新类，然后将其返回。</p>

<p>通常，我们把 type 视作函数，因为我们像函数那样使用它，例如，调用 type(my_object) 获取对象所属的类——作用与 my_object.<strong>class</strong> 相同。然</p>

<p>而，type是一个类。当成类使用时，传入三个参数可以新建一个类：</p>

<p>MyClass = type(&lsquo;MyClass&rsquo;, (MySuperClass, MyMixin),</p>

<p>{&lsquo;x&rsquo;: 42, &lsquo;x2&rsquo;: lambda self: self.x * 2})</p>

<p>type的三个参数分别是name、bases和diet。最后一个参数是一个映射，指定新类的</p>

<p>属性名和值。上述代码的作用与下述代码相同：</p>

<p>class MyClass(MySuperClass, MyMixin): x = 42</p>

<p>def x2(self): return self.x * 2</p>

<p>让人觉得新奇的是， type 的实例是类，例如这里的 MyClass 类或示例 21-1 中的 Dog 类。</p>

<p>总之，示例 21-2 中 record_factory 函数的最后一行会构建一个类，类的名称是</p>

<p>cls_name参数的值，唯一的直接超类是object，有</p>

<p><strong>slots</strong>、 <strong>init</strong>、 <strong>iter</strong> 和 <strong>repr</strong> 四个类属性，其中后三个是实例方法。</p>

<p>我们本可以把 <strong>slots</strong> 类属性的名称改成其他值，不过要是那样的话，就要实现</p>

<p><strong>setattr</strong> 方法，为属性赋值时验证属性的名称，因为对于记录这样的类，我们希望 属性始终是固定的那几个，而且顺序相同。然而 9.8 节说过， <strong>slots</strong> 属性的主要特色 是节省内存，能处理数百万个实例，不过也有一些缺点。</p>

<p>把三个参数传给 type 是动态创建类的常用方式。如果查看 collections.namedtuple</p>

<p>函数的源码(<a href="https://hg.python.org/cpython/file/3.4/Lib/collections/__init__.py%23l236">https://hg+python+org/cpython/file/3.4/Lib/collections/<strong>init</strong>.py#l236</a>)，你会发 现另一种方式：先声明一个 _class_template 变量，其值是字符串形式的源码模板；然 后在 namedtuple 函数中调用 _class_template.format(&hellip;) 方法，填充模板里的空 白；最后，使用内置的 exec 函数计算得到的源码字符串。</p>

<p>在Python中做元编程时，最好不用exec和eval函数。如果接收的字符串 (或片段)来自不可信的源，那么这两个函数会带来严重的安全风险。 Python 提供了 充足的内省工具，大多数时候都不需要使用 exec 和 eval 函数。然而， Python 核心 开发者实现 namedtuple 函数时选择了使用 exec 函数，这样做是为了让生成的类代</p>

<p>码能通过 ._source 属性</p>

<p>( <a href="https://docs.python.org/3/library/collections.html%23collections.somenamedtuple._source">https://docs.python.org/3/library/collections.html#collections.somenamedtuple._source</a>) 获取。</p>

<p>record_factory 函数创建的类，其实例有个局限——不能序列化，即不能使用 pickle 模块里的 dump/load 函数处理。这个示例是为了说明如何使用 type 类满足简单的需 求，因此不会解决这个问题。如果想了解完整的方案，请分析 collections.nameduple 函数的源码(<a href="https://hg.python.org/cpython/file/3.4/Lib/collections/__init__.py%23l236">https://hg+python.org/cpython/file/3.4/Lib/collections/<strong>init</strong>.py#1236</a>)，搜 索“pickling”这个词。</p>

<h3 id="21-2-定制描述符的类装饰器">21.2 定制描述符的类装饰器</h3>

<p>20+1+3 节中的 LineItem 示例还有个问题没有解决：储存属性的名称不具有描述性，即属</p>

<p>性（如weight）的值存储在名为_Quantity#0的实例属性中，这样的名称有点不便于</p>

<p>调试。我们可以使用下述代码从示例 20-7 定义的描述符中获取储存属性的名称：</p>

<p>&gt;&gt;&gt; LineItem.weight.storage_name &lsquo;Quantity#0&rsquo;</p>

<p>可是，如果储存属性的名称中包含托管属性的名称更好，如下所示：</p>

<p>&gt;&gt;&gt; LineItem.weight.storage_name &lsquo;Quantity#weight&rsquo;</p>

<p>20+1+2 节说过，我们不能使用描述性的储存属性名称，因为实例化描述符时无法得知托管 属性（即绑定到描述符上的类属性，例如前述示例中的weight）的名称。可是，一旦组 建好整个类，而且把描述符绑定到类属性上之后，我们就可以审查类，并为描述符设置合 理的储存属性名称。 LineItem 类的 <strong>new</strong> 方法可以做到这一点，因此，在 <strong>init</strong> 方法中使用描述符时，储存属性已经设置了正确的名称。为了解决这个问题而使用 <strong>new</strong> 方法纯属白费力气：每次新建 LineItem 实例时都会运行 <strong>new</strong> 方法中的逻 辑，可是，一旦 LineItem 类构建好了，描述符与托管属性之间的绑定就不会变了。因 此，我们要在创建类时设置储存属性的名称。使用类装饰器或元类可以做到这一点。我们 首先使用较简单的方式。</p>

<p>类装饰器与函数装饰器非常类似，是参数为类对象的函数，返回原来的类或修改后的类。</p>

<p>在示例 21-3 中，解释器会计算 LineItem 类，把返回的类对象传给 model.entity 函 数。 Python 会把 LineItem 这个全局名称绑定给 model.entity 函数返回的对象。在这个 示例中， model.entity 函数会返回原先的 LineItem 类，但是会修改各个描述符实例的 storage_name 属性。</p>

<p>示例 21-3 bulkfood_v6+py：使用 Quantity 和 NonBlank 描述符的 Lineltem 类</p>

<p>import model_v6 as model</p>

<p>@model.entity O</p>

<p>class LineItem:</p>

<p>description = model.NonBlank() weight = model.Quantity() price = model.Quantity()</p>

<p>def <strong>init</strong>(self, description, weight, price): self.description = description self.weight = weight self.price = price</p>

<p>def subtotal(self):</p>

<p>return self.weight * self.price</p>

<p>O 这个类唯一的变化是添加了装饰器。</p>

<p>示例 21-4 是那个装饰器的实现。这里只列出了 model_v6.py 脚本底部添加的新代码，其余 的代码与 model_v5.py 脚本(见示例 20-6)一样。</p>

<p>示例21-4 model_v6+py： 一个类装饰器</p>

<p>def entity(cls): O</p>

<p>for key, attr in cls.<strong>dict</strong>.items(): © if isinstance(attr, Validated): © type_name = type(attr).<strong>name</strong></p>

<p>attr.storage<em>name = &lsquo;</em>{}#{}&lsquo;.format(type_name, key) © return cls ❺</p>

<p>❶ 装饰器的参数是一个类。</p>

<p>❷ 迭代存储类属性的字典。</p>

<p>❸ 如果属性是 Validated 描述符的实例++</p>

<p>❹&hellip;&hellip;使用描述符类的名称和托管属性的名称命名storage_name (例如</p>

<p>_NonBlank#description)。</p>

<p>❺ 返回修改后的类。</p>

<p>bulkfood_v6.py 脚本中的 doctest 证明，改动是成功的。例如，示例 21-5 展示了一个 LineItem 实例中的储存属性名称。</p>

<p>示例 21-5 bulkfood_v6+py：描述符中新 storage_name 属性的 doctest</p>

<p>&gt;&gt;&gt; raisins = LineItem(&lsquo;Golden raisins&rsquo;, 10, 6.95)</p>

<p>&gt;&gt;&gt; dir(raisins)[:3]</p>

<p>[&rsquo;_NonBlank#description&rsquo;, &lsquo;_Quantity#price&rsquo;, &lsquo;_Quantity#weight&rsquo;]</p>

<p>&gt;&gt;&gt; LineItem.description.storage_name</p>

<p>&lsquo;_NonBlank#description&rsquo;</p>

<p>&gt;&gt;&gt; raisins.description &lsquo;Golden raisins&rsquo;</p>

<p>&gt;&gt;&gt; getattr(raisins, &lsquo;_NonBlank#description&rsquo;)</p>

<p>&lsquo;Golden raisins&rsquo;</p>

<p>可以看出，这并不复杂。类装饰器能以较简单的方式做到以前需要使用元类去做的事情</p>

<p>——创建类时定制类。</p>

<p>类装饰器有个重大缺点：只对直接依附的类有效。这意味着，被装饰的类的子类可能继承</p>

<p>也可能不继承装饰器所做的改动，具体情况视改动的方式而定。接下来的几节会探讨这个</p>

<p>问题，并给出解决方案。</p>

<h3 id="21-3-导入时和运行时比较">21.3 导入时和运行时比较</h3>

<p>为了正确地做元编程，你必须知道 Python 解释器什么时候计算各个代码块。 Python 程序</p>

<p>员会区分“导入时”和“运行时”，不过这两个术语没有严格的定义，而且二者之间存在着灰 色地带。在导入时，解释器会从上到下一次性解析完 .py 模块的源码，然后生成用于执行</p>

<p>的字节码。如果句法有错误，就在此时报告。如果本地的 <strong>pycache</strong> 文件夹中有最新 的 .pyc 文件，解释器会跳过上述步骤，因为已经有运行所需的字节码了。</p>

<p>编译肯定是导入时的活动，不过那个时期还会做些其他事，因为 Python 中的语句几乎都 是可执行的，也就是说语句可能会运行用户代码，修改用户程序的状态。尤其是 import</p>

<p>语句，它不只是声明 3，在进程中首次导入模块时，还会运行所导入模块中的全部顶层代 码——以后导入相同的模块则使用缓存，只做名称绑定。那些顶层代码可以做任何事，包 括通常在“运行时”做的事，例如连接数据库。 4 因此， “导入时”与“运行时”之间的界线是</p>

<p>模糊的： import 语句可以触发任何“运行时”行为。</p>

<p>Java中的import语句则只是声明，用于告知编译器需要特定的包。</p>

<p>4我不是说导入模块时应该连接数据库，只是指出来可以做到。</p>

<p>在前一段中我写道，导入时会“运行全部顶层代码”，但是“顶层代码”会经过一些加工。导 入模块时，解释器会执行顶层的 def 语句，可是这么做有什么作用呢？解释器会编译函 数的定义体（首次导入模块时），把函数对象绑定到对应的全局名称上，但是显然解释器 不会执行函数的定义体。通常这意味着解释器在导入时定义顶层函数，但是仅当在运行时</p>

<p>调用函数时才会执行函数的定义体。</p>

<p>对类来说，情况就不同了：在导入时，解释器会执行每个类的定义体，甚至会执行嵌套类</p>

<p>的定义体。执行类定义体的结果是，定义了类的属性和方法，并构建了类对象。从这个意</p>

<p>义上理解，类的定义体属于“顶层代码”，因为它在导入时运行。</p>

<p>上述说明模糊又抽象，下面通过练习理解各个时期所做的事情。</p>

<p>理解计算时间的练习</p>

<p>假设在 evaltime.py 脚本中导入了 evalsupport.py 模块。这两个模块调用了几次 print 函</p>

<p>数，打印 &lt;[N]&gt; 格式的标记，其中 N 是数字。下述两个练习的目标是，确定各个调用在 何时执行。</p>

<p>据我的学生说，这两个练习有助于更好地理解 Python 计算源码的方式。在查看</p>

<p>场景 1 的解答之前，请一定要拿出纸和笔，花点时间作答。</p>

<p>那两个模块的代码在示例 21-6 和示例 21-7 中。先别运行代码，拿出纸和笔，按顺序写出 下述两个场景输出的标记。</p>

<p>场景 1</p>

<p>在 Python 控制台中以交互的方式导入 evaltime+py 模块</p>

<p>&gt;&gt; import evaltime</p>

<p>场景 2</p>

<p>在命令行中运行 evaltime+py 模块</p>

<p>$ python3 evaltime.py</p>

<h4 id="示例21-6-evaltime-py-按顺序写出输出的序号标记-n">示例21-6 evaltime+py：按顺序写出输出的序号标记&lt;[N]&gt;</h4>

<p>from evalsupport import deco_alpha print(&rsquo;&lt;[1]&gt; evaltime module start&rsquo;)</p>

<p>class ClassOne():</p>

<p>print(&rsquo;&lt;[2]&gt; ClassOne body&rsquo;)</p>

<p>def <strong>init</strong>(self):</p>

<p>print(&rsquo;&lt;[3]&gt; ClassOne.<strong>init</strong>&rsquo;)</p>

<p>def <strong>del</strong>(self):</p>

<p>print(&rsquo;&lt;[4]&gt; ClassOne.<strong>del</strong>&rsquo;)</p>

<p>def method_x(self):</p>

<p>print(&rsquo;&lt;[5]&gt; ClassOne.method_x&rsquo;)</p>

<p>class ClassTwo(object):</p>

<p>print(&rsquo;&lt;[6]&gt; ClassTwo body&rsquo;)</p>

<p>@deco_alpha</p>

<p>class ClassThree():</p>

<p>print(&rsquo;&lt;[7]&gt; ClassThree body&rsquo;)</p>

<p>def method_y(self):</p>

<p>print(&rsquo;&lt;[8]&gt; ClassThree.method_y&rsquo;)</p>

<p>class ClassFour(ClassThree):</p>

<p>print(&rsquo;&lt;[9]&gt; ClassFour body&rsquo;)</p>

<p>def method_y(self):</p>

<p>print(&rsquo;&lt;[10]&gt; ClassFour.method_y&rsquo;)</p>

<p>if <strong>name</strong> == &lsquo;<strong>main</strong>&lsquo;:</p>

<p>print(&rsquo;&lt;[11]&gt; ClassOne tests&rsquo;, 30 * &lsquo;.&rsquo;) one = ClassOne()</p>

<p>one.method_x()</p>

<p>print(&rsquo;&lt;[12]&gt; ClassThree tests&rsquo;, 30 * &lsquo;.&rsquo;) three = ClassThree()</p>

<p>three.method_y()</p>

<p>print(&rsquo;&lt;[13]&gt; ClassFour tests&rsquo;, 30 * &lsquo;.&rsquo;)</p>

<p>four = ClassFour()</p>

<p>four.method_y()</p>

<p>print(&rsquo;&lt;[14]&gt; evaltime module end&rsquo;)</p>

<h4 id="示例-21-7-evalsupport-py-evaltime-py-导入的模块">示例 21-7 evalsupport+py： evaltime+py 导入的模块</h4>

<p>print(&rsquo;&lt;[100]&gt; evalsupport module start&rsquo;)</p>

<p>def deco_alpha(cls):</p>

<p>print(&rsquo;&lt;[200]&gt; deco_alpha&rsquo;)</p>

<p>def inner_1(self):</p>

<p>print(&rsquo;&lt;[300]&gt; deco_alpha:inner_1&rsquo;)</p>

<p>cls.method_y = inner_1 return cls</p>

<p>class MetaAleph(type):</p>

<p>print(&rsquo;&lt;[400]&gt; MetaAleph body&rsquo;)</p>

<p>def <strong>init</strong>(cls, name, bases, dic): print(&rsquo;&lt;[500]&gt; MetaAleph.<strong>init</strong>&rsquo;) def inner_2(self):</p>

<p>print(&rsquo;&lt;[600]&gt; MetaAleph.<strong>init</strong>:inner_2&rsquo;) cls.method_z = inner_2 print(&rsquo;&lt;[700]&gt; evalsupport module end&rsquo;)</p>

<h4 id="01-场景1的解答">01+ 场景1的解答</h4>

<p>在 Python 控制台中导入 evaltime+py 模块后得到的输出如示例 21-8 所示 示例 21-8 场景 1：在 Python 控制台中导入 evaltime 模块</p>

<p>&gt;&gt;&gt; import evaltime</p>

<p>&lt;[100]&gt; evalsupport module start O &lt;[400]&gt; MetaAleph body ©</p>

<p>&lt;[700]&gt; evalsupport module end &lt;[1]&gt; evaltime module start &lt;[2]&gt; ClassOne body ©</p>

<p>&lt;[6]&gt; ClassTwo body ©</p>

<p>&lt;[7]&gt; ClassThree body &lt;[200]&gt; deco_alpha ©</p>

<p>&lt;[9]&gt; ClassFour body</p>

<p>&lt;[14]&gt; evaltime module end ©</p>

<p>❶ evalsupport 模块中的所有顶层代码在导入模块时运行；解释器会编译</p>

<p>deco_alpha 函数，但是不会执行定义体。</p>

<p>❷ MetaAleph 类的定义体运行了。</p>

<p>❸ 每个类的定义体都执行了……</p>

<p>❹ ……包括嵌套的类。</p>

<p>❺ 先计算被装饰的类 ClassThree 的定义体，然后运行装饰器函数。</p>

<p>❻ 在这个场景中， evaltime 模块是导入的，因此不会运行 if <strong>name</strong> ==</p>

<p>&lsquo;<strong>main</strong>&lsquo;: 块。</p>

<p>对于场景 1，要注意以下几点。</p>

<p>(1)    这个场景由简单的 import evaltime 语句触发。</p>

<p>(2)    解释器会执行所导入模块及其依赖(evalsupport)中的每个类定义体。</p>

<p>(3)    解释器先计算类的定义体，然后调用依附在类上的装饰器函数，这是合理的行</p>

<p>为，因为必须先构建类对象，装饰器才有类对象可处理。</p>

<p>(4)    在这个场景中，只运行了一个用户定义的函数或方法-deco_alpha装饰器。</p>

<p>下面来看场景 2。</p>

<p>02+ 场景2的解答</p>

<p>运行 python3 evaltime.py 命令后得到的输出如示例 21-9 所示。</p>

<p>示例 21-9 场景 2：在 shell 中运行 evaltime+py</p>

<p>$ python3 evaltime.py &lt;[100]&gt; evalsupport module start</p>

<p>&lt;[400]&gt; MetaAleph body</p>

<p>&lt;[700]&gt; evalsupport module end &lt;[1]&gt; evaltime module start</p>

<p>&lt;[2]&gt; ClassOne body &lt;[6]&gt; ClassTwo body &lt;[7]&gt; ClassThree body &lt;[200]&gt; deco_alpha</p>

<p>&lt;[9]&gt; ClassFour body O</p>

<p>&lt;[11]&gt; ClassOne tests &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;</p>

<p>&lt;[3]&gt; ClassOne.<strong>init</strong> ©</p>

<p>&lt;[5]&gt; ClassOne.method_x</p>

<p>&lt;[12]&gt; ClassThree tests &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;</p>

<p>&lt;[300]&gt; deco_alpha:inner_1 ©</p>

<p>&lt;[13]&gt; ClassFour tests &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;</p>

<p>&lt;[10]&gt; ClassFour.method_y &lt;[14]&gt; evaltime module end &lt;[4]&gt; ClassOne.<strong>del</strong> ©</p>

<p>❶ 目前为止，输出与示例 21-8 相同。</p>

<p>❷ 类的标准行为。</p>

<p>❸ deco_alpha 装饰器修改了 ClassThree.method_y 方法，因此调用</p>

<p>three.method_y() 时会运行 inner_1 函数的定义体。</p>

<p>❹ 只有程序结束时，绑定在全局变量 one 上的 ClassOne 实例才会被垃圾回收程序</p>

<p>回收。</p>

<p>场景 2 主要想说明的是，类装饰器可能对子类没有影响。在示例 21-6 中，我们把</p>

<p>ClassFour 定义为 ClassThree 的子类。 ClassThree 类上依附的 @deco_alpha 装 饰器把 method_y 方法替换掉了，但是这对 ClassFour 类根本没有影响。当然，如 果 ClassFour.method_y 方法使用 super(&hellip;) 调用 ClassThree.method_y 方</p>

<p>法，我们便会看到装饰器起作用，执行 inner_1 函数。</p>

<p>与此不同的是，如果想定制整个类层次结构，而不是一次只定制一个类，使用下一节</p>

<p>介绍的元类更高效。</p>

<h3 id="21-4-元类基础知识">21.4 元类基础知识</h3>

<p>元类是制造类的工厂，不过不是函数（如示例21-2中的record_factory）,而是类。 图 21-1 使用机器和小怪兽图示法描述元类，可以看出，元类是生产机器的机器。</p>

<p><img src="08414584Python-97.jpg" alt="img" /></p>

<p><img src="08414584Python-98.jpg" alt="img" /></p>

<p>舰s丨 Giznvoj Notation</p>

<p>图 21-1：元类是用于构建类的类</p>

<p>根据 Python 对象模型，类是对象，因此类肯定是另外某个类的实例。默认情况下， Python</p>

<p>中的类是 type 类的实例。也就是说， type 是大多数内置的类和用户定义的类的元类：</p>

<p>&gt;&gt;&gt; &lsquo;spam&rsquo;.<strong>class</strong></p>

<p><class 'str'></p>

<p>&gt;&gt;&gt; str.<strong>class</strong></p>

<p><class 'type'></p>

<p>&gt;&gt;&gt; from bulkfood_v6 import LineItem &gt;&gt;&gt; LineItem.<strong>class</strong></p>

<p><class 'type'></p>

<p>&gt;&gt;&gt; type.<strong>class</strong></p>

<p><class 'type'></p>

<p>为了避免无限回溯， type 是其自身的实例，如最后一行所示。</p>

<p>注意，我没有说str或Lineltem继承自type。我的意思是，str和Lineltem是type</p>

<p>的实例。这两个类是 object 的子类。图 21-2 可能有助于你理清这个奇怪的现象。</p>

<p>图 21-2：两个示意图都是正确的。左边的示意图强调 str、type 和 LineItem 是 object 的子类。右边的示意图则清楚地表明 str、object 和 LineItem 是 type 的实 例，因为它们都是类</p>

<p>object类和type类之间的关系很独特：object是type的实例，而type 是 object 的子类。这种关系很“神奇”，无法使用 Python 代码表述，因为定义其中一 个之前另一个必须存在。 type 是自身的实例这一点也很神奇。</p>

<p>除了 type，标准库中还有一些别的元类，例如ABCMeta和Enum。如下述代码片段所 示， collections.Iterable 所属的类是 abc.ABCMeta。 Iterable 是抽象类，而 ABCMeta 不是——不管怎样， Iterable 是 ABCMeta 的实例：</p>

<p>&gt;&gt;&gt; import collections</p>

<p>&gt;&gt;&gt; collections.Iterable.<strong>class</strong></p>

<p><class 'abc.ABCMeta'></p>

<p>&gt;&gt;&gt; import abc</p>

<p>&gt;&gt;&gt; abc.ABCMeta.<strong>class</strong></p>

<p><class 'type'></p>

<p>&gt;&gt;&gt; abc.ABCMeta.<strong>mro</strong></p>

<p>(<class 'abc.ABCMeta'>, <class 'type'>, <class 'object'>)</p>

<p>向上追溯，ABCMeta最终所属的类也是type。所有类都直接或间接地是type的实例， 不过只有元类同时也是 type 的子类。若想理解元类，一定要知道这种关系：元类（如 ABCMeta）从type类继承了构建类的能力。图21-3对这种至关重要的关系做了图解。</p>

<p>图 21-3： Iterable 是 object 的子类，是 ABCMeta 的实例。 object 和 ABCMeta 都是 type 的实例，但是这里的重要关系是， ABCMeta 还是 type 的子类，因为 ABCMeta 是 元类。示意图中只有 Iterable 是抽象类</p>

<p>我们要抓住的重点是，所有类都是 type 的实例，但是元类还是 type 的子类，因此可以 作为制造类的工厂。具体来说，元类可以通过实现 <strong>init</strong> 方法定制实例。元类的 <strong>init</strong> 方法可以做到类装饰器能做的任何事情，但是作用更大，如接下来的练习所</p>

<p>示。</p>

<p>理解元类计算时间的练习</p>

<p>我们对 21+3 节的练习做些改动， evalsupport+py 模块与示例 21-7 一样，不过现在主脚本变</p>

<p>成 evaltime_meta+py 了，如示例 21-10 所示。</p>

<p>示例 21-10 evaltime_meta+py： ClassFive 是 MetaAleph 元类的实例</p>

<p>@deco_alpha</p>

<p>class ClassThree():</p>

<p>print(&rsquo;&lt;[2]&gt; ClassThree body&rsquo;)</p>

<p>def method_y(self):</p>

<p>print(&rsquo;&lt;[3]&gt; ClassThree.method_y&rsquo;)</p>

<p>class ClassFour(ClassThree):</p>

<p>print(&rsquo;&lt;[4]&gt; ClassFour body&rsquo;)</p>

<p>def method_y(self):</p>

<p>print(&rsquo;&lt;[5]&gt; ClassFour.method_y&rsquo;)</p>

<p>class ClassFive(metaclass=MetaAleph): print(&rsquo;&lt;[6]&gt; ClassFive body&rsquo;)</p>

<p>def <strong>init</strong>(self):</p>

<p>print(&rsquo;&lt;[7]&gt; ClassFive.<strong>init</strong>&rsquo;)</p>

<p>def method_z(self):</p>

<p>print(&rsquo;&lt;[8]&gt; ClassFive.method_z&rsquo;)</p>

<p>class ClassSix(ClassFive):</p>

<p>print(&rsquo;&lt;[9]&gt; ClassSix body&rsquo;)</p>

<p>def method_z(self):</p>

<p>print(&rsquo;&lt;[10]&gt; ClassSix.method_z&rsquo;)</p>

<p>if <strong>name</strong> == &lsquo;<strong>main</strong>&lsquo;:</p>

<p>print(&rsquo;&lt;[11]&gt; ClassThree tests&rsquo;, 30 * &lsquo;.&rsquo;)</p>

<p>three = ClassThree()</p>

<p>three.method_y()</p>

<p>print(&rsquo;&lt;[12]&gt; ClassFour tests&rsquo;, 30 * &lsquo;.&rsquo;)</p>

<p>four = ClassFour()</p>

<p>four.method_y()</p>

<p>print(&rsquo;&lt;[13]&gt; ClassFive tests&rsquo;, 30 * &lsquo;.&rsquo;)</p>

<p>five = ClassFive()</p>

<p>five.method_z()</p>

<p>print(&rsquo;&lt;[14]&gt; ClassSix tests&rsquo;, 30 * &lsquo;.&rsquo;)</p>

<p>six = ClassSix()</p>

<p>six.method_z()</p>

<p>print(&rsquo;&lt;[15]&gt; evaltime_meta module end&rsquo;)</p>

<h4 id="同样-请拿出纸和笔-按顺序写出下述两个场景中输出的序号标记-n-场景-3">同样，请拿出纸和笔，按顺序写出下述两个场景中输出的序号标记 &lt;[N]&gt;。 场景 3</h4>

<p>在 Python 控制台中以交互的方式导入 evaltime_meta.py 模块。</p>

<p>场景 4</p>

<p>在命令行中运行 evaltime_meta.py 模块。</p>

<p>解答和分析如下。</p>

<ol>
<li>场景3的解答</li>
</ol>

<p>在 Python 控制台中导入 evaltime_meta.py 模块后得到的输出如示例 21-11 所示。 示例 21-11 场景 3：在 Python 控制台中导入 evaltime_meta 模块</p>

<p>&gt;&gt;&gt; import evaltime_meta</p>

<p>&lt;[100]&gt; evalsupport module start</p>

<p>&lt;[400]&gt; MetaAleph body</p>

<p>&lt;[700]&gt; evalsupport module end</p>

<p>&lt;[1]&gt; evaltime_meta module start</p>

<p>&lt;[2]&gt; ClassThree body</p>

<p>&lt;[200]&gt; deco_alpha</p>

<p>&lt;[4]&gt; ClassFour body</p>

<p>&lt;[6]&gt; ClassFive body</p>

<p>&lt;[500]&gt; MetaAleph.<strong>init</strong> O</p>

<p>&lt;[9]&gt; ClassSix body</p>

<p>&lt;[500]&gt; MetaAleph.<em>init</em> ©</p>

<p>&lt;[15]&gt; evaltime meta module end</p>

<p>O 与场景 1 的关键区别是，创建 ClassFive 时调用了 MetaAleph.<strong>init</strong> 方 法。</p>

<p>© 创建 ClassFive 的子类 ClassSix 时也调用了 MetaAleph.<strong>init</strong> 方法。</p>

<p>Python 解释器计算 ClassFive 类的定义体时没有调用 type 构建具体的类定义体 而是调用 MetaAleph 类。看一下示例 21-12 中定义的 MetaAleph 类，你会发现</p>

<p><strong>init</strong> 方法有四个参数。</p>

<p>self</p>

<p>这是要初始化的类对象(例如 ClassFive)。</p>

<p>name、bases、dic</p>

<p>与构建类时传给 type 的参数一样。</p>

<p>示例 21-12 evalsupport.py:定义 MetaAleph 元类，摘自示例 21-7</p>

<p><img src="08414584Python-102.jpg" alt="img" /></p>

<h4 id="编写元类时-通常会把self参数改成cls-例如-在上述元类的-init-方法中-把第一个参数命名为-cls-能清楚地表明要构建的实例是类">编写元类时，通常会把self参数改成cls。例如，在上述元类的 <strong>init</strong> 方法中，把第一个参数命名为 cls 能清楚地表明要构建的实例是类。</h4>

<p><strong>init</strong> 方法的定义体中定义了 inner_2 函数，然后将其绑定给 cls.method_z。 MetaAleph.<strong>init</strong> 方法签名中的 cls 指代要创建的类（例如 ClassFive）。而inner_2函数签名中的self最终是指代我们在创建的类的实例 （例如 ClassFive 类的实例）。</p>

<h4 id="02-场景4的解答">02. 场景4的解答</h4>

<p>在命令行中运行 python3 evaltime_meta.py 命令后得到的输出如示例 21-13 所</p>

<p>示。</p>

<p>示例 21-13 场景 4：在 shell 中运行 evaltime_meta.py</p>

<p>$ python3 evaltime.py &lt;[100]&gt; evalsupport module start &lt;[400]&gt; MetaAleph body &lt;[700]&gt; evalsupport module end &lt;[1]&gt; evaltime_meta module start &lt;[2]&gt; ClassThree body &lt;[200]&gt; deco_alpha &lt;[4]&gt; ClassFour body &lt;[6]&gt; ClassFive body &lt;[500]&gt; MetaAleph.<strong>init</strong></p>

<p>&lt;[9]&gt; ClassSix body &lt;[500]&gt; MetaAleph.<strong>init</strong></p>

<p>&lt;[11]&gt; ClassThree tests &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;</p>

<p>&lt;[300]&gt; deco_alpha:inner_1 O</p>

<p>&lt;[12]&gt; ClassFour tests &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;</p>

<p>&lt;[5]&gt; ClassFour.method_y ©</p>

<p>&lt;[13]&gt; ClassFive tests &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;</p>

<p>&lt;[7]&gt; ClassFive.<strong>init</strong></p>

<p>&lt;[600]&gt; MetaAleph.<em>init</em>:inner_2 ©</p>

<p>&lt;[14]&gt; ClassSix tests &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;</p>

<p>&lt;[7]&gt; ClassFive.<strong>init</strong></p>

<p>&lt;[600]&gt; MetaAleph.<em>init</em>:inner_2 ©</p>

<p>&lt;[15]&gt; evaltime_meta module end</p>

<h4 id="❶-装饰器依附到-classthree-类上之后-method-y-方法被替换成-inner-1-方-法">❶ 装饰器依附到 ClassThree 类上之后， method_y 方法被替换成 inner_1 方 法……</h4>

<p>❷ 虽然 ClassFour 是 ClassThree 的子类，但是没有依附装饰器的 ClassFour 类</p>

<p>却不受影响。</p>

<p>❸ MetaAleph 类的 <strong>init</strong> 方法把 ClassFive.method_z 方法替换成 inner_2</p>

<p>函数。</p>

<p>❹ ClassFive 的子类 ClassSix 也是一样， method_z 方法被替换成 inner_2 函 数。</p>

<p>注意，ClassSix类没有直接引用MetaAleph类，但是却受到了影响，因为它是 ClassFive 的子类，进而也是 MetaAleph 类的实例，所以由 MetaAleph.__init</p>

<p>方法初始化。</p>

<p>方法。不过，通常情</p>

<p>胃如果想进一步定制类，可以在元类中实现_<em>new</em></p>

<p>况下实现 <strong>init</strong> 方法就够了。</p>

<p>现在，我们可以实践这些理论了。我们将创建一个元类，让描述符以最佳的方式自动</p>

<p>创建储存属性的名称。</p>

<h3 id="21-5-定制描述符的元类">21.5 定制描述符的元类</h3>

<p>回到 LineItem 系列示例。如果用户完全不用知道描述符或元类，直接继承库提供的类就 能满足需求，那该多好。如示例 21-14 所示。</p>

<h4 id="示例21-14-bulkfood-v7-py-有元类的支持-继承model-entity类即可">示例21-14 bulkfood_v7.py：有元类的支持，继承model.Entity类即可</h4>

<p>import model_v7 as model</p>

<p>class LineItem(model.Entity): O</p>

<p>description = model.NonBlank()</p>

<p>weight = model.Quantity() price = model.Quantity()</p>

<p>def <strong>init</strong>(self, description, weight, price): self.description = description self.weight = weight self.price = price</p>

<p>def subtotal(self):</p>

<p>return self.weight * self.price</p>

<h4 id="o-lineitem-是-model-entity-的子类">O LineItem 是 model.Entity 的子类。</h4>

<p>示例 21-14 理解起来相当容易，毕竟根本没有奇怪的句法。可是， model_v7.py 模块必须</p>

<p>定义一个元类，而且model.Entity类是那个元类的实例。model_v7+py］莫块中实现的 Entity 类如示例 21-15 所示。</p>

<p>示例 21-15 model_v7.py： EntityMeta 元类以及它的一个实例 Entity</p>

<p>class EntityMeta(type):</p>

<p>&rdquo;&ldquo;&ldquo;元类，用于创建带有验证字段的业务实体 &ldquo;&rdquo;&rdquo;</p>

<p>def <strong>init</strong>(cls, name, bases, attr_dict):</p>

<p>super().<strong>init</strong>(name, bases, attr_dict) O for key, attr in attr_dict.items(): © if isinstance(attr, Validated): type_name = type(attr).<strong>name</strong> attr.storage<em>name = &lsquo;</em>{}#{}&lsquo;.format(type_name, key)</p>

<p>class Entity(metaclass=EntityMeta): ©</p>

<p>&rdquo;&ldquo;&ldquo;带有验证字段的业务实体 &ldquo;&rdquo;&rdquo;</p>

<h4 id="❶在超类-在这里是type-上调用-init-方法">❶在超类（在这里是type）上调用_init__方法。</h4>

<p>❷ 与示例 21-4 中 @entity 装饰器的逻辑一样。</p>

<p>❸ 这个类的存在只是为了用起来便利：这个莫块的用户直接继承 Entity 类即可，无需</p>

<p>关心 EntityMeta 元类，甚至不用知道它的存在。</p>

<p>示例 21-14 中的代码能通过示例 21-3 中的测试。辅助模块 model_v7.py 比 model_v6.py 难 理解，但是用户级别的代码更简单：只需继承 model_v7.Entity 类， Validated 字段就 能自动获得储存属性的名称。</p>

<p>图 21-4 使用简单的图示说明了我们刚刚实现的逻辑。虽然有很多复杂的逻辑，但都隐藏 在 model_v7 模块中。从用户的角度来看，示例 21-14 中的 LineItem 只是 Entity 的子 类。这就是抽象的作用。</p>

<p>图21-4：使用机器和小怪兽图示法（MGN）注解的UML类图。EntityMeta元机器 用于生产 Lineltem机器。描述符（如 weight 和 price）由 EntityMeta.<strong>init</strong></p>

<p>方法配置。注意 model_v7 模块的边界</p>

<p>除了把类链接到元类上的句法之外 5，目前编写元类使用的句法在 Python 2.2（这个版本 对 Python 类型做了重大改造）之后都能使用。下一节介绍一个只能在 Python 3 中使用的 功能。</p>

<h3 id="21-6-元类的特殊方法-prepare">21.6 元类的特殊方法 <strong>prepare</strong></h3>

<p>在某些应用中，可能需要知道类的属性定义的顺序。例如，对读写 CSV 文件的库来说， 用户定义的类可能想把类中按顺序声明的字段与 CSV 文件中各列的顺序对应起来。</p>

<p>如前所述， type 构造方法及元类的 <strong>new</strong> 和 <strong>init</strong> 方法都会收到要计算的类的定</p>

<p>义体，形式是名称到属性的映像。然而在默认情况下，那个映射是字典；也就是说，元类</p>

<p>或类装饰器获得映射时，属性在类定义体中的顺序已经丢失了。</p>

<p>这个问题的解决办法是，使用 Python 3 引入的特殊方法 <strong>prepare</strong>。这个特殊方法只 在元类中有用，而且必须声明为类方法（即，要使用 @classmethod 装饰器定义）。解 释器调用元类的 <strong>new</strong> 方法之前会先调用 <strong>prepare</strong> 方法，使用类定义体中的属性 创建映射。 <strong>prepare</strong> 方法的第一个参数是元类，随后两个参数分别是要构建的类的 名称和基类组成的元组，返回值必须是映射。元类构建新类时， <strong>prepare</strong> 方法返回 的映射会传给 <strong>new</strong> 方法的最后一个参数，然后再传给 <strong>init</strong> 方法。 理论听起来很复杂，但是我见过的 <strong>prepare</strong> 方法都十分简单。请看示例 21-16。</p>

<p>示例 21-16 model_v8.py：这一版 EntityMeta 元类用到了 <strong>prepare</strong> 方法，而 且为 Entity 类定义了 field_names 类方法</p>

<p>class EntityMeta(type):</p>

<p>&rdquo;&ldquo;&ldquo;元类，用于创建带有验证字段的业务实体 &ldquo;&rdquo;&rdquo;</p>

<p>@classmethod</p>

<p>def <strong>prepare</strong>(cls, name, bases):</p>

<p>return collections.OrderedDict() O</p>

<p>def <strong>init</strong>(cls, name, bases, attr_dict): super().<strong>init</strong>(name, bases, attr_dict) cls._field_names = [] ©</p>

<p>for key, attr in attr_dict.items():    ©</p>

<p>if isinstance(attr, Validated): type_name = type(attr).<strong>name</strong> attr.storage<em>name = &lsquo;</em>{}#{}&lsquo;.format(type_name, key) cls._field_names.append(key) ©</p>

<p>class Entity(metaclass=EntityMeta):</p>

<p>&rdquo;&ldquo;&ldquo;带有验证字段的业务实体 &ldquo;&rdquo;&rdquo;</p>

<p>@classmethod</p>

<p>def field_names(cls):❺</p>

<p>for name in cls._field_names: yield name</p>

<p>❶ 返回一个空的 OrderedDict 实例，类属性将存储在里面。</p>

<p>❷ 在要构建的类中创建一个 _field_names 属性。</p>

<p>❸ 这一行与前一版相比没有变化，不过这里的 attr_dict 是那个 OrderedDict 对象， 由解释器在调用 <strong>init</strong> 方法之前调用 <strong>prepare</strong> 方法时获得。因此，这个 for 循 环会按照添加属性的顺序迭代属性。</p>

<p>❹ 把找到的各个 Validated 字段添加到 _field_names 属性中。</p>

<p>❺ field_names 类方法的作用简单：按照添加字段的顺序产出字段的名称。</p>

<p>像示例 21-16 那样添加一些简单的代码之后，我们可以使用 field_names 类方法迭代任 何 Entity 子类的 Validated 字段。示例 21-17 演示了这个新功能。</p>

<p>示例 21-17 bulkfood_v8+py：展示 field_names 用法的 doctest-无需修改</p>

<p>LineItem 类， field_names 方法继承自 model.Entity 类</p>

<p>&gt;&gt;&gt; for name in LineItem.field_names(): &hellip; print(name)</p>

<p>description</p>

<p>weight</p>

<p>price</p>

<p>对元类的介绍到此结束。在现实世界中，框架和库会使用元类协助程序员执行很多任务，</p>

<p>例如：</p>

<p>•验证属性</p>

<p>•一次把装饰器依附到多个方法上 •序列化对象或转换数据 •对象关系映射 •基于对象的持久存储 •动态转换使用其他语言编写的类结构</p>

<p>下一节将概述 Python 数据莫型为所有类定义的方法。</p>

<p><a href="#footnote1">1</a></p>

<p>例如，A. M. Kuchling发表的著名文章4“Python Warts”(存</p>

<p>档：<a href="http://web.archive.org/web/20031002184114/www.amk.ca/python/writing/warts.html">http://web.archive.org/web/20031002184114/www.amk.ca/python/writing/warts.html</a>)。Kuchling 自己并不讨厌 self 限定</p>

<p>符，但是他提到了这一点——可能是为了呼应 comp.lang.python 邮件列表中的观点。</p>

<h3 id="21-7-类作为对象">21.7 类作为对象</h3>

<p>Python数据模型为每个类定义了很多属性，参见标准库参考中“Built-in Types”一章的“4.13. Special Attributes”一节(<a href="https://docs.python.org/3/library/stdtypes.html%23special-attributes">https://docs.python.Org/3/library/stdtypes.html#special-attributes</a>)。 其中三个属性在本书中已经见过多次： <strong>mro</strong>、<strong>class</strong> 和 <strong>name</strong>。此外，还有 以下属性。</p>

<p>cls.<strong>bases</strong></p>

<p>由类的基类组成的元组。</p>

<p>cls.<strong>qualname</strong></p>

<p>Python 3.3 新引入的属性，其值是类或函数的限定名称，即从模块的全局作用域到类 的点分路径。例如，在示例 21-6 中，内部类 ClassTwo 的 <strong>qualname</strong> 属性，其值是</p>

<p>字符串’ClassOne.ClassTwo•，而<strong>name</strong>属性的值是’ClassTwo&rsquo;。这个属性的规 范是“PEP 3155—Qualified name for classes and functions” (<a href="https://www.python.org/dev/peps/pep-3155/">https://www.python.org/dev/peps/pep-3155/</a>) 。 cls.<strong>subclasses</strong>()</p>

<p>这个方法返回一个列表，包含类的直接子类。这个方法的实现使用弱引用，防止在超 类和子类(子类在 <strong>bases</strong> 属性中储存指向超类的强引用)之间出现循环引用。这个</p>

<p>方法返回的列表中是内存里现存的子类。</p>

<p>cls.mro()</p>

<p>构建类时，如果需要获取储存在类属性 <strong>mro</strong> 中的超类元组，解释器会调用这个 方法。元类可以覆盖这个方法，定制要构建的类解析方法的顺序。</p>

<p><img src="08414584Python-104.jpg" alt="img" /></p>

<p>dir(&hellip;) 函数不会列出本节提到的任何一个属性。</p>

<p>我们对类元编程的学习到此结束。这是个很大的话题，我只讲了皮毛。因此，本书各章都</p>

<p>有“延伸阅读”一节。</p>

<h3 id="21-8-本章小结">21.8 本章小结</h3>

<p>类元编程是指动态创建或定制类。在 Python 中，类是一等对象，因此本章首先说明如何 通过调用内置的 type 元类，使用函数创建类。</p>

<p>接下来的一节继续讨论第 20 章使用描述符实现的 LineItem 类，解决一个遗留问题：如</p>

<p>何让生成的储存属性名中包含托管属性的名称(例如，把 _Quantity#1 变成</p>

<p>_Quantity#price)。解决办法是使用类装饰器。说到底，类装饰器是函数，其参数是 被装饰的类，用于审查和修改刚创建的类，甚至替换成其他类。</p>

<p>然后，本章讨论了莫块中不同部分的代码何时运行。我们发现，所谓的“导入时”和“运行 时”之间有重叠，不过很明显， import 语句会触发运行大量代码。知道代码何时运行至关 重要，可是有些规则难以捉摸，因此我们通过两个计算时间练习对此做了说明。</p>

<p>接下来，本章介绍了元类。我们得知，所有类都直接或间接地是 type 的实例，因此在 Python 中， type 是“根元类”。然后，我们对之前的计算时间练习做了修改，以此说明元</p>

<p>类可以定制类的层次结构。类装饰器则不同，它只能影响一个类，而且对后代可能没有影</p>

<p>响。</p>

<p>随后，我们实际使用元类，解决 LineItem 类中储存属性的命名问题。最终写出的代码比 类装饰器难懂一些，不过可以封装在一个莫块里，这样用户只需继承看似普通的一个类</p>

<p>(model.Entity)，而不用知道它是元类(model.EntityMeta)的实例。这种处理方 式让人想起了 Django和SQLAlchemy的ORM API：使用元类实现，用户却根本无需知 道。</p>

<p>我们实现的第二个元类为 model.EntityMeta 类添加了一个小功能：定义 <strong>prepare</strong></p>

<p>方法，返回一个 OrderedDict 对象，用于储存名称到属性的映射。这样做能保留要构建 的类在定义体中绑定属性的顺序，提供给元类的 <strong>new</strong> 和 <strong>init</strong> 等方法使用。在 这个示例中，我们定义了类属性_field_names，因此用户可以使用</p>

<p>Entity.field_names() 方法以 Validated 描述符出现在源码中的顺序获取描述符。</p>

<p>最后一节，我们概述了 Python 为所有类提供的属性和方法。</p>

<p>元类是充满挑战、让人兴奋的功能，有时会被故作聪明的程序员滥用。最后，我们回顾一</p>

<p>下 Alex Martelli 在他写的“水禽和抽象基类”一文的最后给我们的建议：</p>

<p>此外，不要在生产代码中定义抽象基类(或元类)+ + + + + +如果你很想这样做，我打赌可</p>

<p>能是因为你想“找茬”，刚拿到新工具的人都有大干一场的冲动。如果你能避开这些深</p>

<p>奥的概念，你(以及未来的代码维护者)的生活将更愉快，因为代码简洁明了。</p>

<p>——Alex Martelli</p>

<p>说出上述至理名言的人不仅是 Python 元编程大师，还是造诣颇深的软件工程师，负责世</p>

<p>界上几个最重要的 Python 应用。</p>

<h3 id="21-9延伸阅读">21.9延伸阅读</h3>

<p>为了深入学习本章所述的知识，一定要阅读Python语言参考手册中“Data Model”一章里 的“3.3.3. Customizing class creation”一节</p>

<p>(<a href="https://docs.python.org/3/reference/datamodel.html%23metaclasses">https://docs.python.Org/3/reference/datamodel.html#metaclasses</a>) 、“Built-in Functions”一章 中 type 类的文档(<a href="https://docs.python.org/3/library/functions.html%23type">https://docs+python+org/3/library/fUnctions+html#type</a>)，以及标准库参考 中“Built-in Types”一章里的“4.13. Special Attributes”一节</p>

<p>(<a href="https://docs.python.org/3/library/stdtypes.html%23special-attributes">https://docs.python.org/3/library/stdtypes.html#special-attributes</a>) 。此外，在标准库参考 中，types 模块的文档(<a href="https://docs.python.org/3/library/types.html">https://docs+python+org/3/library/types+html</a>)说明了 Python 3.3 引入 的两个新函数，这两个函数用于辅助类元编程： types.new_class(&hellip;) 和 types. prepare_class(&hellip;)。</p>

<p>类装饰器的规范是“PEP 3129—Class Decorators” (<a href="https://www.python.org/dev/peps/pep-3129/">https://www.python.org/dev/peps/pep-3129/</a>%ef%bc%8c%e4%bd%9c%e8%80%85%e6%98%af)<a href="https://www.python.org/dev/peps/pep-3129/">)，作者是</a>%ef%bc%8c%e4%bd%9c%e8%80%85%e6%98%af)<a href="https://www.python.org/dev/peps/pep-3129/"> Collin Winter，参考实现由 Jack Diederich 提供。Jack Diederich 在 PyC</a>on 2009 大会上做了一场题为“Class Decorators: Radically Simple” 的演讲(视</p>

<p>频： <a href="https://www.youtube.com/watch?v=cAGliEJV9_o">https://www.youtube.com/watch?v=cAGliEJV9_o</a>) ，对这个功能做了简单介绍。</p>

<p>Alex Martelli写的《Python技术手册(第2版)》对元类的说明很出色，还实现了 metaMetaBunch 元类，其作用与示例 21-2 中简单的 record_factory 函数一样，不过完 善得多。 Martelli 没有探讨类装饰器，因为这个功能在那本书出版后才引入。 Beazley 和 Jones在他们合著的《Python Cookbook (第3版)中文版》中提供了几个示例，很好地演 示了类装饰器和元类。Michael Foord写了一篇引人入胜的文章，题为“Meta-classes Made Easy: Eliminating self with</p>

<p>Metaclasses” ( <a href="http://www.voidspace.org.uk/python/articles/metaclasses.shtml">http://www.voidspace.org.uk/python/articles/metaclasses.shtml </a>) 。副标题( “借 助元类去掉self’)说明了一切。</p>

<p>元类的主要参考资料有引入特殊方法_prepare__的“PEP 3115—Metaclasses in Python 3000” (<a href="https://www.python.org/dev/peps/pep-3115/">https://www.python.org/dev/peps/pep-3115/</a>) ，以及 Guido van Rossum 发布的文 章“Unifying types and classes in Python</p>

<p>2.2” (<a href="https://www.python.org/download/releases/2.2.3/descrintro/">https://www.python.org/download/releases/2.2.3/descrintro/</a>) 。这篇文章也适用于 Python 3，谈到了后来称为“新式类”的语义，包括描述符和元类，一定要阅读。 Guido 在文 中提到了 Ira R. Forman 与 Scott H. Danforth 合著的 Putting Metaclasses to Work: a New Dimension in Object-Oriented Programming( Addison- Wesley 出版社， 1998 年)，他在亚 马逊上给这本书打了五颗星，还写了如下评论：</p>

<p>这本书促成 Python 2.2 实现了元类</p>

<p>可惜，这本书已经绝版了。 Python 通过 super() 函数实现了协作式多重继承，谈到</p>

<p>这方面的难题时，我总会提到这本书；据我所知，这本书是这方面最好的教程。 6</p>

<p>I 6摘自亚马逊网站中Putting Metaclasses to Work的商品目录页面(<a href="http://amzn.to/1HGwKDO">http://amzn.to/1HGwKDO </a>)。目前还有二手书出售。 我买了一本，发现很难读懂，不过以后我可能会再读。</p>

<p>“PEP 487—Simpler customization of class creation” (<a href="https://www.python.org/dev/peps/pep-0487/">https://www.python.org/dev/peps/pep-0487/</a>%e6%8f%90%e8%ae%ae%e4%b8%ba)<a href="https://www.python.org/dev/peps/pep-0487/">)提议为</a>%e6%8f%90%e8%ae%ae%e4%b8%ba)<a href="https://www.python.org/dev/peps/pep-0487/"> Python 3.5(写到这里时，处于内测阶段)添加一个新的特殊方法</a></p>

<p><strong>init_subclass</strong>， 7 让普通的类(即，不是元类)定制子类的初始化。与类装饰器 一样， <strong>init_subclass</strong> 方法能让类元编程变得更简单，但会导致元类这个强大的功</p>

<p>能更难正确使用。</p>

<p>| 7现在，Python 3+5己经正式发布，PEP 487没有在Python 3+5中实现，而是推迟到Python 3+6中。——编者注</p>

<p>如果你喜欢元编程，可能希望Python提供基本的元编程功能——Elixir和Lisp语言族提供 的句法宏。天遂人愿，我们有 MacroPy (<a href="https://github.com/lihaoyi/macropy">https://github+com/lihaoyi/macropy</a>)可用。</p>

<p>杂谈</p>

<p>这是本书最后一篇“杂谈”了，首先我要从 Brian Harvey 与 Matthew Wright 合写的著作 中引述一大段文字。 Harvey 和 Wright 是加州大学(伯克利分校和圣巴巴拉分校)的 计算机科学教授，他们在合著的 Simply Scheme 一书中写道：</p>

<p>计算机科学的教学方式分成两个流派，可以描述如下。</p>

<p>(1)    保守派 计算机程序己经变得极其大而复杂，超过了人类思维所能承载的限 度。因此，计算机科学教育的任务是训练平庸的程序员，这样 500 个人合作便能 开发出恰好满足需求的程序。</p>

<p>(2)    激进派 计算机程序己经变得极其大而复杂，超过了人类思维所能承载的限 度。因此，计算机科学教育的任务是教人如何拓展思维，打破常规，学习以更广</p>

<p>博、更强大和更灵活的方式思考，让思维超越程序。编程思想的各个方面在程序 中必会得到充分体现。 8[Brian Harvey and Matthew Wright, Simply Scheme (MIT Press, 1999), p+ xvii+ 伯克利分校的网站中有此书全文</p>

<p>(<a href="https://www.eecs.berkeley.edu/~bh/ss-toc2.html">https://www+eecs+berkeley+edu/~bh/ss-toc2+html</a>) 。 ]}</p>

<p>——Brian Harvey 和 Matthew Wright</p>

<p>Simply Scheme 前言</p>

<p>这是 Harvey 和 Wright 对计算机科学教育的夸张描述，不过也适用于编程语言的设 计。现在，你应该能猜到，我赞成“激进派”，我认为 Python 也是以这种态度设计 的。</p>

<p>为了稳扎稳打， Java 从一开始使用的就是存取方法，而且众多 Java IDE 都提供了生</p>

<p>成读值方法和设值方法的快捷键；与此相比，特性算是一大进步。特性的主要优点</p>

<p>是，一开始编写程序时可以先把属性设为公开的(遵照 KISS 原则)，因为公开的属</p>

<p>性无需大幅改动，随时都能变成特性。不过，描述符更进一步，提供了去除存取方法</p>

<p>中逻辑重复的机制。这种机制特别有效，因此基本的 Python 结构在背后也用到了描</p>

<p>述符。</p>

<p>另一个强大的想法是，把函数当作一等对象，这为高阶函数铺平了道路。描述符和高 阶函数合在一起实现，使得函数和方法的统一成为可能。函数的 <strong>get</strong> 方法能即 时生成方法对象，把实例绑定到 self 参数上。这种做法相当优雅。 9</p>

<p>最后， Python 中的类也是一等对象。作为一门对初学者友好的语言， Python 能提供类</p>

<p>装饰器，允许用户定义功能完整的元类，这些强大的抽象真是太棒了。最棒的是，这 些高级功能没有拖累日常编程（其实无形中提供了帮助）。 Django 和 SQLAlchemy 等 框架用起来这么方便，发展得这么成功，很大程度上归功于元类，而这些工具的用户 甚至不知道元类的存在。不过，他们可以学习，去创建下一个伟大的库。</p>

<p>我还未见过有哪门语言像 Python 这样竭尽所能，让初学者易于入门，让专业人士用</p>

<p>着顺手，让程序高手欢欣鼓舞。感谢Guido van Rossum，以及为此努力的每个人。</p>

<p>9David Gelernter 写的 Machine Beauty（Basic Books 出版社）是一本非常有趣的小书，对工程作品（从桥梁到软件）的 优雅和美学做了阐述。</p>

    </div>

    
    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">iterateself</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">2018-06-26</span>
  </p>
  
  
</div>

    
    

    <footer class="post-footer">
      

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02-python/%E6%B5%81%E7%95%85%E7%9A%84-python/20-%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">20 属性描述符</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02-python/%E6%B5%81%E7%95%85%E7%9A%84-python/03-%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88/">
            <span class="next-text nav-default">03 字典和集合</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="iteratelyd@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="http://github.com/iterateself" class="iconfont icon-github" title="github"></a>
      <a href="https://www.zhihu.com/people/thebegin/activities" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="https://www.douban.com/people/68028070/" class="iconfont icon-douban" title="douban"></a>
  <a href="http://iterate.site/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> site pv: <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
    <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> site uv: <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2018
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">iterateself</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>


<script type="text/javascript" src="/dist/even.min.js?v=3.2.0"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>








</body>
</html>
