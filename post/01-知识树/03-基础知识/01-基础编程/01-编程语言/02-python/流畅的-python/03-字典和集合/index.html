<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>03 字典和集合 - 迭代自己</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="iterateself" />
  <meta name="description" content="第 3 章 字典和集合 字典这个数据结构活跃在所有 Python 程序的背后，即便你的源码里并没有直接用到 它。 ——A. M. Kuchling 《代码之美》第18章“Python的字典" />

  <meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.47.1" />


<link rel="canonical" href="http://iterate.site/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02-python/%E6%B5%81%E7%95%85%E7%9A%84-python/03-%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">




<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<link href="/dist/even.min.css?v=3.2.0" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">




<meta property="og:title" content="03 字典和集合" />
<meta property="og:description" content="第 3 章 字典和集合 字典这个数据结构活跃在所有 Python 程序的背后，即便你的源码里并没有直接用到 它。 ——A. M. Kuchling 《代码之美》第18章“Python的字典" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://iterate.site/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02-python/%E6%B5%81%E7%95%85%E7%9A%84-python/03-%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88/" /><meta property="article:published_time" content="2018-06-26T21:32:38&#43;00:00"/>
<meta property="article:modified_time" content="2018-06-26T21:32:38&#43;00:00"/>
<meta itemprop="name" content="03 字典和集合">
<meta itemprop="description" content="第 3 章 字典和集合 字典这个数据结构活跃在所有 Python 程序的背后，即便你的源码里并没有直接用到 它。 ——A. M. Kuchling 《代码之美》第18章“Python的字典">


<meta itemprop="datePublished" content="2018-06-26T21:32:38&#43;00:00" />
<meta itemprop="dateModified" content="2018-06-26T21:32:38&#43;00:00" />
<meta itemprop="wordCount" content="21294">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="03 字典和集合"/>
<meta name="twitter:description" content="第 3 章 字典和集合 字典这个数据结构活跃在所有 Python 程序的背后，即便你的源码里并没有直接用到 它。 ——A. M. Kuchling 《代码之美》第18章“Python的字典"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">迭代自己</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/recent/">
        <li class="mobile-menu-item">最新</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a><a href="/catalog/">
        <li class="mobile-menu-item">完整目录</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">迭代自己</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/recent/">最新</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/catalog/">完整目录</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">03 字典和集合</h1>

      <div class="post-meta">
        <span class="post-time"> 2018-06-26 </span>
        
        <span class="more-meta"> 21294 words </span>
        <span class="more-meta"> 43 mins read </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> times read </span>
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  
  <div class="post-toc-content">
    <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#第-3-章-字典和集合">第 3 章 字典和集合</a>
<ul>
<li><a href="#3-1-泛映射类型">3.1 泛映射类型</a></li>
<li><a href="#3-2-字典推导">3.2 字典推导</a></li>
<li><a href="#3-3-常见的映射方法">3.3 常见的映射方法</a>
<ul>
<li><a href="#❶-提取-word-出现的情况-如果还没有它的记录-返回">❶ 提取 word 出现的情况，如果还没有它的记录，返回 []。</a></li>
<li><a href="#❷-把单词新出现的位置添加到列表的后面">❷ 把单词新出现的位置添加到列表的后面。</a></li>
<li><a href="#❸-把新的列表放回字典中-这又牵扯到一次查询操作">❸ 把新的列表放回字典中，这又牵扯到一次查询操作。</a></li>
<li><a href="#❹sorted函数的key-参数没有调用str-uppper-而是把这个方法的引用传递给">❹sorted函数的key=参数没有调用str.uppper，而是把这个方法的引用传递给</a></li>
<li><a href="#示例-3-3-这里是示例3-2-的不完全输出-每一行的列表都代表一个单词的出现情-况-列表中的元素是一对值-第一个值表示出现的行-第二个表示出现的列">示例 3-3 这里是示例3-2 的不完全输出，每一行的列表都代表一个单词的出现情 况，列表中的元素是一对值，第一个值表示出现的行，第二个表示出现的列</a></li>
<li><a href="#示例-3-2-里处理单词出现情况的三行-通过-dict-setdefault-可以只用一行解决-示例">示例 3-2 里处理单词出现情况的三行，通过 dict.setdefault 可以只用一行解决。示例</a></li>
<li><a href="#3-4-更接近-alex-martelli-自己举的例子">3-4 更接近 Alex Martelli 自己举的例子。</a></li>
<li><a href="#o-获取单词的出现情况列表-如果单词不存在-把单词和一个空列表放进映射-然后返-回这个空列表-这样就能在不进行第二次查找的情况下更新列表了">O 获取单词的出现情况列表，如果单词不存在，把单词和一个空列表放进映射，然后返 回这个空列表，这样就能在不进行第二次查找的情况下更新列表了。</a></li>
<li><a href="#也就是说-这样写">也就是说，这样写：</a></li>
</ul></li>
<li><a href="#3-4-映射的弹性键查询">3.4 映射的弹性键查询</a>
<ul>
<li><a href="#示例-3-7-则实现了上面例子里的-strkeydict0-类">示例 3-7 则实现了上面例子里的 StrKeyDict0 类。</a></li>
<li><a href="#如果要自定义一个映射类型-更合适的策略其实是继承-collections-userdict-类-示例-3-8-就是如此-这里我们从-dict-继承-只是为">如果要自定义一个映射类型，更合适的策略其实是继承 collections.UserDict 类（示例 3-8 就是如此）。这里我们从 dict 继承，只是为</a></li>
</ul></li>
<li><a href="#3-5-字典的变种">3.5 字典的变种</a></li>
<li><a href="#3-6-子类化-userdict">3.6 子类化 UserDict</a></li>
<li><a href="#3-7-不可变映射类型">3.7 不可变映射类型</a></li>
<li><a href="#3-8集合论">3.8集合论</a>
<ul>
<li><a href="#除了跟数学上的集合计算有关的方法和运算符-集合类型还有一些为了实用性而添加的方-法-其汇总见于表-3-4">除了跟数学上的集合计算有关的方法和运算符，集合类型还有一些为了实用性而添加的方 法，其汇总见于表 3-4。</a></li>
<li><a href="#到这里-我们差不多把集合类型的特性总结完了">到这里，我们差不多把集合类型的特性总结完了。</a></li>
</ul></li>
<li><a href="#3-9-diet和set的背后">3.9 diet和set的背后</a></li>
<li><a href="#3-10-本章小结">3.10 本章小结</a></li>
<li><a href="#3-11-延伸阅读">3.11 延伸阅读</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
  </div>
</div>

    
    

    
    <div class="post-content">
      

<h2 id="第-3-章-字典和集合">第 3 章 字典和集合</h2>

<p>字典这个数据结构活跃在所有 Python 程序的背后，即便你的源码里并没有直接用到 它。</p>

<p>——A. M. Kuchling</p>

<p>《代码之美》第18章“Python的字典类：如何打造全能战士”</p>

<p>dict 类型不但在各种程序里广泛使用，它也是 Python 语言的基石。模块的命名空间、实 例的属性和函数的关键字参数中都可以看到字典的身影。跟它有关的内置函数都在 <strong>builtins</strong>.<strong>dict</strong>模块中。</p>

<p>正是因为字典至关重要， Python 对它的实现做了高度优化，而散列表则是字典类型性能</p>

<p>出众的根本原因。</p>

<p>集合(set)的实现其实也依赖于散列表，因此本章也会讲到它。反过来说，想要进一步 理解集合和字典，就得先理解散列表的原理。</p>

<p>本章内容的大纲如下：</p>

<p>•常见的字典方法 •如何处理查找不到的键 •标准库中dict类型的变种 • set 和 frozenset 类型 •散列表的工作原理</p>

<p>•散列表带来的潜在影响(什么样的数据类型可作为键、不可预知的顺序，等等)</p>

<h3 id="3-1-泛映射类型">3.1 泛映射类型</h3>

<p>collections.abc 模块中有 Mapping 和 MutableMapping 这两个抽象基类，它们的作 用是为 dict 和其他类似的类型定义形式接口(在 Python 2.6 到 Python 3.2 的版本中，这些 类还不属于 collections.abc 模块，而是隶属于 collections 模块)。详见图 3-1。</p>

<p>图 3-1：collections.abc 中的 MutableMapping 和它的超类的 UML 类图(箭头从子 类指向超类，抽象类和抽象方法的名称以斜体显示) 然而，非抽象映射类型一般不会直接继承这些抽象基类，它们会直接对 dict 或是</p>

<p>collections.User.Dict 进行扩展。这些抽象基类的主要作用是作为形式化的文档，它 们定义了构建一个映射类型所需要的最基本的接口。然后它们还可以跟 isinstance 一起</p>

<p>被用来判定某个数据是不是广义上的映射类型：</p>

<p>&gt;&gt;&gt; my_dict = {}</p>

<p>&gt;&gt;&gt; isinstance(my_dict, abc.Mapping) True</p>

<p>这里用 isinstance 而不是 type 来检查某个参数是否为 dict 类型，因为这个参数有可 能不是diet，而是一个比较另类的映射类型。</p>

<p>标准库里的所有映射类型都是利用 dict 来实现的，因此它们有个共同的限制，即只有可</p>

<p>散列的数据类型才能用作这些映射里的键(只有键有这个要求，值并不需要是可散列的</p>

<p>数据类型)。</p>

<p>什么是可散列的数据类型</p>

<p>在 Python 词汇表(<a href="https://docs.python.org/3/glossary.html%23term-hashable">https://docs.python+org/3/glossary+html#term-hashable</a>)中，关于可散</p>

<p>列类型的定义有这样一段话：</p>

<p>如果一个对象是可散列的，那么在这个对象的生命周期中，它的散列值是不变</p>

<p>的，而且这个对象需要实现 <strong>hash</strong>() 方法。另外可散列对象还要有</p>

<p><strong>qe</strong>() 方法，这样才能跟其他键做比较。如果两个可散列对象是相等的，那 么它们的散列值一定是一样的</p>

<p>原子不可变数据类型(str、bytes和数值类型)都是可散列类型，frozenset也是 可散列的，因为根据其定义， frozenset 里只能容纳可散列类型。元组的话，只有 当一个元组包含的所有元素都是可散列类型的情况下，它才是可散列的。来看下面的</p>

<p>元组tt、tl和tf:</p>

<p>&gt;&gt;&gt; tt = (1, 2, (30, 40))</p>

<p>&gt;&gt;&gt; hash(tt)</p>

<p>8027212646858338501 &gt;&gt;&gt; tl = (1, 2, [30, 40])</p>

<p>&gt;&gt;&gt; hash(tl)</p>

<p>Traceback (most recent call last): File &ldquo;<stdin>&rdquo;, line 1, in <module></p>

<p>TypeError: unhashable type: &lsquo;list&rsquo; &gt;&gt;&gt; tf = (1, 2, frozenset([30, 40]))</p>

<p>&gt;&gt;&gt; hash(tf)</p>

<p>-4118419923444501110</p>

<p>直到我写这本书的时候，Python词汇表</p>

<p>(<a href="https://docs.python.org/3/glossary.html%23term-hashable">https://docs.python.Org/3/glossary.html#term-hashable</a>)里还在说“Python 里所有的不可</p>

<p>变类型都是可散列的”。这个说法其实是不准确的，比如虽然元组本身是不可变序</p>

<p>列，它里面的元素可能是其他可变类型的引用。</p>

<p>一般来讲用户自定义的类型的对象都是可散列的，散列值就是它们的 id() 函数的返 回值，所以所有这些对象在比较的时候都是不相等的。如果一个对象实现了 <strong>eq</strong> 方法，并且在方法中用到了这个对象的内部状态的话，那么只有当所有这些内部状态 都是不可变的情况下，这个对象才是可散列的。</p>

<p>根据这些定义，字典提供了很多种构造方法， “Built-in</p>

<p>Types” (<a href="https://docs.python.org/3/library/stdtypes.html%23mapping-types-dict">https://docs.python.org/3/library/stdtypes.html#mapping-types-dict</a>)这个页面上有个</p>

<p>例子来说明创建字典的不同方式：</p>

<p>&gt;&gt;&gt; a = dict(one=1, two=2, three=3)</p>

<p>&gt;&gt;&gt; b = {&lsquo;one&rsquo;: 1, &lsquo;two&rsquo;: 2, &lsquo;three&rsquo;: 3}</p>

<p>&gt;&gt;&gt; c = dict(zip([&lsquo;one&rsquo;, &lsquo;two&rsquo;, &lsquo;three&rsquo;], [1, 2, 3])) &gt;&gt;&gt; d = dict([(&lsquo;two&rsquo;, 2), (&lsquo;one&rsquo;, 1), (&lsquo;three&rsquo;, 3)]) &gt;&gt;&gt; e = dict({&lsquo;three&rsquo;: 3, &lsquo;one&rsquo;: 1, &lsquo;two&rsquo;: 2})</p>

<p>&gt;&gt;&gt; a == b == c == d == e True</p>

<p>除了这些字面句法和灵活的构造方法之外，字典推导(diet comprehension)也可以用来建 造新dict，详见下一节。</p>

<h3 id="3-2-字典推导">3.2 字典推导</h3>

<p>自 Python 2.7 以来，列表推导和生成器表达式的概念就移植到了字典上，从而有了字典推 导（后面还会看到集合推导）。字典推导（dictcomp）可以从任何以键值对作为元素的可 迭代对象中构建出字典。示例 3-1 就展示了利用字典推导可以把一个装满元组的列表变成 两个不同的字典。</p>

<p>示例 3-1 字典推导的应用</p>

<p>&gt;&gt;&gt; DIAL_CODES =</p>

<p>(86,</p>

<p>(91,</p>

<p>(1,</p>

<p>(62,</p>

<p>(55,</p>

<p>(92,</p>

<p>(880,</p>

<p>(234,</p>

<p>(7,</p>

<p>(81,</p>

<p>]</p>

<p>&gt;&gt;&gt; country_code &gt;&gt;&gt; country_code</p>

<p>&lsquo;China&rsquo;), &lsquo;India&rsquo;), &lsquo;United States &lsquo;Indonesia&rsquo;), &lsquo;Brazil&rsquo;), &lsquo;Pakistan&rsquo;), &lsquo;Bangladesh&rsquo; &lsquo;Nigeria&rsquo;), &lsquo;Russia&rsquo;), &lsquo;Japan&rsquo;),</p>

<p>),</p>

<p>),</p>

<p>{country: code for code, country in DIAL_CODES} ©</p>

<p>{&lsquo;China&rsquo;: 86, &lsquo;India&rsquo;: 91, &lsquo;Bangladesh&rsquo;: 880, &lsquo;United States&rsquo;: 1, &lsquo;Pakistan&rsquo;: 92, &lsquo;Japan&rsquo;: 81, &lsquo;Russia&rsquo;: 7, &lsquo;Brazil&rsquo;: 55, &lsquo;Nigeria&rsquo;:</p>

<p>234, &lsquo;Indonesia&rsquo;: 62}</p>

<p>&gt;&gt;&gt; {code: country.upper() for country, code in country_code.items()    ©</p>

<p>&hellip; if code &lt; 66}</p>

<p>{1: &lsquo;UNITED STATES&rsquo;, 55: &lsquo;BRAZIL&rsquo;, 62: &lsquo;INDONESIA&rsquo;, 7: &lsquo;RUSSIA&rsquo;}</p>

<p>❶ 一个承载成对数据的列表，它可以直接用在字典的构造方法中。</p>

<p>❷ 这里把配好对的数据左右换了下，国家名是键，区域码是值。</p>

<p>❸ 跟上面相反，用区域码作为键，国家名称转换为大写，并且过滤掉区域码大于或等于</p>

<p>66 的地区。</p>

<p>如果列表推导的概念已经为你所熟知，接受字典推导应该不难。如果你对列表推导还不 熟，那么是时候来掌握它了，因为字典推导的表达形式会蔓延到其他数据类型中。 下面来看看映射类型提供的 API 的全景图。</p>

<h3 id="3-3-常见的映射方法">3.3 常见的映射方法</h3>

<p>映射类型的方法其实很丰富。表 3-1 为我们展示了 dict、defaultdict 和 OrderedDict 的常见方法，后面两个数据类型是 dict 的变种，位于 collections 模块内。</p>

<p>表3-1： diet、collections.defaultdict和collections.OrderedDict这三种映射 类型的方法列表（依然省略了继承自object的常见方法）；可选参数以［&hellip;］表示</p>

<table>
<thead>
<tr>
<th></th>
<th>dict</th>
<th>defaultdict</th>
<th>OrderedDict</th>
<th></th>
</tr>
</thead>

<tbody>
<tr>
<td>d.clear()</td>
<td>•</td>
<td>•</td>
<td>•</td>
<td>移除所有元素</td>
</tr>

<tr>
<td>d.<strong>contains</strong>(k)</td>
<td>•</td>
<td>•</td>
<td>•</td>
<td>检查k是否在d中</td>
</tr>

<tr>
<td>d.copy()</td>
<td>•</td>
<td>•</td>
<td>•</td>
<td>浅复制</td>
</tr>

<tr>
<td>d.<strong>copy</strong>()</td>
<td></td>
<td>•</td>
<td></td>
<td>用于支持 copy.copy</td>
</tr>

<tr>
<td>d.default_factory</td>
<td></td>
<td>•</td>
<td></td>
<td>在 <strong>missing</strong> 函数中被调用的函数，用以给未找到的 元素设置值*</td>
</tr>

<tr>
<td>d.<strong>delitem</strong>(k)</td>
<td>•</td>
<td>•</td>
<td>•</td>
<td>del d［k］，移除键为k的元素</td>
</tr>

<tr>
<td>d.fromkeys(it,[initial])</td>
<td>•</td>
<td>•</td>
<td>•</td>
<td>将迭代器 it 里的元素设置为映射里的键，如果有 initial 参数，就把它作为这些键对应的值（默认是 None）</td>
</tr>

<tr>
<td>d.get(k,[default])</td>
<td>•</td>
<td>•</td>
<td>•</td>
<td>返回键k对应的值，如果字典里没有键k，则返回None或者 default</td>
</tr>

<tr>
<td>d.<strong>getitem</strong>(k)</td>
<td>•</td>
<td>•</td>
<td>•</td>
<td>让字典d能用d［k］的形式返回键k对应的值</td>
</tr>

<tr>
<td>d.items()</td>
<td>•</td>
<td>•</td>
<td>•</td>
<td>返回d里所有的键值对</td>
</tr>

<tr>
<td>d.<strong>iter</strong>()</td>
<td>•</td>
<td>•</td>
<td>•</td>
<td>获取键的迭代器</td>
</tr>

<tr>
<td>d.keys()</td>
<td>•</td>
<td>•</td>
<td>•</td>
<td>获取所有的键</td>
</tr>

<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

<table>
<thead>
<tr>
<th>d.<strong>len</strong>()</th>
<th>•</th>
<th>•</th>
<th>•</th>
<th>可以用 len(d) 的形式得到字典里键值对的数量</th>
</tr>
</thead>

<tbody>
<tr>
<td>d.<strong>missing</strong>(k)</td>
<td></td>
<td>•</td>
<td></td>
<td>当 <strong>getitem</strong> 找不到对应键的时候，这个方法会被调用</td>
</tr>

<tr>
<td>d.move_to_end(k,[last])</td>
<td></td>
<td></td>
<td>•</td>
<td>把键为k的元素移动到最靠前或者最靠后的位置(last 的默认值是 True)</td>
</tr>

<tr>
<td>d.pop(k, [defaul]</td>
<td>•</td>
<td>•</td>
<td>•</td>
<td>返回键 k 所对应的值，然后移除这个键值对。如果没 有这个键，返回 None 或者 defaul</td>
</tr>

<tr>
<td>d.popitem()</td>
<td>•</td>
<td>•</td>
<td>•</td>
<td>随机返回一个键值对并从字典里移除它#</td>
</tr>

<tr>
<td>d.<strong>reversed</strong>()</td>
<td></td>
<td></td>
<td>•</td>
<td>返回倒序的键的迭代器</td>
</tr>

<tr>
<td>d.s etdefault(k, [default])</td>
<td>•</td>
<td>•</td>
<td>•</td>
<td>若字典里有键k，则把它对应的值设置为default，然 后返回这个值；若无，则让d[k] = default，然后返回 default</td>
</tr>

<tr>
<td>d.<strong>setitem</strong>(k, v)</td>
<td>•</td>
<td>•</td>
<td>•</td>
<td>实现d[k] = v操作，把k对应的值设为V</td>
</tr>

<tr>
<td>d.update(m,[**kargs])</td>
<td>•</td>
<td>•</td>
<td>•</td>
<td>m 可以是映射或者键值对迭代器，用来更新 d 里对应的条目</td>
</tr>

<tr>
<td>d.value s()</td>
<td>•</td>
<td>•</td>
<td>•</td>
<td>返回字典里的所有值</td>
</tr>
</tbody>
</table>

<p>*    default_factory并不是一个方法，而是一个可调用对象(callable)，它的值在defaultdict初始化的时候由用户</p>

<p>设定。</p>

<p>#    OrderedDict.popitem() 会移除字典里最先插入的元素(先进先出)；同时这个方法还有一个可选的 last 参数，若 为真，则会移除最后插入的元素(后进先出)。</p>

<p>上面的表格中， update 方法处理参数 m 的方式，是典型的“鸭子类型”。函数首先检查 m 是否有 keys 方法，如果有，那么 update 函数就把它当作映射对象来处理。否则，函数 会退一步，转而把 m 当作包含了键值对 (key, value) 元素的迭代器。 Python 里大多数 映射类型的构造方法都采用了类似的逻辑，因此你既可以用一个映射对象来新建一个映射</p>

<p>对象，也可以用包含 (key, value) 元素的可迭代对象来初始化一个映射对象。</p>

<p>在映射对象的方法里， setdefault 可能是比较微妙的一个。我们虽然并不会每次都用</p>

<p>它，但是一旦它发挥作用，就可以节省不少次键查询，从而让程序更高效。如果你对它还</p>

<p>不熟悉，下面我会通过一个实例来讲解它的用法。</p>

<p>用setdefault处理找不到的键</p>

<p>当字典 d[k] 不能找到正确的键的时候， Python 会抛出异常，这个行为符合 Python 所信奉 的“快速失败”哲学。也许每个 Python 程序员都知道可以用 d.get（k, default） 来代替 d[k]，给找不到的键一个默认的返回值（这比处理KeyError要方便不少）。但是要更 新某个键对应的值的时候，不管使用 <strong>getitem</strong> 还是 get 都会不自然，而且效率低。 就像示例 3-2 中的还没有经过优化的代码所显示的那样， dict.get 并不是处理找不到的 键的最好方法。</p>

<p>示例 3-2 是由 Alex Martelli 举的一个例子 1 变化而来，例子生成的索引跟示例 3-3 显示的 一样。</p>

<p>1示例代码出现在Martelli的演讲“Re-learning python”中（第41张幻灯</p>

<p>片，<a href="http://www.aleax.it/Python/accu04_Relearn_Python_alex.pdf">http://www.aleax.it/Python/accu04_Releam_Python_alex.pdf</a>），他的代码被我放在了示例 3-4 中，代码很好地展示了</p>

<p>dict.setdefault 的用法。</p>

<p>示例 3-2 index0.py 这段程序从索引中获取单词出现的频率信息，并把它们写进对 应的列表里（更好的解决方案在示例 3-4 中）</p>

<h4 id="❶-提取-word-出现的情况-如果还没有它的记录-返回">❶ 提取 word 出现的情况，如果还没有它的记录，返回 []。</h4>

<h4 id="❷-把单词新出现的位置添加到列表的后面">❷ 把单词新出现的位置添加到列表的后面。</h4>

<h4 id="❸-把新的列表放回字典中-这又牵扯到一次查询操作">❸ 把新的列表放回字典中，这又牵扯到一次查询操作。</h4>

<h4 id="❹sorted函数的key-参数没有调用str-uppper-而是把这个方法的引用传递给">❹sorted函数的key=参数没有调用str.uppper，而是把这个方法的引用传递给</h4>

<p>sorted 函数，这样在排序的时候，单词会被规范成统一格式。 2</p>

<p>| 2这是将方法用作一等函数的一个示例，第5章会谈到这一点。</p>

<h4 id="示例-3-3-这里是示例3-2-的不完全输出-每一行的列表都代表一个单词的出现情-况-列表中的元素是一对值-第一个值表示出现的行-第二个表示出现的列">示例 3-3 这里是示例3-2 的不完全输出，每一行的列表都代表一个单词的出现情 况，列表中的元素是一对值，第一个值表示出现的行，第二个表示出现的列</h4>

<p>$ python3 index0.py ../../data/zen.txt a [(19, 48), (20, 53)]</p>

<p>Although [(11, 1), (16, 1), (18, 1)]</p>

<p>ambiguity [(14, 16)]</p>

<p>and [(15, 23)]</p>

<p>are [(21, 12)]</p>

<p>aren [(10, 15)]</p>

<p>at [(16, 38)]</p>

<p>bad [(19, 50)]</p>

<p>be [(15, 14), (16, 27), (20, 50)] beats [(11, 23)]</p>

<p>Beautiful [(3, 1)]</p>

<p>better [(3, 14), (4, 13), (5, 11), (6, 12), (7, 9), (8, 11), (17, 8), (18, 25)]</p>

<h4 id="示例-3-2-里处理单词出现情况的三行-通过-dict-setdefault-可以只用一行解决-示例">示例 3-2 里处理单词出现情况的三行，通过 dict.setdefault 可以只用一行解决。示例</h4>

<h4 id="3-4-更接近-alex-martelli-自己举的例子">3-4 更接近 Alex Martelli 自己举的例子。</h4>

<p>示例 3-4 index.py 用一行就解决了获取和更新单词的出现情况列表，当然跟示例 3-2 不一样的是，这里用到了 dict.setdefault</p>

<p>&rdquo;&ldquo;&ldquo;创建从一个单词到其出现情况的映射&rdquo;&ldquo;&rdquo;</p>

<p>import sys import re</p>

<p>WORD_RE = re.compile(r&rsquo;\w+&lsquo;) index = {}</p>

<p>with open(sys.argv[1], encoding=&lsquo;utf-8&rsquo;) as fp: for line_no, line in enumerate(fp, 1): for match in WORD_RE.finditer(line): word = match.group() column_no = match.start()+1 location = (line_no, column_no)</p>

<p>index.setdefault(word, []).append(location) O</p>

<p># 以字母顺序打印出结果</p>

<p>for word in sorted(index, key=str.upper): print(word, index[word])</p>

<h4 id="o-获取单词的出现情况列表-如果单词不存在-把单词和一个空列表放进映射-然后返-回这个空列表-这样就能在不进行第二次查找的情况下更新列表了">O 获取单词的出现情况列表，如果单词不存在，把单词和一个空列表放进映射，然后返 回这个空列表，这样就能在不进行第二次查找的情况下更新列表了。</h4>

<h4 id="也就是说-这样写">也就是说，这样写：</h4>

<p>my_dict.setdefault(key, []).append(new_value)</p>

<p>跟这样写：</p>

<p>if key not in my_dict: my_dict[key] = []</p>

<p>my_dict[key].append(new_value)</p>

<p>二者的效果是一样的，只不过后者至少要进行两次键查询——如果键不存在的话，就是三</p>

<p>次，用 setdefault 只需要一次就可以完成整个操作。</p>

<p>那么，在单纯地查找取值（而不是通过查找来插入新值）的时候，该怎么处理找不到的键</p>

<p>呢？</p>

<h3 id="3-4-映射的弹性键查询">3.4 映射的弹性键查询</h3>

<p>有时候为了方便起见，就算某个键在映射里不存在，我们也希望在通过这个键读取值的时 候能得到一个默认值。有两个途径能帮我们达到这个目的，一个是通过 defaultdict 这 个类型而不是普通的diet，另一个是给自己定义一个diet的子类，然后在子类中实现 <strong>missing</strong> 方法。下面将介绍这两种方法。</p>

<p>3.4.1 defaultdict：处理找不到的键的一个选择</p>

<p>示例 3-5 在 eolleetions.defaultdiet 的帮助下优雅地解决了示例 3-4 里的问题。在用 户创建 defaultdiet 对象的时候，就需要给它配置一个为找不到的键创造默认值的方 法。</p>

<p>具体而言，在实例化一个 defaultdiet 的时候，需要给构造方法提供一个可调用对象，</p>

<p>这个可调用对象会在 <strong>getitem</strong> 碰到找不到的键的时候被调用，让 <strong>getitem</strong> 返 回某种默认值。</p>

<p>比如，我们新建了这样一个字典：dd = defaultdiet(list)，如果键’new-key•在dd</p>

<p>中还不存在的话，表达式 dd[&lsquo;new-key&rsquo;] 会按照以下的步骤来行事。</p>

<p>(1)    调用 list() 来建立一个新列表。</p>

<p>(2)    把这个新列表作为值，’new-key&rsquo;作为它的键，放到dd中。</p>

<p>(3)    返回这个列表的引用。</p>

<p>而这个用来生成默认值的可调用对象存放在名为 default_faetory 的实例属性里。</p>

<p>示例 3-5 index_default.py：利用 defaultdiet 实例而不是 setdefault 方法</p>

<p>&rdquo;&ldquo;&ldquo;创建一个从单词到其出现情况的映射&rdquo;&ldquo;&rdquo;</p>

<p>import sys</p>

<p>import re</p>

<p>import eolleetions</p>

<p>WORD_RE = re.eompile(r’\w+’)</p>

<p>index = eolleetions.defaultdiet(list) O with open(sys.argv[1], eneoding=’utf-8’) as fp:</p>

<p>for line_no, line in enumerate(fp, 1):</p>

<p>for mateh in WORD_RE.finditer(line):</p>

<p>word = mateh.group()</p>

<p>eolumn_no = mateh.start()+1 loeation = (line_no, eolumn_no)</p>

<p>index[word].append(loeation) &amp;</p>

<p>for word in sorted(index, key=str.upper): print(word, index[word])</p>

<p>O 把 list 构造方法作为 default_factory 来创建一个 defaultdict。</p>

<p>© 如果 index 并没有 word 的记录，那么 default_factory 会被调用，为查询不到的键 创造一个值。这个值在这里是一个空的列表，然后这个空列表被赋值给 index[word]， 继而被当作返回值返回，因此 .append(location) 操作总能成功。</p>

<p>如果在创建defaultdict的时候没有指定default_factory，查询不存在的键会触发 KeyError。</p>

<p>defaultdict 里的 default_factory 只会在 <strong>getitem</strong> 里被调用，在 其他的方法里完全不会发挥作用。比如， dd 是个 defaultdict， k 是个找不到的 键， dd[k] 这个表达式会调用 default_factory 创造某个默认值，而 dd.get(k) 则会返回 None。</p>

<p>所有这一切背后的功臣其实是特殊方法 <strong>missing</strong>。它会在 defaultdict 遇到找不到 的键的时候调用default_factory，而实际上这个特性是所有映射类型都可以选择去支 持的。</p>

<p>3.4.2 特殊方法<strong>missing</strong></p>

<p>所有的映射类型在处理找不到的键的时候，都会牵扯到 <strong>missing</strong> 方法。这也是这个 方法称作“missing”的原因。虽然基类dict并没有定义这个方法，但是dict是知道有这 么个东西存在的。也就是说，如果有一个类继承了 dict，然后这个继承类提供了 <strong>missing</strong> 方法，那么在 <strong>getitem</strong> 碰到找不到的键的时候， Python 就会自动调用 它，而不是抛出一个 KeyError 异常。</p>

<p><strong>missing</strong>方法只会被<strong>getitem</strong>调用(比如在表达式d[k]中)。</p>

<p>提供 <strong>missing</strong> 方法对 get 或者 <strong>contains</strong>(in 运算符会用到这个方法)这 些方法的使用没有影响。这也是我在上一节最后的警告中提到， defaultdict 中的 default_factory 只对 <strong>getitem</strong> 有作用的原因。</p>

<p>有时候，你会希望在查询的时候，映射类型里的键统统转换成str。为可编程电路板(像 Raspberry Pi 或 Arduino3)准备的 Pingo.io (<a href="http://www.pingo.io/docs/">http://www.pingo.io/docs/</a>)项目里就有具体的 例子。在 Pingo.io 里，电路板上的 GPIO 针脚 4 以 board.pins 为名，封装在名为 board 的对象里。 board.pins 是一个映射类型，其中键是针脚的物理位置，它可能只是一个数 字或字符串，比如&rdquo;A0&rdquo;或&rdquo;P9_12&rdquo;;值则是针脚连接的东西。为了保持一致性，我们希 望 board.pins 的键只能是字符串，但是为了方便查询， my_arduino.pins[13] 也是可 行的，这样可以帮 Arduino 的初级玩家快速找到第 13 个针脚上的 LED 灯。示例 3-6 展示 了这样的一个映射是怎么运行的。</p>

<p>3Raspberry Pi是一个集成到巴掌大小的板子上的电脑。Ardumo则是一种可以在烧录程序的同时，连接上各种传感器，</p>

<p>用以跟物理世界交互的电路板。更多的相关信息可以在 <a href="https://www.raspberrypi.org/">https://www.raspberrypi.org/</a> 和 <a href="https://www.arduino.cc/">https://www.arduino.cc/</a> 上找到。 ——译者注</p>

<p>4通用输入输出针脚，用来跟传感器或其他设备用数据互动。一译者注</p>

<p>示例 3-6 当有非字符串的键被查找的时候， StrKeyDict0 是如何在该键不存在的情 况下，把它转换为字符串的</p>

<p>Tests for item retrieval using &rsquo;d[key]&rsquo; notation::</p>

<p>&gt;&gt;&gt; d = StrKeyDict0([(&lsquo;2&rsquo;, &lsquo;two&rsquo;), (&lsquo;4&rsquo;, &lsquo;four&rsquo;)]) &gt;&gt;&gt; d[&lsquo;2&rsquo;]</p>

<p>&lsquo;two&rsquo;</p>

<p>&gt;&gt;&gt; d[4]</p>

<p>&lsquo;four&rsquo;</p>

<p>&gt;&gt;&gt; d[1]</p>

<p>Traceback (most recent call last):</p>

<p>KeyError: &lsquo;1&rsquo;</p>

<p>Tests for item retrieval using &rsquo;d.get(key)&rsquo; notation::</p>

<p>&gt;&gt;&gt; d.get(&lsquo;2&rsquo;)</p>

<p>&lsquo;two&rsquo;</p>

<p>&gt;&gt;&gt; d.get(4)</p>

<p>&lsquo;four&rsquo;</p>

<p>&gt;&gt;&gt; d.get(1, &lsquo;N/A&rsquo;)</p>

<p>&lsquo;N/A&rsquo;</p>

<p>Tests for the &lsquo;in&rsquo; operator::</p>

<p>&gt;&gt;&gt; 2 in d</p>

<p>True</p>

<p>&gt;&gt;&gt; 1 in d</p>

<p>False</p>

<p>class StrKeyDictO(dict): O</p>

<p>def <strong>missing</strong>(self, key):</p>

<p>if isinstance(key, str): &amp;</p>

<p>raise KeyError(key)</p>

<p>return self[str(key)]    ©</p>

<h4 id="示例-3-7-则实现了上面例子里的-strkeydict0-类">示例 3-7 则实现了上面例子里的 StrKeyDict0 类。</h4>

<p><img src="08414584Python-19.jpg" alt="img" /></p>

<h4 id="如果要自定义一个映射类型-更合适的策略其实是继承-collections-userdict-类-示例-3-8-就是如此-这里我们从-dict-继承-只是为">如果要自定义一个映射类型，更合适的策略其实是继承 collections.UserDict 类（示例 3-8 就是如此）。这里我们从 dict 继承，只是为</h4>

<p>了演示 <strong>missing</strong> 是如何被 dict.<strong>getitem</strong> 调用的。</p>

<p>示例 3-7 StrKeyDict0 在查询的时候把非字符串的键转换为字符串</p>

<p>def get(self, key, default=None):</p>

<p>try:</p>

<p>return self[key] © exeept KeyError:</p>

<p>return default ❺</p>

<p>def <strong>eontains</strong>(self, key):</p>

<p>return key in self.keys() or str(key) in self.keys() ©</p>

<p>❶ StrKeyDiet0 继承了 diet。</p>

<p>❷ 如果找不到的键本身就是字符串，那就抛出 KeyError 异常。</p>

<p>❸ 如果找不到的键不是字符串，那么把它转换成字符串再进行查找。</p>

<p>❹ get 方法把查找工作用 self[key] 的形式委托给 <strong>getitem</strong>，这样在宣布查找失败</p>

<p>之前，还能通过 <strong>missing</strong> 再给某个键一个机会。</p>

<p>❺如果抛出KeyError，那么说明<strong>missing</strong>也失败了，于是返回default。</p>

<p>❻ 先按照传入键的原本的值来查找(我们的映射类型中可能含有非字符串的键)，如果</p>

<p>没找到，再用 str() 方法把键转换成字符串再查找一次。</p>

<p>下面来看看为什么 isinstanee(key, str) 测试在上面的 <strong>missing</strong> 中是必需的。</p>

<p>如果没有这个测试，只要 str(k) 返回的是一个存在的键，那么 <strong>missing</strong> 方法是没 问题的，不管是字符串键还是非字符串键，它都能正常运行。但是如果 str(k) 不是一个 存在的键，代码就会陷入无限递归。这是因为 <strong>missing</strong> 的最后一行中的 self[str(key)] 会调用 <strong>getitem</strong>，而这个 str(key) 又不存在，于是 <strong>missing</strong> 又会被调用。</p>

<p>为了保持一致性， <strong>eontains</strong> 方法在这里也是必需的。这是因为 k in d 这个操作会 调用它，但是我们从 diet 继承到的 <strong>eontains</strong> 方法不会在找不到键的时候调用 <strong>missing</strong> 方法。 <strong>eontains</strong> 里还有个细节，就是我们这里没有用更具 Python 风</p>

<p>格的方式-k in my_diet-来检查键是否存在，因为那也会导致<strong>eontains</strong>被</p>

<p>递归调用。为了避免这一情况，这里采取了更显式的方法，直接在这个 self.keys() 里 查询。</p>

<p>^像k in my_diet.keys()这种操作在Python 3中是很快的，而且即便映射类 型对象很庞大也没关系。这是因为 diet.keys() 的返回值是一个“视图”。视图就像 一个集合，而且跟字典类似的是，在视图里查找一个元素的速度很快。在“Dictionary view objects” (<a href="https://docs.python.org/3/library/stdtypes.html%23dictionary-view-objects">https://docs.python.Org/3/library/stdtypes.html#dictionary-view-objects</a>)里 可以找到关于这个细节的文档。 Python 2 的 diet.keys() 返回的是个列表，因此虽 然上面的方法仍然是正确的，它在处理体积大的对象的时候效率不会太高，因为 k in my_list 操作需要扫描整个列表。</p>

<p>出于对准确度的考虑，我们也需要这个按照键的原本的值来查找的操作(也就是 key in</p>

<p>self.keys())，因为在创建StrKeyDictO和为它添加新值的时候，我们并没有强制要</p>

<p>求传入的键必须是字符串。因为这个操作没有规定死键的类型，所以让查找操作变得更加</p>

<p>友好。</p>

<p>好了，我们已经见识过 dict 和 defaultdict 了。但是标准库里面还有很多其他的映射 类型，下面就来看看。</p>

<h3 id="3-5-字典的变种">3.5 字典的变种</h3>

<p>这一节总结了标准库里 collections 模块中，除了 defaultdict 之外的不同映射类</p>

<p>型。</p>

<p>collections.OrderedDict</p>

<p>这个类型在添加键的时候会保持顺序，因此键的迭代次序总是一致 的。 OrderedDict 的 popitem 方法默认删除并返回的是字典里的最后一个元素，但是如 果像 my_odict.popitem(last=False) 这样调用它，那么它删除并返回第一个被添加进 去的元素。</p>

<p>collections.ChainMap</p>

<p>该类型可以容纳数个不同的映射对象，然后在进行键查找操作的时候，这些对象会被 当作一个整体被逐个查找，直到键被找到为止。这个功能在给有嵌套作用域的语言做解释 器的时候很有用，可以用一个映射对象来代表一个作用域的上下文。在 collections 文</p>

<p>档介绍 ChainMap 对象的那一部分</p>

<p>(<a href="https://docs.python.org/3/library/collections.html%23collections.ChainMap">https://docs+python+org/3/library/collections+html#collections+ChainMap</a>)里有一些具体的使 用示例，其中包含了下面这个 Python 变量查询规则的代码片段：</p>

<p>import builtins</p>

<p>pylookup = ChainMap(locals(), globals(), vars(builtins))</p>

<p>collections.Counter</p>

<p>这个映射类型会给键准备一个整数计数器。每次更新一个键的时候都会增加这个计数 器。所以这个类型可以用来给可散列表对象计数，或者是当成多重集来用——多重集合就 是集合里的元素可以出现不止一次。 Counter 实现了 + 和 - 运算符用来合并记录，还有 像 most_common([n]) 这类很有用的方法。 most_common([n]) 会按照次序返回映射里 最常见的 n 个键和它们的计数，详情参阅文档</p>

<p>(<a href="https://docs.python.org/3/library/collections.html%23collections.Counter">https://docs.python.org/3/library/collections.html#collections.Counter</a>) 。下面的小例子利用 Counter 来计算单词中各个字母出现的次数：</p>

<p>&gt;&gt;&gt; ct = collections.Counter(&lsquo;abracadabra&rsquo;)</p>

<p>&gt;&gt;&gt; ct</p>

<p>Counter({&lsquo;a&rsquo;: 5, &lsquo;b&rsquo;: 2, &lsquo;r&rsquo;: 2, &lsquo;c&rsquo;: 1, &rsquo;d&rsquo;: 1})</p>

<p>&gt;&gt;&gt; ct.update(&lsquo;aaaaazzz&rsquo;)</p>

<p>&gt;&gt;&gt; ct</p>

<p>Counter({&lsquo;a&rsquo;: 10, &lsquo;z&rsquo;: 3, &lsquo;b&rsquo;: 2, &lsquo;r&rsquo;: 2, &lsquo;c&rsquo;: 1, &rsquo;d&rsquo;: 1})</p>

<p>&gt;&gt;&gt; ct.most_common(2)</p>

<p>[(&lsquo;a&rsquo;, 10), (&lsquo;z&rsquo;, 3)]</p>

<p>colllections.UserDict</p>

<p>这个类其实就是把标准 dict 用纯 Python 又实现了一遍。</p>

<p>跟 OrderedDict、ChainMap 和 Counter 这些开箱即用的类型不同， UserDict 是让用户 继承写子类的。下面就来试试。</p>

<h3 id="3-6-子类化-userdict">3.6 子类化 UserDict</h3>

<p>就创造自定义映射类型来说，以 UserDict 为基类，总比以普通的 dict 为基类要来得方 便。</p>

<p>这体现在，我们能够改进示例 3-7 中定义的 StrKeyDict0 类，使得所有的键都存储为字 符串类型。</p>

<p>而更倾向于从 UserDict 而不是从 dict 继承的主要原因是，后者有时会在某些方法的实 现上走一些捷径，导致我们不得不在它的子类中重写这些方法，但是 UserDict 就不会带 来这些问题。5</p>

<p>5关于从diet或者其他内置类继承到底有什么不好，详见12.1节。</p>

<p>另外一个值得注意的地方是，UserDict并不是diet的子类，但是UserDict有一个叫</p>

<p>作 data 的属性，是 dict 的实例，这个属性实际上是 UserDict 最终存储数据的地方。 这样做的好处是，比起示例 3-7， UserDict 的子类就能在实现 <strong>setitem</strong> 的时候避免 不必要的递归，也可以让 <strong>contains</strong> 里的代码更简洁。</p>

<p>多亏了 UserDict，示例3-8里的StrKeyDict的代码比示例3-7里的StrKeyDictO要短</p>

<p>一些，功能却更完善：它不但把所有的键都以字符串的形式存储，还能处理一些创建或者</p>

<p>更新实例时包含非字符串类型的键这类意外情况。</p>

<p>示例3-8无论是添加、更新还是查询操作，StrKeyDict都会把非字符串的键转换</p>

<p>为字符串</p>

<p>import collections</p>

<p>class StrKeyDict(collections.UserDict): O</p>

<p>def <strong>missing</strong>(self, key): © if isinstance(key, str):</p>

<p>raise KeyError(key) return self[str(key)]</p>

<p>def <strong>contains</strong>(self, key):</p>

<p>return str(key) in self.data ©</p>

<p>def <strong>setitem</strong>(self, key, item): self.data[str(key)] = item ©</p>

<p>❶ StrKeyDict 是对 UserDict 的扩展。</p>

<p>❷ <strong>missing</strong> 跟示例 3-7 里的一模一样。</p>

<p>❸ <strong>contains</strong> 则更简洁些。这里可以放心假设所有已经存储的键都是字符串。因 此，只要在 self.data 上查询就好了，并不需要像 StrKeyDict0 那样去麻烦</p>

<p>self.keys()。</p>

<p>❹ <strong>setitem</strong> 会把所有的键都转换成字符串。由于把具体的实现委托给了 self.data 属性，这个方法写起来也不难。</p>

<p>因为UserDiet继承的是MutableMapping，所以StrKeyDiet里剩下的那些映射类型的 方法都是从 UserDiet、MutableMapping 和 Mapping 这些超类继承而来的。特别是最后 的Mapping类，它虽然是一个抽象基类(ABC)，但它却提供了好几个实用的方法。以 下两个方法值得关注。</p>

<p>MutableMapping.update</p>

<p>这个方法不但可以为我们所直接利用，它还用在 <strong>init</strong> 里，让构造方法可以利用 传入的各种参数(其他映射类型、元素是 (key, value) 对的可迭代对象和键值参数) 来新建实例。因为这个方法在背后是用 self[key] = value 来添加新值的，所以它其实 是在使用我们的 <strong>setitem</strong> 方法。</p>

<p>Mapping.get</p>

<p>在StrKeyDietO (示例3-7)中，我们不得不改写get方法，好让它的表现跟 <strong>getitem</strong> 一致。而在示例 3-8 中就没这个必要了，因为它继承了 Mapping.get 方 法，而 Python 的源码(<a href="https://hg.python.org/cpython/file/3.4/Lib/_collections_abc.py%23l422">https://hg+python+org/cpython/file/3.4/Lib/_collections_abc.py#1422</a>)显 示，这个方法的实现方式跟 StrKeyDiet0.get 是一模一样的。</p>

<p>在写完StrKeyDiet这个类之后，我读到了 Antonie Pitrou写的“PEP 455 — Adding a key-transforming dictionary to</p>

<p>collections” (<a href="https://www.python.org/dev/peps/pep-0455/">https://www.python.org/dev/peps/pep-0455/</a>) 。文章附带的补丁里包含了 一个叫作 TransformDiet 的新类型。这个补丁通过 issue</p>

<p>18986 (<a href="http://bugs.python.org/issue18986">http://bugs.python.org/issue18986</a>)被吸收进了 Python 3.5。为了试试这个类，</p>

<p>我把它提取出来放进了一个单独的模块(在本书代码仓库中：03-dict-<a href="https://github.com/fluentpython/example-code/blob/master/03-dict-set/transformdict.py">set/transformdict.py</a><a href="https://github.com/fluentpython/example-code/blob/master/03-dict-set/transformdict.py">， https://github.com/fluentpython/example-code/blob/master/03-dict-</a>set/transformdict.py)。比起 StrKeyDiet，TransformDiet 的通用性更强，也更复</p>

<p>杂，因为它把键存成字符串的同时，还要按照它原来的样子存一份。</p>

<p>之前我们见识过了不可变的序列类型，那有没有不可变的字典类型呢？这么说吧，在标准</p>

<p>库里是没有这样的类型的，但是可以用替身来代替。</p>

<h3 id="3-7-不可变映射类型">3.7 不可变映射类型</h3>

<p>标准库里所有的映射类型都是可变的，但有时候你会有这样的需求，比如不能让用户错误 地修改某个映射。3.4.2节提到过Pingo.io，它里面就有个现成的例子。Pingo.io里有个映 射的名字叫作board.pins，里面的数据是GPIO物理针脚的信息，我们当然不希望用户 一个疏忽就把这些信息给改了。因为硬件方面的东西是不会受软件影响的，所以如果把这 个映射里的信息改了，就跟物理上的元件对不上号了。</p>

<p>从Python 3.3开始，types模块中引入了一个封装类名叫MappingProxyType。如果给这</p>

<p>个类一个映射，它会返回一个只读的映射视图。虽然是个只读视图，但是它是动态的。这 意味着如果对原映射做出了改动，我们通过这个视图可以观察到，但是无法通过这个视图 对原映射做出修改。示例 3-9 简短地对这个类的用法做了个演示。</p>

<p>示例 3-9 用 MappingProxyType 来获取字典的只读实例 mappingproxy</p>

<p>&gt;&gt;&gt; from types import MappingProxyType</p>

<p>&gt;&gt;&gt; d = {1:&lsquo;A&rsquo;}</p>

<p>&gt;&gt;&gt; d_proxy = MappingProxyType(d)</p>

<p>&gt;&gt;&gt; d_proxy mappingproxy({1: &lsquo;A&rsquo;})</p>

<p>&gt;&gt;&gt; d_proxy &lsquo;A&rsquo;</p>

<p>&gt;&gt;&gt; d_proxy[2] = &lsquo;x&rsquo;    ©</p>

<p>Traceback (most recent call last):</p>

<p>File &ldquo;<stdin>&rdquo;, line 1, in <module></p>

<p>TypeError: &lsquo;mappingproxy&rsquo; object does not support item assignment &gt;&gt;&gt; d[2] = &lsquo;B&rsquo;</p>

<p>&gt;&gt;&gt; d_proxy &amp;</p>

<p>mappingproxy({1: &lsquo;A&rsquo;, 2: &lsquo;B&rsquo;})</p>

<p>&gt;&gt;&gt; d_proxy[2]</p>

<p>&lsquo;B&rsquo;</p>

<p>&gt;&gt;&gt;</p>

<p>O d中的内容可以通过d_proxy看到。</p>

<p>© 但是通过 d_proxy 并不能做任何修改。</p>

<p>© d_proxy是动态的，也就是说对d所做的任何改动都会反馈到它上面。</p>

<p>因此在Pingo.io中我们是这样用它的：Board的具体子类会提供一个包含针脚信息的私有 映射成员，然后通过公开属性 .pins 把这个映射暴露给 API 的客户，而 .pins 属性其实 就是用 mappingproxy 实现的。一旦这样写好了，客户就不能对这个映射进行任何意外</p>

<p>的添加、移除或者修改操作。 6</p>

<p>I 6为了照顾Python 2.7，现实中的Pingo.io没有借用MappingProxyType来实现这个功能，因为它只在Python 3.3里才</p>

<p>有。</p>

<p>到了这里，我们对标准库中的大多数映射类型都有了一些了解，下面让我们移步到集合类</p>

<p>型。</p>

<h3 id="3-8集合论">3.8集合论</h3>

<p>“集”这个概念在Python中算是比较年轻的，同时它的使用率也比较低。set和它的不可变 的姊妹类型 frozenset 直到 Python 2.3 才首次以模块的形式出现，然后在 Python 2.6 中它 们升级成为内置类型。</p>

<p>本书中“集”或者“集合”既指set，也指frozenset。当“集”仅指代set类时，</p>

<p>我会用等宽字体表示 7。</p>

<p>| 7“集”在英文中就是set，因此原书中需要用等宽字体来区分特指和泛指。一编者注 集合的本质是许多唯一对象的聚集。因此，集合可以用于去重：</p>

<p>&gt;&gt;&gt; l = [&lsquo;spam&rsquo;, &lsquo;spam&rsquo;, &lsquo;eggs&rsquo;, &lsquo;spam&rsquo;] &gt;&gt;&gt; set(l)</p>

<p>{&lsquo;eggs&rsquo;, &lsquo;spam&rsquo;}</p>

<p>&gt;&gt;&gt; list(set(l))</p>

<p>[&lsquo;eggs&rsquo;, &lsquo;spam&rsquo;]</p>

<p>集合中的元素必须是可散列的， set 类型本身是不可散列的，但是 frozenset 可以。因 此可以创建一个包含不同 frozenset 的 set。</p>

<p>除了保证唯一性，集合还实现了很多基础的中缀运算符。给定两个集合 a 和 b， a | b 返</p>

<p>回的是它们的合集， a &amp; b 得到的是交集，而 a - b 得到的是差集。合理地利用这些操 作，不仅能够让代码的行数变少，还能减少 Python 程序的运行时间。这样做同时也是为</p>

<p>了让代码更易读，从而更容易判断程序的正确性，因为利用这些运算符可以省去不必要的</p>

<p>循环和逻辑操作。</p>

<p>例如，我们有一个电子邮件地址的集合(haystack)，还要维护一个较小的电子邮件地 址集合(needles)，然后求出needles中有多少地址同时也出现在了 heystack里。 借助集合操作，我们只需要一行代码就可以了(见示例 3-10)。</p>

<p>示例3-10 needles的元素在haystack里出现的次数，两个变量都是set类型</p>

<p>found = len(needles &amp; haystack)</p>

<p>如果不使用交集操作的话，代码可能就变成了示例 3-11 里那样。</p>

<p>示例 3-11 needles 的元素在 haystack 里出现的次数(作用和示例 3-10 中的相 同)</p>

<p>found += 1</p>

<p>示例 3-10 比示例 3-11 的速度要快一些；另一方面，示例 3-11 可以用在任何可迭代对象 needles 和 haystaek 上，而示例 3-10 则要求两个对象都是集合。话再说回来，就算手 头没有集合，我们也可以随时建立集合，如示例 3-12 所示。</p>

<p>示例 3-12 needles 的元素在 haystaek 里出现的次数，这次的代码可以用在任何 可迭代对象上</p>

<p>found = len(set(needles) &amp; set(haystaek))</p>

<p># 另一种写法：</p>

<p>found = len(set(needles).interseetion(haystaek))</p>

<p>示例 3-12 里的这种写法会牵扯到把对象转化为集合的成本，不过如果 needles 或者是 haystaek 中任意一个对象已经是集合，那么示例 3-12 的方案可能就比示例 3-11 里的要 更高效。</p>

<p>以上的所有例子的运行时间都能在 3 毫秒左右，在含有 10 000 000 个元素的 haystaek 里 搜索 1000 个值，算下来大概是每个元素 3 微秒。</p>

<p>除了速度极快的查找功能(这也得归功于它背后的散列表)，内置的 set 和 frozenset 提供了丰富的功能和操作，不但让创建集合的方式丰富多彩，而且对于 set 来讲，我们 还可以对集合里已有的元素进行修改。在讨论这些操作之前，先来看一下相关的句法。 3.8.1 集合字面量</p>

<p>除空集之外，集合的字面量——{1}、{1, 2}，等等——看起来跟它的数学形式一模一 样。如果是空集，那么必须写成 set() 的形式。</p>

<p>不要忘了，如果要创建一个空集，你必须用不带任何参数的构造方法set()。如果只 是写成 {} 的形式，跟以前一样，你创建的其实是个空字典。</p>

<p>在 Python 3 里面，除了空集，集合的字符串表示形式总是以 {&hellip;} 的形式出现。</p>

<p>&gt;&gt;&gt; s = {1} &gt;&gt;&gt; type(s)</p>

<p><elass 'set'></p>

<p>&gt;&gt;&gt; s {1}</p>

<p>&gt;&gt;&gt; s.pop()</p>

<p>1</p>

<p>&gt;&gt;&gt; s</p>

<p>set()</p>

<p>像｛1, 2, 3｝这种字面量句法相比于构造方法（set（［1, 2, 3］））要更快且更易读。 后者的速度要慢一些，因为 Python 必须先从 set 这个名字来查询构造方法，然后新建一 个列表，最后再把这个列表传入到构造方法里。但是如果是像 ｛1, 2, 3｝ 这样的字面 量， Python 会利用一个专门的叫作 BUILD_SET 的字节码来创建集合。</p>

<p>用dis.dis （反汇编函数）来看看两个方法的字节码的不同：</p>

<p>O检查｛1｝字面量背后的字节码。</p>

<p>© 特殊的字节码 BUILD_SET 几乎完成了所有的工作。</p>

<p>© set（［1］） 的字节码。</p>

<p>O 3种不同的操作代替了上面的BUILD_SET: LOAD_NAME、BUILD_LIST和 CALL_FUNCTION。</p>

<p>由于 Python 里没有针对 frozenset 的特殊字面量句法，我们只能采用构造方法。 Python 3 里 frozenset 的标准字符串表示形式看起来就像构造方法调用一样。来看这段控制台对</p>

<p>话：</p>

<p>&gt;&gt;&gt; frozenset(range(10))</p>

<p>frozenset({0, 1, 2, 3, 4, 5, 6, 7, 8, 9})</p>

<p>既然提到了句法，就不得不提一下我们已经熟悉的列表推导，因为也有类似的方式来新建</p>

<p>集合。</p>

<p>3.8.2 集合推导</p>

<p>Python 2.7带来了集合推导（setcomps）和之前在3.2节里讲到过的字典推导。示例3-13 是个简单的例子。</p>

<p>示例 3-13 新建一个 Latin-1 字符集合，该集合里的每个字符的 Unicode 名字里都 有“SIGN”这个单词</p>

<p>{</p>

<p>§ ,=,年，# , a,    &lt; ,    ¥ ,    , x, $ ,    5,    £ ,    © ,</p>

<p>&lsquo;°&rsquo;,    &lsquo;+&rsquo;,    ■士’，    &lsquo;&gt;&rsquo;,    &lsquo;-&rsquo;,    &lsquo;®&rsquo;,    &lsquo;%&rsquo;}</p>

<p>O从unieodedata模块里导入name函数，用以获取字符的名字。</p>

<p>©把编码在32〜255之间的字符的名字里有“SIGN”单词的挑出来，放到一个集合里。</p>

<p>跟句法相关的内容就讲到这里，下面看看用于集合类型的丰富操作。</p>

<p>3.8.3 集合的操作</p>

<p>图 3-2 列出了可变和不可变集合所拥有的方法的概况，其中不少是运算符重载的特殊方 法。表 3-2 则包含了数学里集合的各种操作在 Python 中所对应的运算符和方法。其中有些 运算符和方法会对集合做就地修改（像&amp;=、differenee_update，等等），这类操作在 纯粹的数学世界里是没有意义的，另外 frozenset 也不会实现这些操作。</p>

<p>图 3-2： collections.abc 中， MutableSet 和它的超类的 UML 类图（箭头从子类指 向超类，抽象类和抽象方法的名称以斜体显示，其中省略了反向运算符方法）</p>

<p>表3-2中的中缀运算符需要两侧的被操作对象都是集合类型，但是其他的所有 方法则只要求所传入的参数是可迭代对象。例如，想求 4 个聚合类型 a、 b、 e 和 d</p>

<p>的合集，可以用a.union（b, e, d），这里a必须是个set，但是b、e和d则可以</p>

<p>是任何类型的可迭代对象。</p>

<p>表3-2：集合的数学运算：这些方法或者会生成新集合，或者会在条件允许的情况下</p>

<p>就地修改集合</p>

<table>
<thead>
<tr>
<th>学号11£;付</th>
<th>Python运算符</th>
<th>方法</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td></td>
<td>s &amp; z</td>
<td>s.__and__(z)</td>
<td>s和z的交集</td>
</tr>

<tr>
<td></td>
<td>s.__rand__(z)</td>
<td>反向&amp;操作</td>
<td></td>
</tr>
</tbody>
</table>

<table>
<thead>
<tr>
<th>S n Z</th>
<th>z &amp; s</th>
<th>s.inter section(it, &hellip;)</th>
<th>把可迭代的it和其他所有参数转化为集合，然后 求它们与s的交集</th>
</tr>
</thead>

<tbody>
<tr>
<td>s &amp;= z</td>
<td>s.\iand\(z )</td>
<td>把s更新为s和z的交集</td>
<td></td>
</tr>

<tr>
<td>s.inter section_update(it, &hellip;)</td>
<td>把可迭代的it和其他所有参数转化为集合，然后 求得它们与s的交集，然后把s更新成这个交集</td>
<td></td>
<td></td>
</tr>

<tr>
<td>S uZ</td>
<td>s | z</td>
<td>s.__or__(z)</td>
<td>s和z的并集</td>
</tr>

<tr>
<td>z | s</td>
<td>s.__ror__(z)</td>
<td>|的反向操作</td>
<td></td>
</tr>

<tr>
<td>s.union(it, &hellip;)</td>
<td>把可迭代的it和其他所有参数转化为集合，然后 求它们和s的并集</td>
<td></td>
<td></td>
</tr>

<tr>
<td>s |= z</td>
<td>s.__ior__(z)</td>
<td>把s更新为s和z的并集</td>
<td></td>
</tr>

<tr>
<td>s .update( it, &hellip;)</td>
<td>把可迭代的it和其他所有参数转化为集合，然后 求它们和s的并集，并把s更新成这个并集</td>
<td></td>
<td></td>
</tr>

<tr>
<td>S \ Z</td>
<td>s - z</td>
<td>s.__sub__(z)</td>
<td>s和z的差集，或者叫作相对补集</td>
</tr>

<tr>
<td>z - s</td>
<td>s.__rsub__(z)</td>
<td>-的反向操作</td>
<td></td>
</tr>

<tr>
<td>s . difference( it, &hellip;)</td>
<td>把可迭代的it和其他所有参数转化为集合，然后 求它们和s的差集</td>
<td></td>
<td></td>
</tr>

<tr>
<td>s -= z</td>
<td>s.__isub__(z)</td>
<td>把s更新为它与z的差集</td>
<td></td>
</tr>

<tr>
<td>s .difference_update( it, &hellip;)</td>
<td>把可迭代的it和其他所有参数转化为集合，求它 们和s的差集，然后把s更新成这个差集</td>
<td></td>
<td></td>
</tr>

<tr>
<td>s . symmetric\difference(it)</td>
<td>求s和set(it)的对称差集</td>
<td></td>
<td></td>
</tr>

<tr>
<td>S △Z</td>
<td>s A z</td>
<td>s.__xor__(z)</td>
<td>求s和z的对称差集</td>
</tr>

<tr>
<td>z A s</td>
<td>s.\rxor\(z)</td>
<td>-的反向操作</td>
<td></td>
</tr>

<tr>
<td>s . symmetric_difference_update(it,…) - -</td>
<td>把可迭代的it和其他所有参数转化为集合，然后 求它们和s的对称差集，最后把s更新成该结果</td>
<td></td>
<td></td>
</tr>

<tr>
<td>s A= z</td>
<td>s.__ixor__(z)</td>
<td>把s更新成它与z的对称差集</td>
<td></td>
</tr>
</tbody>
</table>

<p>在写这本书的时候，Python有个缺陷(issue 8743， <a href="http://bugs.python.org/issue8743">http://bugs.python.org/issue8743</a>) ，里面说到 set() 的运算符</p>

<p>(or、and、sub、xor 和它们相对应的就地修改运算符)要求参数必须是 set() 的 实例，这就导致这些运算符不能被用在 collections.abc.Set 这个子类上面。这个</p>

<p>缺陷已经在 Python 2.7 和 Python 3.4 里修复了，在你看到这本书的时候，它已经成了</p>

<p>历史。</p>

<p>表 3-3 里列出了返回值是 True 和 False 的方法和运算符。</p>

<p>表3-3：集合的比较运算符，返回值是布尔类型</p>

<table>
<thead>
<tr>
<th>数学符号</th>
<th>Python运算符</th>
<th>方法</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td></td>
<td></td>
<td>s.isdisjoint(z)</td>
<td>查看s和z是否不相交(没有共同元素)</td>
</tr>

<tr>
<td>e e s</td>
<td>e in s</td>
<td>s.__contains__(e)</td>
<td>兀素e是否属于s</td>
</tr>

<tr>
<td>S    Z    s &lt;= z</td>
<td>s.__le__(z)</td>
<td>s是否为z的子集</td>
<td></td>
</tr>

<tr>
<td>s.issubset(it)</td>
<td>把可迭代的it转化为集合，然后查看s是否为它的子</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

<table>
<thead>
<tr>
<th></th>
<th></th>
<th>集</th>
<th></th>
</tr>
</thead>

<tbody>
<tr>
<td>sc Z</td>
<td>s &lt; z</td>
<td>s.__lt__(z)</td>
<td>s是否为z的真子集</td>
</tr>

<tr>
<td>S =3 Z    s &gt;= z</td>
<td>s.__ge__(z)</td>
<td>s是否为z的父集</td>
<td></td>
</tr>

<tr>
<td>s.issuperset(it)</td>
<td>把可迭代的it转化为集合，然后查看s是否为它的父 集</td>
<td></td>
<td></td>
</tr>

<tr>
<td>S D Z</td>
<td>s &gt; z</td>
<td>s.__gt__(z)</td>
<td>s是否为z的真父集</td>
</tr>
</tbody>
</table>

<h4 id="除了跟数学上的集合计算有关的方法和运算符-集合类型还有一些为了实用性而添加的方-法-其汇总见于表-3-4">除了跟数学上的集合计算有关的方法和运算符，集合类型还有一些为了实用性而添加的方 法，其汇总见于表 3-4。</h4>

<p>表3-4：集合类型的其他方法</p>

<table>
<thead>
<tr>
<th></th>
<th>set</th>
<th>frozenset</th>
<th></th>
</tr>
</thead>

<tbody>
<tr>
<td>s.add(e)</td>
<td>•</td>
<td></td>
<td>把元素e添加到s中</td>
</tr>

<tr>
<td>s.clear()</td>
<td>•</td>
<td></td>
<td>移除掉s中的所有元素</td>
</tr>

<tr>
<td>s.copy()</td>
<td>•</td>
<td>•</td>
<td>对S浅复制</td>
</tr>

<tr>
<td>s.di scard(e)</td>
<td>•</td>
<td></td>
<td>如果s里有e这个元素的话，把它移除</td>
</tr>

<tr>
<td>s.<strong>iter</strong>()</td>
<td>•</td>
<td>•</td>
<td>返回s的迭代器</td>
</tr>

<tr>
<td>s.<strong>len</strong>()</td>
<td>•</td>
<td>•</td>
<td>len(s)</td>
</tr>

<tr>
<td>s.pop()</td>
<td>•</td>
<td></td>
<td>从s中移除一个元素并返回它的值，若s为空，则抛出KeyError异常</td>
</tr>

<tr>
<td>s.remove(e)</td>
<td>•</td>
<td></td>
<td>从s中移除e元素，若e元素不存在，则抛出KeyError异常</td>
</tr>
</tbody>
</table>

<h4 id="到这里-我们差不多把集合类型的特性总结完了">到这里，我们差不多把集合类型的特性总结完了。</h4>

<p>下面会继续探讨字典和集合类型背后的实现，看看它们是如何借助散列表来实现这些功能 的。读完这章余下的内容后，就算再遇到 dict、 set 或是其他这一类型的一些莫名其妙 的表现，你也不会手足无措。</p>

<h3 id="3-9-diet和set的背后">3.9 diet和set的背后</h3>

<p>想要理解 Python 里字典和集合类型的长处和弱点，它们背后的散列表是绕不开的一环。 这一节将会回答以下几个问题。</p>

<p>• Python里的diet和set的效率有多高？</p>

<p>•为什么它们是无序的？</p>

<p>•为什么并不是所有的Python对象都可以当作diet的键或set里的元素？</p>

<p>•为什么diet的键和set元素的顺序是跟据它们被添加的次序而定的，以及为什么在 映射对象的生命周期中，这个顺序并不是一成不变的？</p>

<p>•为什么不应该在迭代循环diet或是set的同时往里添加元素？</p>

<p>为了让你有动力研究散列表，下面先来看一个关于 diet 和 set 效率的实验，实验对象里</p>

<p>大概有上百万个元素，而实验结果可能会出乎你的意料。</p>

<p>3.9.1 一个关于效率的实验</p>

<p>所有的 Python 程序员都从经验中得出结论，认为字典和集合的速度是非常快的。接下来</p>

<p>我们要通过可控的实验来证实这一点。</p>

<p>为了对比容器的大小对 diet、 set 或 list 的 in 运算符效率的影响，我创建了一个有 1000万个双精度浮点数的数组，名叫haystack。另外还有一个包含了 1000个浮点数的 needles 数组，其中 500 个数字是从 haystaek 里挑出来的，另外 500 个肯定不在 haystaek 里。</p>

<p>作为 diet 测试的基准，我用 diet.fromkeys() 来建立了一个含有 1000 个浮点数的名叫 haystaek 的字典，并用 timeit 模块测试示例 3-14(与示例 3-11 相同)里这段代码运行 所需要的时间。</p>

<p>示例 3-14 在 haystaek 里查找 needles 的元素，并计算找到的元素的个数</p>

<p>found = 0</p>

<p>for n in needles:</p>

<p>if n in haystaek: found += 1</p>

<p>然后这段基准测试重复了 4 次，每次都把 haystaek 的大小变成了上一次的 10 倍，直到 里面有 1000 万个元素。最后这些测试的结果列在了表 3-5 中。</p>

<p>表3-5:用in运算符在5个不同大小的haystack字典里搜索1000个元素所需要的时间。</p>

<p>代码运行在一个Core i7笔记本上，Python版本是3.4.0 （测试计算的是示例3-14里循环 的运行时间）</p>

<table>
<thead>
<tr>
<th>haystack的长度</th>
<th>増长系数</th>
<th>diet花费时间</th>
<th>増长系数</th>
</tr>
</thead>

<tbody>
<tr>
<td>1000</td>
<td>1X</td>
<td>0.000202s</td>
<td>1.00X</td>
</tr>

<tr>
<td>10 000</td>
<td>10X</td>
<td>0.000140s</td>
<td>0.69x</td>
</tr>

<tr>
<td>100 000</td>
<td>100X</td>
<td>0.000228s</td>
<td>1.13x</td>
</tr>

<tr>
<td>1 000 000</td>
<td>1000X</td>
<td>0.000290s</td>
<td>1.44x</td>
</tr>

<tr>
<td>10 000 000</td>
<td>10 000X</td>
<td>0.000337s</td>
<td>1.67x</td>
</tr>
</tbody>
</table>

<p>也就是说，在我的笔记本上从 1000 个字典键里搜索 1000 个浮点数所需的时间是 0.000202 秒，把同样的搜索在含有 10 000 000 个元素的字典里进行一遍，只需要 0.000337 秒。换 句话说，在一个有 1000 万个键的字典里查找 1000 个数，花在每个数上的时间不过是 0.337 微秒——没错，相当于平均每个数差不多三分之一微秒。</p>

<p>作为对比，我把 haystaek 换成了 set 和 list 类型，重复了同样的增长大小的实验。对 于set，除了上面的那个循环的运行时间，我还测量了示例3-15那行代码，这段代码也 计算了 needles 中出现在 haystaek 中的元素的个数。</p>

<p>示例 3-15 利用交集来计算 needles 中出现在 haystaek 中的元素的个数</p>

<p>found = len(needles &amp; haystaek)</p>

<p>表 3-6 列出了所有测试的结果。最快的时间来自“集合交集花费时间”这一列，这一列的结 果是示例 3-15 中利用集合 &amp; 操作的代码的效果。不出所料的是，最糟糕的表现来自“列表 花费时间”这一列。由于列表的背后没有散列表来支持 in 运算符，每次搜索都需要扫描 一次完整的列表，导致所需的时间跟据 haystaek 的大小呈线性增长。</p>

<p>表3-6:在5个不同大小的haystack里搜索1000个元素所需的时间，haystack分别以字 典、集合和列表的形式出现。测试环境是一个有Core i7处理器的笔记本，Python版本 是3.4.0（测试所测量的代码是示例3-14中的循环和示例3-15的集合&amp;操作）</p>

<table>
<thead>
<tr>
<th>的kac 度 st 长ayh</th>
<th>长数増系</th>
<th>费花间ct 时id</th>
<th>长数増系</th>
<th>集合花费时间</th>
<th>长数増系</th>
<th>花集间交时合费集</th>
<th>长数増系</th>
<th>列表花费时间</th>
<th>増长系数</th>
</tr>
</thead>

<tbody>
<tr>
<td>0001</td>
<td>X1</td>
<td>s0202000</td>
<td>X001</td>
<td>s310000.</td>
<td>X001</td>
<td>s8700000</td>
<td>X001</td>
<td>s6551000.</td>
<td>X001</td>
</tr>
</tbody>
</table>

<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>

<tbody>
<tr>
<td>10 000</td>
<td>10X</td>
<td>0.000140s</td>
<td>0.69X</td>
<td>0.000147s</td>
<td>1.03x</td>
<td>0.000092s</td>
<td>1.06x</td>
<td>0.086586s</td>
<td>8.20x</td>
</tr>

<tr>
<td>100 000</td>
<td>100X</td>
<td>0.000228s</td>
<td>1.13X</td>
<td>0.000241s</td>
<td>1.69x</td>
<td>0.000163s</td>
<td>1.87x</td>
<td>0.871560s</td>
<td>82.57x</td>
</tr>

<tr>
<td>1 000 000</td>
<td>1000X</td>
<td>0.000290s</td>
<td>1.44x</td>
<td>0.000332s</td>
<td>2.32x</td>
<td>0.000250s</td>
<td>2.87x</td>
<td>9.189616s</td>
<td>870.56X</td>
</tr>

<tr>
<td>10 000 000</td>
<td>10000X</td>
<td>0.000337s</td>
<td>1.67x</td>
<td>0.000387s</td>
<td>2.71x</td>
<td>0.000314s</td>
<td>3.61x</td>
<td>97.948056s</td>
<td>9278,</td>
</tr>
</tbody>
</table>

<p>如果在你的程序里有任何的磁盘输入 / 输出，那么不管查询有多少个元素的字典或集合， 所耗费的时间都能忽略不计(前提是字典或者集合不超过内存大小)。可以仔细看看跟表 3-6 有关的代码，另外在附录 A 的示例 A-1 中还有相关的讨论。</p>

<p>把字典和集合的运行速度之快的事实抓在手里之后，让我们来看看它背后的原因。对散列</p>

<p>表内部结构的讨论，能解释诸如为什么键是无序且不稳定的。</p>

<p>3.9.2 字典中的散列表</p>

<p>这一节笼统地描述了 Python 如何用散列表来实现 dict 类型，有些细节只是一笔带过，像 CPython 里的一些优化技巧 8 就没有提到。但是总体来说描述是准确的。</p>

<p>8Python 源码 dictobject.c 模块(<a href="http://hg.python.org/cpython/file/tip/Objects/dictobject.c">http://hg.python.org/cpython/file/tip/Objects/dictobject.c </a>)里有丰富的注释，另外延伸阅</p>

<p>读中有对《代码之美》一书的引用。</p>

<p><img src="08414584Python-22.jpg" alt="img" /></p>

<p>为了简单起见，这里先集中讨论 dict 的内部结构，然后再延伸到集合上面 散列表其实是一个稀疏数组(总是有空白元素的数组称为稀疏数组)。在一般的数据结构</p>

<p>教材中，散列表里的单元通常叫作表元(bucket)。在diet的散列表当中，每个键值对</p>

<p>都占用一个表元，每个表元都有两个部分，一个是对键的引用，另一个是对值的引用。因</p>

<p>为所有表元的大小一致，所以可以通过偏移量来读取某个表元。</p>

<p>因为 Python 会设法保证大概还有三分之一的表元是空的，所以在快要达到这个阈值的时 候，原有的散列表会被复制到一个更大的空间里面。</p>

<p>如果要把一个对象放入散列表，那么首先要计算这个元素键的散列值。 Python 中可以用</p>

<p>hash() 方法来做这件事情，接下来会介绍这一点。</p>

<ol>
<li>散列值和相等性</li>
</ol>

<p>内置的 hash() 方法可以用于所有的内置类型对象。如果是自定义对象调用 hash() 的话，实际上运行的是自定义的 <strong>hash</strong>。如果两个对象在比较的时候是相等的， 那它们的散列值必须相等，否则散列表就不能正常运行了。例如，如果 1 == 1.0 为</p>

<p>真，那么 hash(1) == hash(1.0) 也必须为真，但其实这两个数字(整型和浮点) 的内部结构是完全不一样的。 9</p>

<p>为了让散列值能够胜任散列表索引这一角色，它们必须在索引空间中尽量分散开来。 这意味着在最理想的状况下，越是相似但不相等的对象，它们散列值的差别应该越 大。示例 3-16 是一段代码输出，这段代码被用来比较散列值的二进制表达的不同。</p>

<p>注意其中 1 和 1.0 的散列值是相同的，而 1.0001、1.0002 和 1.0003 的散列值则非常不 同。</p>

<p>示例 3-16 在32 位的 Python 中， 1、1.0001、1.0002 和 1.0003 这几个数的散列</p>

<p>值的二进制表达对比(上下两个二进制间不同的位被 ! 高亮出来，表格的最右 列显示了有多少位不相同)</p>

<p>32-bit Python build</p>

<p>1    00000000000000000000000000000001</p>

<p>!= 0</p>

<p>1.0    00000000000000000000000000000001</p>

<p>1.0 00000000000000000000000000000001 ! !!! ! !! ! ! ! ! !! !!! != 16</p>

<p>1.0001 00101110101101010000101011011101</p>

<p>1.0001 00101110101101010000101011011101 !!! !!!! !!!!! !!!!! !! ! != 20</p>

<p>1.0002 01011101011010100001010110111001</p>

<p>1.0002 01011101011010100001010110111001 ! ! ! !!! ! ! !! ! ! ! !!!! != 17</p>

<p>1.0003 00001100000111110010000010010110</p>

<p>用来计算示例3-16的程序见于附录A。尽管程序里大部分代码都是用来整理输出格 式的，考虑到完整性，我还是把全部的代码放在示例 A-3 中了。</p>

<p>从Python 3.3开始，str、bytes和datetime对象的散列值计算过程中多 了随机的“加盐”这一步。所加盐值是 Python 进程内的一个常量，但是每次启动 Python 解释器都会生成一个不同的盐值。随机盐值的加入是为了防止 DOS 攻击</p>

<p>而采取的一种安全措施。在 <strong>hash</strong> 特殊方法的文档</p>

<p>(<a href="https://docs.python.org/3/reference/datamodel.html%23object.__hash__">https://docs.python. org/3/reference/datamodel.html#object.<strong>hash</strong></a>) 里有相关的详 细信息。</p>

<p>了解对象散列值相关的基本概念之后，我们可以深入到散列表工作原理背后的算法</p>

<p>了。</p>

<ol>
<li>散列表算法</li>
</ol>

<p>为了获取 my_diet[seareh_key] 背后的值， Python 首先会调用 hash(seareh_key) 来计算 seareh_key 的散列值，把这个值最低的几位数字当作偏移量，在散列表里 查找表元(具体取几位，得看当前散列表的大小)。若找到的表元是空的，则抛出</p>

<p>KeyError异常。若不是空的，则表元里会有一对found_key:found_value。这时 候 Python 会检验 search_key == found_key 是否为真，如果它们相等的话，就会 返回 found_value。</p>

<p>如果 search_key 和 found_key 不匹配的话，这种情况称为散列冲突。发生这种情 况是因为，散列表所做的其实是把随机的元素映射到只有几位的数字上，而散列表本</p>

<p>身的索引又只依赖于这个数字的一部分。为了解决散列冲突，算法会在散列值中另外 再取几位，然后用特殊的方法处理一下，把新得到的数字再当作索引来寻找表元。 10</p>

<p>若这次找到的表元是空的，则同样抛出KeyError；若非空，或者键匹配，则返回这 个值；或者又发现了散列冲突，则重复以上的步骤。图 3-3 展示了这个算法的示意 图。</p>

<p>图 3-3：从字典中取值的算法流程图；给定一个键，这个算法要么返回一个值，</p>

<p>要么抛出 KeyError 异常</p>

<p>添加新元素和更新现有键值的操作几乎跟上面一样。只不过对于前者，在发现空表元</p>

<p>的时候会放入一个新元素；对于后者，在找到相对应的表元后，原表里的值对象会被</p>

<p>替换成新值。</p>

<p>另外在插入新值时， Python 可能会按照散列表的拥挤程度来决定是否要重新分配内存 为它扩容。如果増加了散列表的大小，那散列值所占的位数和用作索引的位数都会随 之増加，这样做的目的是为了减少发生散列冲突的概率。</p>

<p>表面上看，这个算法似乎很费事，而实际上就算 dict 里有数百万个元素，多数的搜</p>

<p>索过程中并不会有冲突发生，平均下来每次搜索可能会有一到两次冲突。在正常情况</p>

<p>下，就算是最不走运的键所遇到的冲突的次数用一只手也能数过来。</p>

<p>了解 dict 的工作原理能让我们知道它的所长和所短，以及从它衍生而来的数据类型</p>

<p>的优缺点。下面就来看看 diet 这些特点背后的原因。</p>

<p>9既然提到了整型，CPython的实现细节里有一条是：如果有一个整型对象，而且它能被存进一个机器字中，那么它的 散列值就是它本身的值。</p>

<p>10在散列冲突的情况下，用C语言写的用来打乱散列值位的算法的名字很有意思，叫perturb。详见CPython源码里</p>

<p>的 dietobjeet.e(<a href="https://hg.python.org/cpython/file/tip/Objects/dictobject.c">https://hg.python.org/cpython/file/tip/Objects/dictobject.c</a>)。</p>

<p>3.9.3 diet的实现及其导致的结果</p>

<p>下面的内容会讨论使用散列表给 diet 带来的优势和限制都有哪些。</p>

<ol>
<li>键必须是可散列的</li>
</ol>

<p>一个可散列的对象必须满足以下要求。</p>

<p>(1)    支持 hash() 函数，并且通过 <strong>hash</strong>() 方法所得到的散列值是不变的。</p>

<p>(2)    支持通过 <strong>eq</strong>() 方法来检测相等性。</p>

<p>(3)    若 a == b 为真，则 hash(a) == hash(b) 也为真。</p>

<p>所有由用户自定义的对象默认都是可散列的，因为它们的散列值由 id() 来获取，而 且它们都是不相等的。</p>

<p>如果你实现了一个类的<strong>eq</strong>方法，并且希望它是可散列的，那么它 一定要有个恰当的 <strong>hash</strong> 方法，保证在 a == b 为真的情况下 hash(a) == hash(b) 也必定为真。否则就会破坏恒定的散列表算法，导致由这些对象所组 成的字典和集合完全失去可靠性，这个后果是非常可怕的。另一方面，如果一个 含有自定义的 <strong>eq</strong> 依赖的类处于可变的状态，那就不要在这个类中实现 <strong>hash</strong> 方法，因为它的实例是不可散列的。</p>

<ol>
<li>字典在内存上的开销巨大</li>
</ol>

<p>由于字典使用了散列表，而散列表又必须是稀疏的，这导致它在空间上的效率低下。</p>

<p>举例而言，如果你需要存放数量巨大的记录，那么放在由元组或是具名元组构成的列</p>

<p>表中会是比较好的选择；最好不要根据 JSON 的风格，用由字典组成的列表来存放这</p>

<p>些记录。用元组取代字典就能节省空间的原因有两个：其一是避免了散列表所耗费的</p>

<p>空间，其二是无需把记录中字段的名字在每个元素里都存一遍。</p>

<p>在用户自定义的类型中， <strong>slots</strong> 属性可以改变实例属性的存储方式，由 diet 变 成tuple，相关细节在9.8节会谈到。</p>

<p>记住我们现在讨论的是空间优化。如果你手头有几百万个对象，而你的机器有几个 GB 的内存，那么空间的优化工作可以等到真正需要的时候再开始计划，因为优化往 往是可维护性的对立面。</p>

<ol>
<li>键查询很快</li>
</ol>

<p>diet 的实现是典型的空间换时间：字典类型有着巨大的内存开销，但它们提供了无 视数据量大小的快速访问——只要字典能被装在内存里。正如表 3-5 所示，如果把字 典的大小从 1000 个元素增加到 10 000 000 个，查询时间也不过是原来的 2.8 倍，从 0.000163 秒增加到了 0.00456 秒。这意味着在一个有 1000 万个元素的字典里，每秒 能进行 200 万个键查询。</p>

<ol>
<li>键的次序取决于添加顺序</li>
</ol>

<p>当往 diet 里添加新键而又发生散列冲突的时候，新键可能会被安排存放到另一个位 置。于是下面这种情况就会发生：由 diet([key1, value1), (key2, value2)] 和 diet([key2, value2], [key1, value1]) 得到的两个字典，在进行比较的时 候，它们是相等的；但是如果在 key1 和 key2 被添加到字典里的过程中有冲突发生 的话，这两个键出现在字典里的顺序是不一样的。</p>

<p>示例 3-17 展示了这个现象。这个示例用同样的数据创建了 3 个字典，唯一的区别就 是数据出现的顺序不一样。可以看到，虽然键的次序是乱的，这 3 个字典仍然被视作</p>

<p>相等的。</p>

<p>示例 3-17 dialcodes.py 将同样的数据以不同的顺序添加到 3 个字典里</p>

<p># 世界人口数量前10位国家的电话区号</p>

<p>DIAL_CODES = [</p>

<p>(86, &lsquo;China&rsquo;),</p>

<p>(91, &lsquo;India&rsquo;),</p>

<p>(1, &lsquo;United States&rsquo;),</p>

<p>(62, &lsquo;Indonesia&rsquo;),</p>

<p>(55, &lsquo;Brazil&rsquo;),</p>

<p>(92, &lsquo;Pakistan&rsquo;),</p>

<p>(880, &lsquo;Bangladesh&rsquo;),</p>

<p>(234, &lsquo;Nigeria&rsquo;),</p>

<p>(7, &lsquo;Russia&rsquo;),</p>

<p>(81, &lsquo;Japan&rsquo;),</p>

<p>]</p>

<p>di = diet(DIAL_CODES) O</p>

<p>print(&lsquo;d1:&lsquo;, d1.keys())</p>

<p>d2 = diet(sorted(DIAL_CODES)) &amp; print(&lsquo;d2:&lsquo;, d2.keys())</p>

<p>d3 = diet(sorted(DIAL_CODES, key=lambda x:x[1]))    ©</p>

<p>print(&lsquo;d3:&lsquo;, d3.keys())</p>

<p>assert di == d2 and d2 == d3 ©</p>

<p>O 创建 di 的时候，数据元组的顺序是按照国家的人口排名来决定的。</p>

<p>&amp;创建d2的时候，数据元组的顺序是按照国家的电话区号来决定的。</p>

<p>© 创建 d3 的时候，数据元组的顺序是按照国家名字的英文拼写来决定的。</p>

<p>© 这些字典是相等的，因为它们所包含的数据是一样的。示例 3-18 里是上面例子的 输出。</p>

<p>示例 3-18 dialcodes.py 的输出中， 3 个字典的键的顺序是不一样的</p>

<p>d1: dict_keys([880, 1, 86, 55, 7, 234, 91, 92, 62, 81]) d2: dict_keys([880, 1, 91, 86, 81, 55, 234, 7, 92, 62]) d3: dict keys([880, 81, 1, 86, 55, 7, 234, 91, 92, 62])</p>

<ol>
<li>往字典里添加新键可能会改变已有键的顺序</li>
</ol>

<p>无论何时往字典里添加新的键， Python 解释器都可能做出为字典扩容的决定。扩容导</p>

<p>致的结果就是要新建一个更大的散列表，并把字典里已有的元素添加到新表里。这个</p>

<p>过程中可能会发生新的散列冲突，导致新散列表中键的次序变化。要注意的是，上面</p>

<p>提到的这些变化是否会发生以及如何发生，都依赖于字典背后的具体实现，因此你不</p>

<p>能很自信地说自己知道背后发生了什么。如果你在迭代一个字典的所有键的过程中同</p>

<p>时对字典进行修改，那么这个循环很有可能会跳过一些键——甚至是跳过那些字典中</p>

<p>已经有的键。</p>

<p>由此可知，不要对字典同时进行迭代和修改。如果想扫描并修改一个字典，最好分成</p>

<p>两步来进行：首先对字典迭代，以得出需要添加的内容，把这些内容放在一个新字典</p>

<p>里；迭代结束之后再对原有字典进行更新。</p>

<p>在Python 3中，.keys()、.items()和.values()方法返回的都是字典 视图。也就是说，这些方法返回的值更像集合，而不是像 Python 2 那样返回列</p>

<p>表。视图还有动态的特性，它们可以实时反馈字典的变化。</p>

<p>现在已经可以把学到的有关散列表的知识应用在集合上面了。</p>

<p>3.9.4 set的实现以及导致的结果</p>

<p>set 和 frozenset 的实现也依赖散列表，但在它们的散列表里存放的只有元素的引用 (就像在字典里只存放键而没有相应的值)。在 set 加入到 Python 之前，我们都是把字</p>

<p>典加上无意义的值当作集合来用的。</p>

<p>在 3.9.3 节中所提到的字典和散列表的几个特点，对集合来说几乎都是适用的。为了避免</p>

<p>太多重复的内容，这些特点总结如下。</p>

<p>•集合里的元素必须是可散列的。</p>

<p>•集合很消耗内存。</p>

<p>•可以很高效地判断元素是否存在于某个集合。</p>

<p>•元素的次序取决于被添加到集合里的次序。</p>

<p>•往集合里添加元素，可能会改变集合里己有元素的次序。</p>

<h3 id="3-10-本章小结">3.10 本章小结</h3>

<p>字典算得上是 Python 的基石。除了基本的 dict 之外，标准库还提供现成且好用的特殊映 射类型，比如 defaultdict、OrderedDict、ChainMap 和 Counter。这些映射类型都 属于 collections 模块，这个模块还提供了便于扩展的 UserDict 类。</p>

<p>大多数映射类型都提供了两个很强大的方法： setdefault 和 update。 setdefault 方 法可以用来更新字典里存放的可变值(比如列表)，从而避免了重复的键搜索。 update</p>

<p>方法则让批量更新成为可能，它可以用来插入新值或者更新已有键值对，它的参数可以是</p>

<p>包含 (key, value) 这种键值对的可迭代对象，或者关键字参数。映射类型的构造方法 也会利用 update 方法来让用户可以使用别的映射对象、可迭代对象或者关键字参数来创 建新对象。</p>

<p>在映射类型的 API 中，有个很好用的方法是 <strong>missing</strong>，当对象找不到某个键的时 候，可以通过这个方法自定义会发生什么。</p>

<p>collections.abc 模块提供了 Mapping 和 MutableMapping 这两个抽象基类，利用它</p>

<p>们，我们可以进行类型查询或者引用。不太为人所知的 MappingProxyType 可以用来创</p>

<p>建不可变映射对象，它被封装在 types 模块中。另外还有 Set 和 MutableSet 这两个抽 象基类。</p>

<p>dict 和 set 背后的散列表效率很高，对它的了解越深入，就越能理解为什么被保存的元</p>

<p>素会呈现出不同的顺序，以及已有的元素顺序会发生变化的原因。同时，速度是以牺牲空</p>

<p>间为代价而换来的。</p>

<h3 id="3-11-延伸阅读">3.11 延伸阅读</h3>

<p>Python 标准库中的“8.3. collections—Container datatypes”一节 (<a href="https://docs.python.org/3/library/collections.html">https://docs.python.org/3Zlibrary/collections.html</a>)提到了关于一些映射类型的例子和使用</p>

<p>技巧。如果想要创建新的映射类型，或者是体会一下现有的映射类型的实现方式， Python 模块 Lib/collections/<strong>init</strong>.py 的源码是一个很好的参考。</p>

<p>《Python Cookbook (第 3 版)中文版》(David Beazley 和 Brian K. Jones 著)的第 1 章中</p>

<p>有 20 个关于数据结构的使用技巧，大多数都在讲 diet 的巧妙用法。</p>

<p>“Python 的字典类：如何打造全能战士”是《代码之美》第 18 章的标题，这一章集中解释 了 Python 字典背后的工作原理。 A.M. Kuchling 是这一章的作者，同时他还是 Python 的核 心开发者，并撰写了很多 Python 的官方文档和指南。同时 CPython 模块里的 dietobjeet.e 源文件(<a href="https://hg.python.org/cpython/file/tip/Objects/dictobject.c">https://hg.python.org/cpython/file/tip/Objects/dictobjectc</a>)还提供了 大量的注释。Brandon Craig Rhodes 的讲座“The Mighty</p>

<p>Dictionary” (<a href="http://pyvideo.org/video/276/the-mighty-dictionary-55">http://pyvideo.org/video/276/the-mighty-dictionary-55</a>)对散列表做了很精彩的</p>

<p>讲解，有趣的是他的幻灯片里也包含了大量的表格。</p>

<p>关于为什么要在语言里加入集合这种数据类型，当初也是有一番考量的。具体情况</p>

<p>在“PEP 218 — Adding a Built-In Set Object Type” (<a href="https://www.python.org/dev/peps/pep-">https://www.python.org/dev/peps/pep-</a></p>

<p><a href="https://www.python.org/dev/peps/pep-0218/">0218/</a><a href="https://www.python.org/dev/peps/pep-0218/">)中有所记录。在 PEP 128 刚刚通过的时候，还没有针对 set 的特殊字面量句法</a>。 后来 Python 3 里加入了对 set 字面量句法的支持，然后这个实现又被向后兼容到了 Python 2.7 里，同时被移植的还有 diet 和 set 推导。 “PEP 274 — Dict</p>

<p>Comprehensions” (<a href="https://www.python.org/dev/peps/pep-0274/">https://www.python.org/dev/peps/pep-0274/</a>)就是字典推导的出生证；然</p>

<p>而我找不到任何关于集合推导的PEP，当然很有可能是因为这两个功能太接近了。</p>

<p>杂谈</p>

<p>我的朋友 Geraldo Cohen 曾经说过， Python 的特点是“简单而正确”。</p>

<p>diet 类型正是这一特点的完美体现——对它的优化只为一个目标：更好地实现对随 机键的读取。而优化的结果非常好，由于速度快而且够健壮，它大量地应用于 Python 的解释器当中。如果对排序有要求，那么还可以选择OrderedDiet。然而对于映射 类型来说，保持元素的顺序并不是一个常用需求，因此会把它排除在核心功能之外， 而以标准库的形式提供其他衍生的类型。</p>

<p>与之形成鲜明对比的是PHP。在PHP手册中，数组的描述如下 (<a href="http://php.net/manual/en/language.types.array.php">http://php.net/manual/en/language.types.array.php</a>) ：</p>

<p>PHP 中的数组实际上是一个有序的映射——映射类型存放的是键值对。这个映射 类型被优化为可充当不同的角色。它可以当作数组、列表(向量)、散列表(映 射类型的一种实现)、字典、集合类型、栈、队列或其他可能的数据类型。</p>

<p>单凭这段话，我无法想象 PHP 把 list 和 OrderedDiet 混合实现的成本有多大。</p>

<p>本书前两章的目的是展示 Python 中的集合类型为特定的使用场景做了怎样的优化。</p>

<p>我特意强调了在 list 和 dict 的常规用法之外还有那些特殊的使用情景。</p>

<p>在遇到 Python 之前，我主要使用 Perl、 PHP 和 JavaScript 做网站开发。我很喜欢这些</p>

<p>语言中跟映射类型相关的字面量句法特性。某些时候我不得不使用Java和C，然后 我就会疯狂地想念这些特性。好用的映射类型的字面量句法可以帮助开发者轻松实现</p>

<p>配置和表格相关的开发，也能让我们很方便地为原型开发或者测试准备好数据容器。</p>

<p>Java 由于没有这个特性，不得不用复杂且冗长的 XML 来替代。</p>

<p>JSON 被当作“瘦身版 XML” (<a href="http://www.json.org/fatfree.html">http://www+json+org/fafree+html</a>)。在很多情景下，JSON 都成功取代了 XML。由于拥有紧凑的列表和字典表达，JSON格式可以完美地用于数</p>

<p>据交换。</p>

<p>PHP和Ruby的散列语法借鉴了 Perl，它们都用=&gt; 作为键和值的连接。JavaScript则 从 Python 那儿偷师，使用了 :。而 JSON 又从 JavaScript 发展而来，它的语法正好是 Python 句法的子集。因此，除了在 true、 false 和 null 这几个值的拼写上有出入 之外， JSON 和 Python 是完全兼容的。于是，现在大家用来交换数据的格式全是 Python 的 dict 和 list。</p>

<p>简单而正确。</p>

    </div>

    
    

    
    

    <footer class="post-footer">
      

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02-python/%E6%B5%81%E7%95%85%E7%9A%84-python/21-%E7%B1%BB%E5%85%83%E7%BC%96%E7%A8%8B/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">21 类元编程</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02-python/%E6%B5%81%E7%95%85%E7%9A%84-python/04-%E6%96%87%E6%9C%AC%E5%92%8C%E5%AD%97%E8%8A%82%E5%BA%8F%E5%88%97/">
            <span class="next-text nav-default">04 文本和字节序列</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="iteratelyd@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="http://github.com/iterateself" class="iconfont icon-github" title="github"></a>
      <a href="https://www.zhihu.com/people/thebegin/activities" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="https://www.douban.com/people/68028070/" class="iconfont icon-douban" title="douban"></a>
  <a href="http://iterate.site/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> site pv: <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
    <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> site uv: <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2018
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">iterateself</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>


<script type="text/javascript" src="/dist/even.min.js?v=3.2.0"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>








</body>
</html>
