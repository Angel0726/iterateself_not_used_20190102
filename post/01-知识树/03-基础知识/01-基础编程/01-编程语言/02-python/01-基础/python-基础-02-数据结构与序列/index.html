<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Python 基础 02 数据结构与序列 - 迭代自己</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="iterateself" />
  <meta name="description" content="[TOC] 需要补充的 还是有一些知识点之前大概知道是怎么回事，现在才比较清楚。 还是要更多的例子来熟练应用。 1 Tuple（元组） tuple是长度固定，不" />

  <meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.47.1" />


<link rel="canonical" href="http://iterate.site/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02-python/01-%E5%9F%BA%E7%A1%80/python-%E5%9F%BA%E7%A1%80-02-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%BA%8F%E5%88%97/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">




<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<link href="/dist/even.min.css?v=3.2.0" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">




<meta property="og:title" content="Python 基础 02 数据结构与序列" />
<meta property="og:description" content="[TOC] 需要补充的 还是有一些知识点之前大概知道是怎么回事，现在才比较清楚。 还是要更多的例子来熟练应用。 1 Tuple（元组） tuple是长度固定，不" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://iterate.site/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02-python/01-%E5%9F%BA%E7%A1%80/python-%E5%9F%BA%E7%A1%80-02-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%BA%8F%E5%88%97/" /><meta property="article:published_time" content="2018-06-15T17:32:35&#43;00:00"/>
<meta property="article:modified_time" content="2018-06-15T17:32:35&#43;00:00"/>
<meta itemprop="name" content="Python 基础 02 数据结构与序列">
<meta itemprop="description" content="[TOC] 需要补充的 还是有一些知识点之前大概知道是怎么回事，现在才比较清楚。 还是要更多的例子来熟练应用。 1 Tuple（元组） tuple是长度固定，不">


<meta itemprop="datePublished" content="2018-06-15T17:32:35&#43;00:00" />
<meta itemprop="dateModified" content="2018-06-15T17:32:35&#43;00:00" />
<meta itemprop="wordCount" content="4990">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Python 基础 02 数据结构与序列"/>
<meta name="twitter:description" content="[TOC] 需要补充的 还是有一些知识点之前大概知道是怎么回事，现在才比较清楚。 还是要更多的例子来熟练应用。 1 Tuple（元组） tuple是长度固定，不"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">迭代自己</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">主页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a><a href="/catalog/">
        <li class="mobile-menu-item">完整目录</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">迭代自己</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">主页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/catalog/">完整目录</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Python 基础 02 数据结构与序列</h1>

      <div class="post-meta">
        <span class="post-time"> 2018-06-15 </span>
        
        <span class="more-meta"> 4990 words </span>
        <span class="more-meta"> 10 mins read </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> times read </span>
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  
  <div class="post-toc-content">
    <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#需要补充的">需要补充的</a></li>
</ul></li>
<li><a href="#1-tuple-元组">1 Tuple（元组）</a>
<ul>
<li><a href="#unpacking-tuples-取出元组">Unpacking tuples(取出元组)</a></li>
<li><a href="#tuple-methods-元组方法">Tuple methods(元组方法)</a></li>
</ul></li>
<li><a href="#2-list-列表">2 List (列表)</a>
<ul>
<li><a href="#添加和移除元素">添加和移除元素</a></li>
<li><a href="#合并list">合并list</a></li>
<li><a href="#排序">排序</a></li>
<li><a href="#binary-search-and-maintaining-a-sorted-list-二分搜索和维持一个排好序的list">Binary search and maintaining a sorted list （二分搜索和维持一个排好序的list）</a></li>
<li><a href="#slicing-切片">Slicing (切片)</a></li>
</ul></li>
<li><a href="#3-built-in-sequence-functions-内建的序列函数">3 Built-in Sequence Functions(内建的序列函数)</a>
<ul>
<li><a href="#enumerate-枚举">enumerate（枚举）</a></li>
<li><a href="#sorted">sorted</a></li>
<li><a href="#zip">zip</a></li>
<li><a href="#reversed">reversed</a></li>
</ul></li>
<li><a href="#4-dict-字典">4 dict（字典）</a>
<ul>
<li><a href="#creating-dicts-from-sequences-从序列中生成dict">Creating dicts from sequences（从序列中生成dict）</a></li>
<li><a href="#default-value-默认值">Default value(默认值)</a></li>
<li><a href="#valid-dict-key-types-有效的key类型">Valid dict key types (有效的key类型)</a></li>
<li><a href="#5-set-集合">5 Set 集合</a></li>
</ul></li>
<li><a href="#6-list-set-and-dict-comprehensions-推导式">6 List, Set, and Dict Comprehensions(推导式)</a>
<ul>
<li><a href="#nested-list-comprehensions-嵌套列表表达式">Nested list comprehensions（嵌套列表表达式）</a></li>
</ul></li>
</ul>
</nav>
  </div>
</div>

    
    

    
    <div class="post-content">
      

<p>[TOC]</p>

<h2 id="需要补充的">需要补充的</h2>

<ul>
<li>还是有一些知识点之前大概知道是怎么回事，现在才比较清楚。</li>
<li>还是要更多的例子来熟练应用。</li>
</ul>

<h1 id="1-tuple-元组">1 Tuple（元组）</h1>

<p>tuple是长度固定，不可改变的序列。创建元祖的方法是用逗号：==创建的时候不用加括号吗==</p>

<pre><code>tup = 4, 5, 6
print(tup)
</code></pre>

<p>输出：</p>

<pre><code>(4, 5, 6)
</code></pre>

<p>如果想要创建一个更复杂的tuple的话，还是要用括号，括号之间还是用逗号：</p>

<pre><code>nested_tup = (4, 5, 6), (7, 8)
print(nested_tup)
</code></pre>

<p>输出：</p>

<pre><code>((4, 5, 6), (7, 8))
</code></pre>

<p>把其他序列或迭代器转换为序列：</p>

<pre><code>print(tuple([4, 0, 2]))
print(tuple('string'))
</code></pre>

<p>输出：</p>

<pre><code>(4, 0, 2)
('s', 't', 'r', 'i', 'n', 'g')
</code></pre>

<p>存放在 tuple 中的 object 本身无法更改：</p>

<pre><code>tup = tuple(['foo', [1, 2], True])
tup[2] = False
</code></pre>

<p>输出：</p>

<pre><code>---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
&lt;ipython-input-7-692985e84db1&gt; in &lt;module&gt;()
      1 tup = tuple(['foo', [1, 2], True])
----&gt; 2 tup[2] = False

TypeError: 'tuple' object does not support item assignment
</code></pre>

<p>但是如果tuple内部的object是可更改的，那么我们可以试着更改一下：==还可以这样？==</p>

<pre><code>tup[1].append(3)
print(tup)
</code></pre>

<p>输出：</p>

<pre><code>('foo', [1, 2, 3], True)
</code></pre>

<p>用 + 来合并多个tuple：==这个也没用过==</p>

<pre><code>(4, None, 'for') + (6, 0) + ('bar', )
</code></pre>

<p>输出：</p>

<pre><code>(4, None, 'for', 6, 0, 'bar')
</code></pre>

<p><code>*</code> 相当于copy多份，也可以用在list上：</p>

<pre><code>('foo', 'bar') * 4
</code></pre>

<p>输出：</p>

<pre><code>('foo', 'bar', 'foo', 'bar', 'foo', 'bar', 'foo', 'bar')
</code></pre>

<h2 id="unpacking-tuples-取出元组">Unpacking tuples(取出元组)</h2>

<pre><code>tup = (4, 5, 6)
a, b, c = tup
print(b)
</code></pre>

<p>输出：</p>

<pre><code>5
</code></pre>

<pre><code>tup = 4, 5, (6, 7)
a, b, (c, d) = tup
print(d)
</code></pre>

<p>输出：</p>

<pre><code>7
</code></pre>

<p>用下面的方法来交换变量的名字:</p>

<pre><code>tmp = a
a = b 
b = tmp
</code></pre>

<p>但是在python里，交换能更简洁一些：==是的，这种方法，经常忘记==</p>

<pre><code>b, a = a, b
</code></pre>

<p>这种 unpacking 通常用在迭代序列上：</p>

<pre><code>seq = [(1, 2, 3), (4, 5, 6), (7, 8, 9)]
for a, b, c in seq:
    print('a={0}, b={1}, c={2}'.format(a, b, c))
</code></pre>

<p>输出：</p>

<pre><code>a=1, b=2, c=3
a=4, b=5, c=6
a=7, b=8, c=9
</code></pre>

<p>另一种更高级的 unpacking 方法是用于只取出 tuple 中开头几个元素，剩下的元素直接赋给<code>*rest</code>：==没想到还可以这样，厉害了==</p>

<pre><code>values = 1, 2, 3, 4, 5
a, b, *rest = values
print(a,b)
print(rest)
</code></pre>

<p>输出：</p>

<pre><code>1 2
[3, 4, 5]
</code></pre>

<p>如果 rest 部分是你想要丢弃的，名字本身无所谓，通常用下划线来代替：==嗯，厉害，这个是经常看到的==</p>

<pre><code>a, b, *_ = values
</code></pre>

<h2 id="tuple-methods-元组方法">Tuple methods(元组方法)</h2>

<p>因为tuple的大小和内容都不能改变，所以方法也很少。<code>count</code>用来计算某个值出现的次数，list中也有这个方法：</p>

<pre><code>a = (1, 2, 2, 2, 3, 4, 2)
a.count(2) # 用来计算每个值出现的次数
</code></pre>

<p>输出：</p>

<pre><code>4
</code></pre>

<h1 id="2-list-列表">2 List (列表)</h1>

<p>列表的灵活性就很强了，大小和内容都可以变：</p>

<pre><code>a_list = [2, 3, 7, None]
tup = ('foo', 'bar', 'baz')
b_list = list(tup)
print(b_list)
b_list[1] = 'peekaboo'
b_list
</code></pre>

<p>输出：</p>

<pre><code>['foo', 'bar', 'baz']
['foo', 'peekaboo', 'baz']
</code></pre>

<p>list 函数通常用来具现化迭代器或生成器：</p>

<pre><code>gen = range(10)
print(gen) # 这是一个迭代器，所以无法看到里面的内容
list(gen) # 具现化后就可以看到了
</code></pre>

<p>输出：</p>

<pre><code>range(0, 10)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>

<h2 id="添加和移除元素">添加和移除元素</h2>

<pre><code>b_list.append('dwarf')
print(b_list)
</code></pre>

<p>输出：</p>

<pre><code>['foo', 'peekaboo', 'baz', 'dwarf']
</code></pre>

<p>insert 可以把元素插入到特定的位置：</p>

<pre><code>b_list.insert(1, 'red')
print(b_list)
</code></pre>

<p>输出：</p>

<pre><code>['foo', 'red', 'peekaboo', 'baz', 'dwarf']
</code></pre>

<p>需要注意的是 insert 方法运算量比 append 大。所以如果想要在序列的开头和结尾添加元素的话，可以使用 collections.deque，这是一种双结尾的队列。==这个地方要注意==</p>

<p>insert 的反向操作较 pop, 能移除序列中特定位置的元素：</p>

<pre><code>print(b_list.pop(2))
print(b_list)
</code></pre>

<p>输出：</p>

<pre><code>'peekaboo'
['foo', 'red', 'baz', 'dwarf']
</code></pre>

<p>remove 可以通过值移除指定的element，如果同一个值在序列中多次出现，只移除第一个：==这个要注意，只会移除第一个==</p>

<pre><code>b_list.append('foo')
print(b_list)
b_list.remove('foo')
print(b_list)
</code></pre>

<p>输出：</p>

<pre><code>['foo', 'red', 'baz', 'dwarf', 'foo']
['red', 'baz', 'dwarf', 'foo']
</code></pre>

<p>检查一个值是否在 list 中，用 in：</p>

<pre><code>print('dwarf' in b_list)
print('dwarf' not in b_list)
</code></pre>

<p>输出：</p>

<pre><code>True
False
</code></pre>

<h2 id="合并list">合并list</h2>

<p>用 + 号：</p>

<pre><code>[4, None, 'foo'] + [7, 8, (2, 3)]
</code></pre>

<p>输出：</p>

<pre><code>[4, None, 'foo', 7, 8, (2, 3)]
</code></pre>

<p>通过entend方法，可以添加多个元素：</p>

<pre><code>x = [4, None, 'foo']
x.extend([7, 8, (2, 3)])
print(x)
</code></pre>

<p>输出：</p>

<pre><code>[4, None, 'foo', 7, 8, (2, 3)]
</code></pre>

<p>注意：用 + 法来做合并是一个运算量较大的操作，因为要创建一个新的 list 并复制。如果操作的是一个很大的list，用extend会更好一些：==这个不知道==</p>

<pre><code>everything = []
for chunk in list_of_lists:
    everything.extend(chunk)
# 上面的代码要比下面的快
everything = []
for chunk in list_of_lists:
    everything = everything + chunk
</code></pre>

<p>这里总结一下，首先是 append 和 extend 的区别。==这个一定要注意区分，==</p>

<pre><code>x = [4, None, 'foo']
x.extend([7, 8, (2, 3)])
print(x)
x.append([7, 8, (2, 3)])
print(x)
</code></pre>

<p>输出：</p>

<pre><code>[4, None, 'foo', 7, 8, (2, 3)]
[4, None, 'foo', 7, 8, (2, 3), [7, 8, (2, 3)]]
</code></pre>

<ul>
<li>append 是把后面的 list 作为 元素添加到前一个 list 里</li>
<li>extend 是把两个 list 的内容扩充到一起。</li>
</ul>

<p>然后是 extend和 + 的区别</p>

<ul>
<li><code>+</code>是创建了一个新的list并返回，运算量大</li>
<li>extend 是在原本的 list上做了更改，运算量小</li>
</ul>

<h2 id="排序">排序</h2>

<p>用sort函数</p>

<pre><code>a = [7, 2, 5, 1, 3]
a.sort()
print(a)
</code></pre>

<p>输出：</p>

<pre><code>[1, 2, 3, 5, 7]
</code></pre>

<p>sort 函数有一些比较方便的选项。比如设置一个sort key，这个key也是一个函数（funciton）。比如我们想要按 string 的长度来排序：</p>

<pre><code>b = ['saw', 'small', 'He', 'foxes', 'six']
b.sort(key=len)# 从小倒大排列的
print(b)
</code></pre>

<p>输出：</p>

<pre><code>['He', 'saw', 'six', 'small', 'foxes']
</code></pre>

<h2 id="binary-search-and-maintaining-a-sorted-list-二分搜索和维持一个排好序的list">Binary search and maintaining a sorted list （二分搜索和维持一个排好序的list）</h2>

<p>内建的 bisect 模块可以实现二分搜索。<code>bisect.bisect</code> 是用来寻找插入的位置，而<code>bisect.insort</code> 则实际插入元素到指定的位置：==没想到还有这种功能==</p>

<pre><code>import bisect
c = [1, 2, 2, 2, 3, 4, 7]
print(bisect.bisect(c, 2))# 返回 2 可以插入的位置
print(bisect.bisect(c, 5))# 返回 5 可以插入的位置
bisect.insort(c, 6)
print(c)
</code></pre>

<p>输出：</p>

<pre><code>4
6
[1, 2, 2, 2, 3, 4, 6, 7]
</code></pre>

<p>注意：bisect模块不会检查list是否是排好序的，所以用这个模块之前要先把list排序。==这个要注意==</p>

<h2 id="slicing-切片">Slicing (切片)</h2>

<p>[start:stop], 输出的结果包含开头，不包含结尾。所以输出的结果的数量是stop-start。==要注意==</p>

<pre><code>seq = [7, 2, 3, 7, 5, 6, 0, 1]
seq[1:5] 
</code></pre>

<p>输出：</p>

<pre><code>[2, 3, 7, 5]
</code></pre>

<p>可以赋值：</p>

<pre><code>seq[3:4] = [6, 3]
seq # 把元素7变成了6, 3
</code></pre>

<p>输出：</p>

<pre><code>[7, 2, 3, 6, 3, 5, 6, 0, 1]
</code></pre>

<p>可以不用写开头或结尾：</p>

<pre><code>seq[:5]
seq[3:]
</code></pre>

<p>输出：</p>

<pre><code>[7, 2, 3, 6, 3]
[6, 3, 5, 6, 0, 1]
</code></pre>

<p>负索引表示倒数开始多少个的意思：</p>

<pre><code>seq[-4:]
seq[-6:-2]
</code></pre>

<p>输出：</p>

<pre><code>[5, 6, 0, 1]
[6, 3, 5, 6]
</code></pre>

<p>两个冒号后面的数代表步长，就是隔几个元素取一次：</p>

<pre><code>print(seq)
print(seq[::2])
</code></pre>

<p>输出：</p>

<pre><code>[7, 2, 3, 6, 3, 5, 6, 0, 1]
[7, 3, 3, 6, 1]
</code></pre>

<p>用 -1 能反转一个 list 或 tuple：==这个用法还是很常见的==</p>

<pre><code>seq[::-1]
</code></pre>

<p>输出：</p>

<pre><code>[1, 0, 6, 5, 3, 6, 3, 2, 7]
</code></pre>

<p>切片方式：</p>

<p><img src="http://pacdb2bfr.bkt.clouddn.com/blog/image//180615/h8Lf4eHgBH.png?imageslim" alt="mark" /></p>

<h1 id="3-built-in-sequence-functions-内建的序列函数">3 Built-in Sequence Functions(内建的序列函数)</h1>

<h2 id="enumerate-枚举">enumerate（枚举）</h2>

<p>这个通常用于迭代序列。一个比较直白的方法是：</p>

<pre><code>i = 0
for value in collection:
    # do something with value
    i += 1
</code></pre>

<p>但enumerate能返回一个 (i, value) 的tuple：==这种用法要注意，的确是个好方法==</p>

<pre><code>for i, value in enumerate(collection):
    # do something with value
</code></pre>

<p>enumerate通常用来把一个list中的位置和值映射到一个dcit字典里：</p>

<pre><code>some_list = ['foo', 'bar', 'baz']
mapping = {}
for i, v in enumerate(some_list):
    mapping[v] = i
print(mapping)
</code></pre>

<p>输出：</p>

<pre><code>{'bar': 1, 'baz': 2, 'foo': 0}
</code></pre>

<h2 id="sorted">sorted</h2>

<p>sorted 函数返回一个新的排好序的序列，而之前提到的 .sort 方法是直接更改原有的序列，不产生新序列：==注意，这个要注意区==</p>

<pre><code>sorted([7, 1, 2, 6, 0, 3, 2])
sorted('horse race')
</code></pre>

<p>输出：</p>

<pre><code>[0, 1, 2, 2, 3, 6, 7]
[' ', 'a', 'c', 'e', 'e', 'h', 'o', 'r', 'r', 's']
</code></pre>

<h2 id="zip">zip</h2>

<p>用于&rdquo;pairs&rdquo;(成对)。把多个序列中每个对应的元素变成一对，最后返回一个含有tuple的list：==对应的元素变成一对==</p>

<pre><code>seq1 = ['foo', 'bar', 'baz']
seq2 = ['one', 'two', 'three']
zipped = zip(seq1, seq2)
print(zipped)
list(zipped)
</code></pre>

<p>输出：</p>

<pre><code>&lt;zip object at 0x0000019B03D801C8&gt;
[('foo', 'one'), ('bar', 'two'), ('baz', 'three')]
</code></pre>

<p>zip 可以接收任意长度的序列，最后返回的结果取决于最短的序列：</p>

<pre><code>seq3 = [False, True]
list(zip(seq1, seq2, seq3))
</code></pre>

<p>输出：</p>

<pre><code>[('foo', 'one', False), ('bar', 'two', True)]
</code></pre>

<p>zip 的一个常见用法是同时迭代多个序列，可以和 enumerate 搭配起来用：==哇塞，厉害的方法==</p>

<pre><code>for i, (a, b) in enumerate(zip(seq1, seq2)):
    print('{0}: {1}, {2}'.format(i, a, b))
</code></pre>

<p>输出：</p>

<pre><code>0: foo, one
1: bar, two
2: baz, three
</code></pre>

<p>如果给我们一个压缩过的序列，我们可以将其解压：==这也行？没看明白？==</p>

<pre><code>pitchers = [('Nolan', 'Ryan'), 
            ('Roger', 'Clemens'), 
            ('Schilling', 'Curt')]
first_names, last_names = zip(*pitchers)
print(first_names)
print(last_names)
</code></pre>

<p>输出：</p>

<pre><code>('Nolan', 'Roger', 'Schilling')
('Ryan', 'Clemens', 'Curt')
</code></pre>

<h2 id="reversed">reversed</h2>

<p>reverse可以倒叙迭代序列：</p>

<pre><code>list(reversed(range(10)))
</code></pre>

<p>输出：</p>

<pre><code>[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
</code></pre>

<p>注意，revered是一个generator（生成器，之后会详细讲），所以必须需要list来具现化。==这个revered 和 [::-1] 有区别吗？==</p>

<h1 id="4-dict-字典">4 dict（字典）</h1>

<p>字典也被叫做 hash map 或 associative array。结构就是 key-value pairs. 创建方式是用<code>{}</code>:</p>

<pre><code>empty_dict = {}
d1 = {'a': 'some value', 'b': [1, 2, 3, 4]}
print(d1)
</code></pre>

<p>输出：</p>

<pre><code>{'a': 'some value', 'b': [1, 2, 3, 4]}
</code></pre>

<p>dict像list一样可以插入：</p>

<pre><code>d1[7] = 'an integer'
print(d1)
</code></pre>

<p>输出：</p>

<pre><code>{'b': [1, 2, 3, 4], 7: 'an integer', 'a': 'some value'}
</code></pre>

<p>可以检查dict是否有某个key：</p>

<pre><code>'b' in d1
</code></pre>

<p>输出：</p>

<pre><code>True
</code></pre>

<p>可以用 del 或 pop 删除值：</p>

<pre><code>d1[5] = 'some value'
print(d1)
del d1[5]
print(d1)
d1['dummy'] = 'another value'
print(d1)
ret = d1.pop('dummy')
print(ret)
print(d1)
</code></pre>

<p>输出：</p>

<pre><code>{'b': [1, 2, 3, 4], 7: 'an integer', 5: 'some value', 'a': 'some value'}
{'b': [1, 2, 3, 4], 7: 'an integer', 'a': 'some value'}
{'b': [1, 2, 3, 4],
 'dummy': 'another value',
 7: 'an integer',
 'a': 'some value'}
'another value'
{'b': [1, 2, 3, 4], 7: 'an integer', 'a': 'some value'}
</code></pre>

<p>keys 和 values 方法能返回 dict 中 key-value 组合的迭代器，不过并不安什么顺序。如果想让keys和values 每次打印的顺序相同的话：</p>

<pre><code>list(d1.keys())
list(d1.values())
</code></pre>

<p>输出：</p>

<pre><code>['b', 7, 'a']
[[1, 2, 3, 4], 'an integer', 'some value']
</code></pre>

<p>可以用update来合并两个dict：==这个不知道，如果有相同的key 会怎么样？==</p>

<pre><code>d1.update({'b': 'foo', 'c': 12})
print(d1)
</code></pre>

<p>输出：</p>

<pre><code>{'b': 'foo', 'c': 12, 7: 'an integer', 'a': 'some value'}
</code></pre>

<p>这个update是更改了原有的dict，不会返回新的dict</p>

<h2 id="creating-dicts-from-sequences-从序列中生成dict">Creating dicts from sequences（从序列中生成dict）</h2>

<p>假设我们想把两个序列按照 key-value 的方式生成一个 dict，我们可能会这样写：</p>

<pre><code>mapping = []
for key, value in zip(key_list, value_list):
    mapping[key] = value
</code></pre>

<p>因为dict其实就是 2-tuple 的组合，所以dict函数能接受一组 2-tuple：</p>

<pre><code>mapping = dict(zip(range(5), reversed(range(5))))
mapping
</code></pre>

<p>输出：</p>

<pre><code>{0: 4, 1: 3, 2: 2, 3: 1, 4: 0}
</code></pre>

<h2 id="default-value-默认值">Default value(默认值)</h2>

<p>如果 dict 中某个 key 存在的话，就返回该 value，否则的话，就返回一个默认值：</p>

<pre><code>if key in some_dict:
    value = some_dict[key]
else:
    value = default_value
</code></pre>

<p>不过 dict 中的 get 和 pop 方法能设置默认值，即能把上面的代码简写为：</p>

<pre><code>value = some_dict.get(key, default_value)
</code></pre>

<p>如果key不存在的话，get方法默认会返回 None，而 pop 则会引发一个错误。</p>

<p>通过设定值，一个常用的场景是一个dict中的value也是其他集合，比如list。举例说明，我们想要把一些单词按首字母归类：</p>

<pre><code>words = ['apple', 'bat', 'bar', 'atom', 'book']
by_letter = {}
for word in words:
    letter = word[0]
    if letter not in by_letter:
        by_letter[letter] = [word]
    else:
        by_letter[letter].append(word)
print(by_letter)
</code></pre>

<p>输出：</p>

<pre><code>{'a': ['apple', 'atom'], 'b': ['bat', 'bar', 'book']}
</code></pre>

<p>而 setdefault 方法则是专门为这个用途存在的，上面的循环可以写为：==这个不知道==</p>

<pre><code>for word in words:
    letter = word[0]
    by_letter.setdefault(letter, []).append(word)
</code></pre>

<p>使用setdefault() 初始化字典键值. 使用字典的时候经常会遇到这样一种应用场景：动态更新字典，像如上面代码，如果 key 不在 dictionary 中那么就添加它并把它对应的值初始为空列表 [] ，然后把元素 append 到空列表中。</p>

<p>内建的 collections 模块有一个有用的 class，defaultdict，这个能让上述过程更简单。创建方法是传递一个type或是函数：==这个要注意==</p>

<pre><code>from collections import defaultdict
by_letter = defaultdict(list)
for word in words:
    by_letter[word[0]].append(word)
</code></pre>

<h2 id="valid-dict-key-types-有效的key类型">Valid dict key types (有效的key类型)</h2>

<p>通常 key 的类型是不可更改的常量类型（int，float，string）或tuple。专业的叫法是 hashability。可以查看一个object是否是hashable，只要是hashable的，就可以当做 dict 中的 key 。这里用 hash函数查看：</p>

<p>In [102]:</p>

<pre><code>print(hash('string'))
print(hash((1, 2, (2, 3))))
print(hash(1, 2, [2, 3])) # 失败，因为list是可变的
</code></pre>

<p>输出：</p>

<pre><code>-522944812555367519
1097636502276347782
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
&lt;ipython-input-105-b1f78f4caeda&gt; in &lt;module&gt;()
----&gt; 1 hash(1, 2, [2, 3]) # 失败，因为list是可变的

TypeError: hash() takes exactly one argument (3 given)
</code></pre>

<p>要想把list当做key的话，可以把list转变为tuple：</p>

<pre><code>d = {}
d[tuple([1, 2, 3])] = 5
print(d)
</code></pre>

<p>输出：</p>

<pre><code>{(1, 2, 3): 5}
</code></pre>

<h2 id="5-set-集合">5 Set 集合</h2>

<p>set是无序且元素不重复的。就像是key唯一，且没有value的字典。两种方式可以创建，一个是用set函数，一个是用花括号：</p>

<pre><code>print(set([2, 3, 2, 1, 4, 4, 3]))
print({2, 3, 2, 1, 4, 4, 3})
</code></pre>

<p>输出：</p>

<pre><code>{1, 2, 3, 4}
{1, 2, 3, 4}
</code></pre>

<p>集合的操作既然也支持，比如并集，交集，差集：</p>

<pre><code>a = {1, 2, 3, 4, 5}
b = {3, 4, 5, 6, 7, 8}
# 并集
a.union(b)
a | b
# 交集
a.intersection(b)
a &amp; b
</code></pre>

<p>输出：</p>

<pre><code>{1, 2, 3, 4, 5, 6, 7, 8}
{1, 2, 3, 4, 5, 6, 7, 8}
{3, 4, 5}
{3, 4, 5}
</code></pre>

<p>一些集合操作</p>

<p><img src="http://pacdb2bfr.bkt.clouddn.com/blog/image/180615/BmL8G1d58C.png?imageslim" alt="mark" /></p>

<p>上面这些逻辑操作都是直接更改 set 本身。如果是一个很大的 set ，下面的操作会更有效率：</p>

<pre><code>c = a.copy()
c |= b
print(c)
d = a.copy()
d &amp;= b
print(d)
</code></pre>

<p>输出：</p>

<pre><code>{1, 2, 3, 4, 5, 6, 7, 8}
{3, 4, 5}
</code></pre>

<p>set的元素必须是不可更改的。如果想要 list 一样的元素，只能变为 tuple：==嗯，要注意==</p>

<pre><code>my_data = [1, 2, 3, 4]
my_set = {tuple(my_data)}
print(my_set)
</code></pre>

<p>输出：</p>

<pre><code>{(1, 2, 3, 4)}
</code></pre>

<p>我们可以查看一个子集与父集的关系：</p>

<pre><code>a_set = {1, 2, 3, 4, 5}
{1, 2, 3}.issubset(a_set)
a_set.issuperset({1, 2, 3})
</code></pre>

<p>输出：</p>

<pre><code>True
True
</code></pre>

<h1 id="6-list-set-and-dict-comprehensions-推导式">6 List, Set, and Dict Comprehensions(推导式)</h1>

<p>list comprehension(列表推导式）是python里最受喜爱的一个特色。我们能简洁地构造一个list：</p>

<pre><code>[expr for val in collection if condiction]
</code></pre>

<p>相当于：</p>

<pre><code>result = []
for val in collection:
    if condition:
        result.append(expr)
</code></pre>

<p>比如，给定一个list，里面有很多string，我们只要留下string长度超过2的，并将其转换为大写：</p>

<pre><code>strings = ['a', 'as', 'bat', 'car', 'dove', 'python']
[x.upper() for x in strings if len(x) &gt; 2]
</code></pre>

<p>输出：</p>

<pre><code>['BAT', 'CAR', 'DOVE', 'PYTHON']
</code></pre>

<p>dict推导式：</p>

<p><code>dict_comp = {key-expr: value-expr for value in collection if condition}</code></p>

<p>set的推导式：</p>

<p><code>set_comp = {expr for value in collection if condition}</code></p>

<p>基于上面的例子，我们想要一个集合来保存string的长度：==嗯，原来还可以这样==</p>

<pre><code>unique_length = {len(x) for x in strings}
unique_length
</code></pre>

<p>输出：</p>

<pre><code>{1, 2, 3, 4, 6}
</code></pre>

<p>用map让表达更功能化一些：==是的，这样更明确==</p>

<pre><code>set(map(len, strings))
</code></pre>

<p>输出：</p>

<pre><code>{1, 2, 3, 4, 6}
</code></pre>

<p>一个简单而的字典表达式例子，string和其在list中对应的index：</p>

<pre><code>loc_mapping = {val: index for index, val in enumerate(strings)}
loc_mapping
</code></pre>

<p>输出：</p>

<pre><code>{'a': 0, 'as': 1, 'bat': 2, 'car': 3, 'dove': 4, 'python': 5}
</code></pre>

<h2 id="nested-list-comprehensions-嵌套列表表达式">Nested list comprehensions（嵌套列表表达式）</h2>

<p>假设我们有一个list，list中又有不同的list表示英语和西班牙语的姓名：</p>

<pre><code>all_data = [['John', 'Emily', 'Michael', 'Mary', 'Steven'], 
            ['Maria', 'Juan', 'Javier', 'Natalia', 'Pilar']]
</code></pre>

<p>我们想要按语言来组织这些名字。可以用一个for loop：</p>

<pre><code class="language-python">names_of_interest = []
for names in all_data:
    enough_es = [name for name in names if name.count('e') &gt;= 2]
    names_of_interest.extend(enough_es)
names_of_interest
</code></pre>

<p>输出：</p>

<pre><code>['Steven']
</code></pre>

<p>但是我们key用嵌套列表表达式写得更简洁一些：==没想到还可以这样！！从外层的循环到内层的循环==</p>

<pre><code class="language-python">result = [name for names in all_data for name in names if name.count('e') &gt;= 2]
result
</code></pre>

<p>输出：</p>

<pre><code>['Steven']
</code></pre>

<p>for 部分是根据嵌套的顺序来写的，从外层的 loop 到内层的 loop 。这里一个例子是把tuple扁平化成一个整数列表：</p>

<pre><code class="language-python">some_tuples = [(1, 2, 3), (4, 5, 6), (7, 8, 9)]
flattened = [x for tup in some_tuples for x in tup]
flattened
</code></pre>

<p>输出：</p>

<pre><code>[1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>

<p>一定要记住顺序是和我们写for loop一样的：</p>

<pre><code class="language-python">flatteded = []
for tup in some_tuples:
    for x in tup:
        flattened.append(x)
</code></pre>

<p>列表表达式里再有一个列表表达式也是可以的，可以生成 a list of lists：==嗯，这个也行==</p>

<pre><code class="language-python">[[x for x in tup] for tup in some_tuples]
</code></pre>

<p>输出：</p>

<pre><code>[[1, 2, 3], [4, 5, 6], [7, 8, 9]]
</code></pre>

    </div>

    
    

    
    

    <footer class="post-footer">
      

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02-python/01-%E5%9F%BA%E7%A1%80/python-%E5%9F%BA%E7%A1%80-03-%E5%87%BD%E6%95%B0/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Python 基础 03 函数</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/05-%E5%9F%BA%E7%A1%80%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/01-%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/02-linux-%E7%8E%AF%E5%A2%83/tmux/">
            <span class="next-text nav-default">tmux</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="iteratelyd@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="http://github.com/iterateself" class="iconfont icon-github" title="github"></a>
      <a href="https://www.zhihu.com/people/thebegin/activities" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="https://www.douban.com/people/68028070/" class="iconfont icon-douban" title="douban"></a>
  <a href="http://iterate.site/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> site pv: <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
    <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> site uv: <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2018
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">iterateself</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>


<script type="text/javascript" src="/dist/even.min.js?v=3.2.0"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>








</body>
</html>
