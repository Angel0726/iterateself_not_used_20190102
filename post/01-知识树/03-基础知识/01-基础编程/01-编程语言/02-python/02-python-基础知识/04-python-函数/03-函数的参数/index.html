<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title> - 迭代自己</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="iterateself" />
  <meta name="description" content="需要补充的 嗯，关于函数的参数，我还是想补充一些在情况的应用场景，不然单纯的理解可以怎么写，不是很明白为什么一定要用这些写法。嗯，需要补充一些" />

  <meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.47.1" />


<link rel="canonical" href="http://iterate.site/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02-python/02-python-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/04-python-%E5%87%BD%E6%95%B0/03-%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">




<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<link href="/dist/even.min.css?v=3.2.0" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">




<meta property="og:title" content="" />
<meta property="og:description" content="需要补充的 嗯，关于函数的参数，我还是想补充一些在情况的应用场景，不然单纯的理解可以怎么写，不是很明白为什么一定要用这些写法。嗯，需要补充一些" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://iterate.site/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02-python/02-python-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/04-python-%E5%87%BD%E6%95%B0/03-%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0/" />
<meta itemprop="name" content="">
<meta itemprop="description" content="需要补充的 嗯，关于函数的参数，我还是想补充一些在情况的应用场景，不然单纯的理解可以怎么写，不是很明白为什么一定要用这些写法。嗯，需要补充一些">



<meta itemprop="wordCount" content="5623">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content=""/>
<meta name="twitter:description" content="需要补充的 嗯，关于函数的参数，我还是想补充一些在情况的应用场景，不然单纯的理解可以怎么写，不是很明白为什么一定要用这些写法。嗯，需要补充一些"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">迭代自己</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">最新</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a><a href="/catalog/">
        <li class="mobile-menu-item">完整目录</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">迭代自己</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">最新</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/catalog/">完整目录</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title"></h1>

      <div class="post-meta">
        <span class="post-time"> 0001-01-01 </span>
        
        <span class="more-meta"> 5623 words </span>
        <span class="more-meta"> 12 mins read </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> times read </span>
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  
  <div class="post-toc-content">
    <nav id="TableOfContents">
<ul>
<li><a href="#需要补充的">需要补充的</a></li>
<li><a href="#函数的参数">函数的参数</a>
<ul>
<li>
<ul>
<li><a href="#位置参数">位置参数</a></li>
<li><a href="#默认参数">默认参数</a></li>
<li><a href="#可变参数">可变参数</a></li>
<li><a href="#关键字参数">关键字参数</a></li>
<li><a href="#命名关键字参数">命名关键字参数</a></li>
<li><a href="#参数组合">参数组合</a></li>
<li><a href="#小结">小结</a></li>
</ul></li>
</ul></li>
<li><a href="#相关资料">相关资料</a></li>
</ul>
</nav>
  </div>
</div>

    
    

    
    <div class="post-content">
      

<h1 id="需要补充的">需要补充的</h1>

<ul>
<li>嗯，关于函数的参数，我还是想补充一些在情况的应用场景，不然单纯的理解可以怎么写，不是很明白为什么一定要用这些写法。嗯，需要补充一些例子。</li>
</ul>

<h1 id="函数的参数">函数的参数</h1>

<p>定义函数的时候，我们把参数的名字和位置确定下来，函数的接口定义就完成了。对于函数的调用者来说，只需要知道如何传递正确的参数，以及函数将返回什么样的值就够了，函数内部的复杂逻辑被封装起来，调用者无需了解。<span style="color:red;">嗯，调用者怎么知道要怎么使用这个参数呢？函数内部的异常要怎么处理好呢？</span></p>

<p>Python的函数定义非常简单，但灵活度却非常大。除了正常定义的必选参数外，还可以使用默认参数、可变参数和关键字参数，使得函数定义出来的接口，不但能处理复杂的参数，还可以简化调用者的代码。</p>

<h3 id="位置参数">位置参数</h3>

<p>我们先写一个计算x2的函数：</p>

<pre><code>def power(x):
    return x * x
</code></pre>

<p>对于<code>power(x)</code>函数，参数<code>x</code>就是一个位置参数。</p>

<p>当我们调用<code>power</code>函数时，必须传入有且仅有的一个参数<code>x</code>：</p>

<pre><code>&gt;&gt;&gt; power(5)
25
&gt;&gt;&gt; power(15)
225
</code></pre>

<p>现在，如果我们要计算x3怎么办？可以再定义一个<code>power3</code>函数，但是如果要计算x4、x5……怎么办？我们不可能定义无限多个函数。</p>

<p>你也许想到了，可以把<code>power(x)</code>修改为<code>power(x, n)</code>，用来计算xn，说干就干：</p>

<pre><code>def power(x, n):
    s = 1
    while n &gt; 0:
        n = n - 1
        s = s * x
    return s
</code></pre>

<p>对于这个修改后的<code>power(x, n)</code>函数，可以计算任意n次方：</p>

<pre><code>&gt;&gt;&gt; power(5, 2)
25
&gt;&gt;&gt; power(5, 3)
125
</code></pre>

<p>修改后的<code>power(x, n)</code>函数有两个参数：<code>x</code>和<code>n</code>，这两个参数都是位置参数，调用函数时，传入的两个值按照位置顺序依次赋给参数<code>x</code>和<code>n</code>。</p>

<h3 id="默认参数">默认参数</h3>

<p>新的<code>power(x, n)</code>函数定义没有问题，但是，旧的调用代码失败了，原因是我们增加了一个参数，导致旧的代码因为缺少一个参数而无法正常调用：</p>

<pre><code>&gt;&gt;&gt; power(5)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: power() missing 1 required positional argument: 'n'
</code></pre>

<p>Python的错误信息很明确：调用函数<code>power()</code>缺少了一个位置参数<code>n</code>。</p>

<p>这个时候，默认参数就排上用场了。由于我们经常计算x2，所以，完全可以把第二个参数n的默认值设定为2：</p>

<pre><code>def power(x, n=2):
    s = 1
    while n &gt; 0:
        n = n - 1
        s = s * x
    return s
</code></pre>

<p>这样，当我们调用<code>power(5)</code>时，相当于调用<code>power(5, 2)</code>：</p>

<pre><code>&gt;&gt;&gt; power(5)
25
&gt;&gt;&gt; power(5, 2)
25
</code></pre>

<p>而对于<code>n &gt; 2</code>的其他情况，就必须明确地传入n，比如<code>power(5, 3)</code>。</p>

<p>从上面的例子可以看出，默认参数可以简化函数的调用。设置默认参数时，有几点要注意：</p>

<p>一是必选参数在前，默认参数在后，否则Python的解释器会报错（思考一下为什么默认参数不能放在必选参数前面）；
二是如何设置默认参数。</p>

<p>当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。<span style="color:red;">嗯，这样的排布，</span></p>

<p>使用默认参数有什么好处？最大的好处是能降低调用函数的难度。</p>

<p>举个例子，我们写个一年级小学生注册的函数，需要传入<code>name</code>和<code>gender</code>两个参数：</p>

<pre><code>def enroll(name, gender):
    print('name:', name)
    print('gender:', gender)
</code></pre>

<p>这样，调用<code>enroll()</code>函数只需要传入两个参数：</p>

<pre><code>&gt;&gt;&gt; enroll('Sarah', 'F')
name: Sarah
gender: F
</code></pre>

<p>如果要继续传入年龄、城市等信息怎么办？这样会使得调用函数的复杂度大大增加。</p>

<p>我们可以把年龄和城市设为默认参数：</p>

<pre><code>def enroll(name, gender, age=6, city='Beijing'):
    print('name:', name)
    print('gender:', gender)
    print('age:', age)
    print('city:', city)
</code></pre>

<p>这样，大多数学生注册时不需要提供年龄和城市，只提供必须的两个参数：</p>

<pre><code>&gt;&gt;&gt; enroll('Sarah', 'F')
name: Sarah
gender: F
age: 6
city: Beijing
</code></pre>

<p>只有与默认参数不符的学生才需要提供额外的信息：</p>

<pre><code>enroll('Bob', 'M', 7)
enroll('Adam', 'M', city='Tianjin')
</code></pre>

<p>可见，默认参数降低了函数调用的难度，而一旦需要更复杂的调用时，又可以传递更多的参数来实现。无论是简单调用还是复杂调用，函数只需要定义一个。</p>

<p>有多个默认参数时，调用的时候，既可以按顺序提供默认参数，比如调用<code>enroll('Bob', 'M', 7)</code>，意思是，除了<code>name</code>，<code>gender</code>这两个参数外，最后1个参数应用在参数<code>age</code>上，<code>city</code>参数由于没有提供，仍然使用默认值。</p>

<p>也可以不按顺序提供部分默认参数。当不按顺序提供部分默认参数时，需要把参数名写上。比如调用<code>enroll('Adam', 'M', city='Tianjin')</code>，意思是，<code>city</code>参数用传进去的值，其他默认参数继续使用默认值。</p>

<p>默认参数很有用，但使用不当，也会掉坑里。默认参数有个最大的坑，演示如下：</p>

<p>先定义一个函数，传入一个list，添加一个<code>END</code>再返回：</p>

<pre><code>def add_end(L=[]):
    L.append('END')
    return L
</code></pre>

<p>当你正常调用时，结果似乎不错：</p>

<pre><code>&gt;&gt;&gt; add_end([1, 2, 3])
[1, 2, 3, 'END']
&gt;&gt;&gt; add_end(['x', 'y', 'z'])
['x', 'y', 'z', 'END']
</code></pre>

<p>当你使用默认参数调用时，一开始结果也是对的：</p>

<pre><code>&gt;&gt;&gt; add_end()
['END']
</code></pre>

<p>但是，再次调用<code>add_end()</code>时，结果就不对了：</p>

<pre><code>&gt;&gt;&gt; add_end()
['END', 'END']
&gt;&gt;&gt; add_end()
['END', 'END', 'END']
</code></pre>

<p><span style="color:red;">哇塞，这个问题！嗯，之前看到的时候就挺震惊的，但是忘记了，现在又看到了。</span></p>

<p>很多初学者很疑惑，默认参数是<code>[]</code>，但是函数似乎每次都“记住了”上次添加了<code>'END'</code>后的list。</p>

<p>原因解释如下：</p>

<p>Python函数在定义的时候，默认参数<code>L</code>的值就被计算出来了，即<code>[]</code>，因为默认参数<code>L</code>也是一个变量，它指向对象<code>[]</code>，每次调用该函数，如果改变了<code>L</code>的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的<code>[]</code>了。<span style="color:red;">是的呀。但是我在想，为什么 L 在函数调用完成后没有释放掉？而是在下次调用的时候又使用了？</span></p>

<p>因此，定义默认参数要牢记一点：默认参数必须指向不变对象！！<span style="color:red;">嗯，要注意！！</span></p>

<p>嗯，对应上面的问题，实验如下：</p>

<p>当：</p>

<pre><code class="language-py">def add_end(L=[]):
    L.append(&quot;end&quot;)
    return L

print(add_end([1,2]))
print(add_end())
</code></pre>

<p>输出：</p>

<pre><code>[1, 2, 'end']
['end']
</code></pre>

<p>当：</p>

<pre><code class="language-py">def add_end(L=[]):
    L.append(&quot;end&quot;)
    return L

print(add_end())
print(add_end())
</code></pre>

<p>输出：</p>

<pre><code>['end']
['end', 'end']
</code></pre>

<p><span style="color:red;">哦，总的来说是这样的，当传入 <code>[1,2]</code> 的时候，L 的值被改变了，指向了 <code>[1,2]</code>，然后再调用 <code>add_end()</code> 的时候，<code>L</code> 的值又被改变成指向了一个新的 <code>[]</code>，但是，如果连续两个 <code>add_end()</code> ，那么第一个 <code>add_end()</code> 的时候 <code>L=[&quot;end&quot;]</code>，然后第二个 <code>add_end()</code> 的时候，实际上这个 <code>L</code> 还是指向的刚才的 <code>[&quot;end&quot;]</code>，所以，会继续添加 <code>&quot;end&quot;</code>。 嗯，没想到，这种简单的操作中也因为底层的机制导致一些存在问题的可能性。</span></p>

<p>要修改上面的例子，我们可以用<code>None</code>这个不变对象来实现：<span style="color:red;">哦，是的，这就是为什么经常看到类库中的参数的默认值是 None ，很可能就是想要对应这个问题。</span></p>

<pre><code class="language-py">def add_end(L=None):
    if L is None:
        L = []
    L.append('END')
    return L
</code></pre>

<p><span style="color:red;">机智的处理！ </span></p>

<p>现在，无论调用多少次，都不会有问题：</p>

<pre><code>&gt;&gt;&gt; add_end()
['END']
&gt;&gt;&gt; add_end()
['END']
</code></pre>

<p>为什么要设计<code>str</code>、<code>None</code>这样的不变对象呢？因为不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。我们在编写程序时，如果可以设计一个不变对象，那就尽量设计成不变对象。<span style="color:red;">嗯，同时读的时候不用加锁，的确是好的，但是写的时候还是要加锁的。嗯，如果可以设计成一个不变对象，那么就尽量设计成一个不变对象。</span></p>

<h3 id="可变参数">可变参数</h3>

<p>在Python函数中，还可以定义可变参数。顾名思义，可变参数就是传入的参数个数是可变的，可以是 1 个、2 个到任意个，还可以是 0 个。</p>

<p>我们以数学题为例子，给定一组数字a，b，c……，请计算a2 + b2 + c2 + ……。</p>

<p>要定义出这个函数，我们必须确定输入的参数。由于参数个数不确定，我们首先想到可以把a，b，c……作为一个list或tuple传进来，这样，函数可以定义如下：</p>

<pre><code class="language-py">def calc(numbers):
    sum = 0
    for n in numbers:
        sum = sum + n * n
    return sum
</code></pre>

<p>但是调用的时候，需要先组装出一个 list 或 tuple：</p>

<pre><code class="language-py">&gt;&gt;&gt; calc([1, 2, 3])
14
&gt;&gt;&gt; calc((1, 3, 5, 7))
84
</code></pre>

<p>如果利用可变参数，调用函数的方式可以简化成这样：</p>

<pre><code class="language-py">&gt;&gt;&gt; calc(1, 2, 3)
14
&gt;&gt;&gt; calc(1, 3, 5, 7)
84
</code></pre>

<p>所以，我们把函数的参数改为可变参数：</p>

<pre><code class="language-py">def calc(*numbers):
    sum = 0
    for n in numbers:
        sum = sum + n * n
    return sum
</code></pre>

<p><span style="color:red;">嗯，说实话，可变参数的函数还是比较少用到的。</span></p>

<p>定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个<code>*</code>号。在函数内部，参数<code>numbers</code>接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数：<span style="color:red;">嗯，下次用到的时候，在这里做个标记，来看看是什么场景下使用的。</span></p>

<pre><code>&gt;&gt;&gt; calc(1, 2)
5
&gt;&gt;&gt; calc()
0
</code></pre>

<p>如果已经有一个list或者tuple，要调用一个可变参数怎么办？可以这样做：</p>

<pre><code>&gt;&gt;&gt; nums = [1, 2, 3]
&gt;&gt;&gt; calc(nums[0], nums[1], nums[2])
14
</code></pre>

<p>这种写法当然是可行的，问题是太繁琐，所以Python允许你在list或tuple前面加一个<code>*</code>号，把list或tuple的元素变成可变参数传进去：</p>

<pre><code>&gt;&gt;&gt; nums = [1, 2, 3]
&gt;&gt;&gt; calc(*nums)
14
</code></pre>

<p><span style="color:red;">嗯，这个之前看书看到过，但是又忘记了。</span></p>

<p><code>*nums</code> 表示把 <code>nums</code> 这个list的所有元素作为可变参数传进去。这种写法相当有用，而且很常见。<span style="color:red;">嗯，还是想知道使用的场景是什么，而且，为什么说很常见呢？实际上，没有觉得这个比直接传 list 进去好在哪里。。嗯，还是有点不透彻。</span></p>

<h3 id="关键字参数">关键字参数</h3>

<p>可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。请看示例：<span style="color:red;">嗯，还是想知道应用场景。单单讲这个有点浮在空中的感觉。没有什么依附</span></p>

<pre><code>def person(name, age, **kw):
    print('name:', name, 'age:', age, 'other:', kw)
</code></pre>

<p>函数<code>person</code>除了必选参数<code>name</code>和<code>age</code>外，还接受关键字参数<code>kw</code>。在调用该函数时，可以只传入必选参数：</p>

<pre><code>&gt;&gt;&gt; person('Michael', 30)
name: Michael age: 30 other: {}
</code></pre>

<p>也可以传入任意个数的关键字参数：</p>

<pre><code>&gt;&gt;&gt; person('Bob', 35, city='Beijing')
name: Bob age: 35 other: {'city': 'Beijing'}
&gt;&gt;&gt; person('Adam', 45, gender='M', job='Engineer')
name: Adam age: 45 other: {'gender': 'M', 'job': 'Engineer'}
</code></pre>

<p>关键字参数有什么用？它可以扩展函数的功能。比如，在<code>person</code>函数里，我们保证能接收到<code>name</code>和<code>age</code>这两个参数，但是，如果调用者愿意提供更多的参数，我们也能收到。试想你正在做一个用户注册的功能，除了用户名和年龄是必填项外，其他都是可选项，利用关键字参数来定义这个函数就能满足注册的需求。<span style="color:red;">但是，普通的对应方式不是也可以对应吗？为什么一定要这样对应？</span></p>

<p>和可变参数类似，也可以先组装出一个dict，然后，把该dict转换为关键字参数传进去：</p>

<pre><code>&gt;&gt;&gt; extra = {'city': 'Beijing', 'job': 'Engineer'}
&gt;&gt;&gt; person('Jack', 24, city=extra['city'], job=extra['job'])
name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}
</code></pre>

<p>当然，上面复杂的调用可以用简化的写法：</p>

<pre><code>&gt;&gt;&gt; extra = {'city': 'Beijing', 'job': 'Engineer'}
&gt;&gt;&gt; person('Jack', 24, **extra)
name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}
</code></pre>

<p><span style="color:red;">嗯。</span></p>

<p><code>**extra</code>表示把<code>extra</code>这个dict的所有key-value用关键字参数传入到函数的<code>**kw</code>参数，<code>kw</code>将获得一个dict，注意<code>kw</code>获得的dict是<code>extra</code>的一份拷贝，对<code>kw</code>的改动不会影响到函数外的<code>extra</code>。</p>

<h3 id="命名关键字参数">命名关键字参数</h3>

<p>对于关键字参数，函数的调用者可以传入任意不受限制的关键字参数。至于到底传入了哪些，就需要在函数内部通过<code>kw</code>检查。</p>

<p>仍以<code>person()</code>函数为例，我们希望检查是否有<code>city</code>和<code>job</code>参数：</p>

<pre><code>def person(name, age, **kw):
    if 'city' in kw:
        # 有city参数
        pass
    if 'job' in kw:
        # 有job参数
        pass
    print('name:', name, 'age:', age, 'other:', kw)
</code></pre>

<p>但是调用者仍可以传入不受限制的关键字参数：</p>

<pre><code>&gt;&gt;&gt; person('Jack', 24, city='Beijing', addr='Chaoyang', zipcode=123456)
</code></pre>

<p>如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收<code>city</code>和<code>job</code>作为关键字参数。这种方式定义的函数如下：</p>

<pre><code>def person(name, age, *, city, job):
    print(name, age, city, job)
</code></pre>

<p>和关键字参数<code>**kw</code>不同，命名关键字参数需要一个特殊分隔符<code>*</code>，<code>*</code>后面的参数被视为命名关键字参数。<span style="color:red;">这个好像之前没有什么印象，这个一般应用在什么时候呢？</span></p>

<p>调用方式如下：</p>

<pre><code>&gt;&gt;&gt; person('Jack', 24, city='Beijing', job='Engineer')
Jack 24 Beijing Engineer
</code></pre>

<p>如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符<code>*</code>了：</p>

<pre><code>def person(name, age, *args, city, job):
    print(name, age, args, city, job)
</code></pre>

<p>命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错：</p>

<pre><code>&gt;&gt;&gt; person('Jack', 24, 'Beijing', 'Engineer')
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: person() takes 2 positional arguments but 4 were given
</code></pre>

<p>由于调用时缺少参数名<code>city</code>和<code>job</code>，Python解释器把这4个参数均视为位置参数，但<code>person()</code>函数仅接受2个位置参数。</p>

<p>命名关键字参数可以有缺省值，从而简化调用：</p>

<pre><code>def person(name, age, *, city='Beijing', job):
    print(name, age, city, job)
</code></pre>

<p>由于命名关键字参数<code>city</code>具有默认值，调用时，可不传入<code>city</code>参数：</p>

<pre><code>&gt;&gt;&gt; person('Jack', 24, job='Engineer')
Jack 24 Beijing Engineer
</code></pre>

<p>使用命名关键字参数时，要特别注意，如果没有可变参数，就必须加一个<code>*</code>作为特殊分隔符。如果缺少<code>*</code>，Python解释器将无法识别位置参数和命名关键字参数：<span style="color:red;">嗯，但是为什么 python 要做出这种机制呢？</span></p>

<pre><code class="language-py">def person(name, age, city, job):
    # 缺少 *，city和job被视为位置参数
    pass
</code></pre>

<h3 id="参数组合">参数组合</h3>

<p>在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。<span style="color:red;">嗯，这个要知道。</span></p>

<p>比如定义一个函数，包含上述若干种参数：</p>

<pre><code class="language-py">def f1(a, b, c=0, *args, **kw):
    print('a =', a, 'b =', b, 'c =', c, 'args =', args, 'kw =', kw)

def f2(a, b, c=0, *, d, **kw):
    print('a =', a, 'b =', b, 'c =', c, 'd =', d, 'kw =', kw)
</code></pre>

<p>在函数调用的时候，Python解释器自动按照参数位置和参数名把对应的参数传进去。</p>

<pre><code class="language-py">&gt;&gt;&gt; f1(1, 2)
a = 1 b = 2 c = 0 args = () kw = {}
&gt;&gt;&gt; f1(1, 2, c=3)
a = 1 b = 2 c = 3 args = () kw = {}
&gt;&gt;&gt; f1(1, 2, 3, 'a', 'b')
a = 1 b = 2 c = 3 args = ('a', 'b') kw = {}
&gt;&gt;&gt; f1(1, 2, 3, 'a', 'b', x=99)
a = 1 b = 2 c = 3 args = ('a', 'b') kw = {'x': 99}
&gt;&gt;&gt; f2(1, 2, d=99, ext=None)
a = 1 b = 2 c = 0 d = 99 kw = {'ext': None}
</code></pre>

<p>最神奇的是通过一个tuple和dict，你也可以调用上述函数：</p>

<pre><code class="language-py">&gt;&gt;&gt; args = (1, 2, 3, 4)
&gt;&gt;&gt; kw = {'d': 99, 'x': '#'}
&gt;&gt;&gt; f1(*args, **kw)
a = 1 b = 2 c = 3 args = (4,) kw = {'d': 99, 'x': '#'}
&gt;&gt;&gt; args = (1, 2, 3)
&gt;&gt;&gt; kw = {'d': 88, 'x': '#'}
&gt;&gt;&gt; f2(*args, **kw)
a = 1 b = 2 c = 3 d = 88 kw = {'x': '#'}
</code></pre>

<p>所以，对于任意函数，都可以通过类似 <code>func(*args, **kw)</code> 的形式调用它，无论它的参数是如何定义的。<span style="color:red;">好吧，有点牛逼</span></p>

<p>虽然可以组合多达5种参数，但不要同时使用太多的组合，否则函数接口的可理解性很差。<span style="color:red;">是呀。</span></p>

<h3 id="小结">小结</h3>

<p>Python的函数具有非常灵活的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。</p>

<p>默认参数一定要用不可变对象，如果是可变对象，程序运行时会有逻辑错误！<span style="color:red;">嗯。</span></p>

<p>要注意定义可变参数和关键字参数的语法：</p>

<p><code>*args</code>是可变参数，args接收的是一个tuple；</p>

<p><code>**kw</code>是关键字参数，kw接收的是一个dict。</p>

<p>以及调用函数时如何传入可变参数和关键字参数的语法：</p>

<p>可变参数既可以直接传入：<code>func(1, 2, 3)</code>，又可以先组装list或tuple，再通过<code>*args</code>传入：<code>func(*(1, 2, 3))</code>；</p>

<p>关键字参数既可以直接传入：<code>func(a=1, b=2)</code>，又可以先组装dict，再通过<code>**kw</code>传入：<code>func(**{'a': 1, 'b': 2})</code>。</p>

<p>使用<code>*args</code>和<code>**kw</code>是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。<span style="color:red;">哦，还有这么一个约定俗成的用法。</span></p>

<p>命名的关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。</p>

<p>定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符<code>*</code>，否则定义的将是位置参数。<span style="color:red;">嗯。</span></p>

<h1 id="相关资料">相关资料</h1>

<ul>
<li><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431752945034eb82ac80a3e64b9bb4929b16eeed1eb9000">函数的参数</a></li>
</ul>

    </div>

    
    

    
    

    <footer class="post-footer">
      

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02-python/02-python-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/04-python-%E5%87%BD%E6%95%B0/02-%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default"></span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02-python/02-python-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/04-python-%E5%87%BD%E6%95%B0/04-%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0/">
            <span class="next-text nav-default"></span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="iteratelyd@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="http://github.com/iterateself" class="iconfont icon-github" title="github"></a>
      <a href="https://www.zhihu.com/people/thebegin/activities" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="https://www.douban.com/people/68028070/" class="iconfont icon-douban" title="douban"></a>
  <a href="http://iterate.site/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> site pv: <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
    <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> site uv: <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2018
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">iterateself</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>


<script type="text/javascript" src="/dist/even.min.js?v=3.2.0"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>








</body>
</html>
