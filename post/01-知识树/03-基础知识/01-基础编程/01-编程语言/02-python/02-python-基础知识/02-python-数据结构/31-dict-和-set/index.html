<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title> - 迭代自己</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="iterateself" />
  <meta name="description" content="需要补充的 感觉这个讲的不是很细致，而且缺乏一些应用场景的例子的讲解，还是要多补充一下的。 dict Python内置了字典：dict的支持，dict 全" />

  <meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.47.1" />


<link rel="canonical" href="http://iterate.site/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02-python/02-python-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/02-python-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/31-dict-%E5%92%8C-set/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">




<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<link href="/dist/even.min.css?v=3.2.0" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">




<meta property="og:title" content="" />
<meta property="og:description" content="需要补充的 感觉这个讲的不是很细致，而且缺乏一些应用场景的例子的讲解，还是要多补充一下的。 dict Python内置了字典：dict的支持，dict 全" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://iterate.site/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02-python/02-python-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/02-python-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/31-dict-%E5%92%8C-set/" />
<meta itemprop="name" content="">
<meta itemprop="description" content="需要补充的 感觉这个讲的不是很细致，而且缺乏一些应用场景的例子的讲解，还是要多补充一下的。 dict Python内置了字典：dict的支持，dict 全">



<meta itemprop="wordCount" content="3562">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content=""/>
<meta name="twitter:description" content="需要补充的 感觉这个讲的不是很细致，而且缺乏一些应用场景的例子的讲解，还是要多补充一下的。 dict Python内置了字典：dict的支持，dict 全"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">迭代自己</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">最新</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a><a href="/catalog/">
        <li class="mobile-menu-item">完整目录</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">迭代自己</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">最新</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/catalog/">完整目录</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title"></h1>

      <div class="post-meta">
        <span class="post-time"> 0001-01-01 </span>
        
        <span class="more-meta"> 3562 words </span>
        <span class="more-meta"> 8 mins read </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> times read </span>
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  
  <div class="post-toc-content">
    <nav id="TableOfContents">
<ul>
<li><a href="#需要补充的">需要补充的</a></li>
<li><a href="#dict">dict</a>
<ul>
<li>
<ul>
<li><a href="#set">set</a></li>
<li><a href="#再议不可变对象">再议不可变对象</a></li>
<li><a href="#小结">小结</a></li>
</ul></li>
</ul></li>
<li><a href="#相关资料">相关资料</a></li>
</ul>
</nav>
  </div>
</div>

    
    

    
    <div class="post-content">
      

<h1 id="需要补充的">需要补充的</h1>

<ul>
<li>感觉这个讲的不是很细致，而且缺乏一些应用场景的例子的讲解，还是要多补充一下的。</li>
</ul>

<h1 id="dict">dict</h1>

<p>Python内置了字典：dict的支持，dict 全称 dictionary，在其他语言中也称为 map，使用键-值（key-value）存储，具有极快的查找速度。</p>

<p>举个例子，假设要根据同学的名字查找对应的成绩，如果用list实现，需要两个list：</p>

<pre><code class="language-py">names = ['Michael', 'Bob', 'Tracy']
scores = [95, 75, 85]
</code></pre>

<p>给定一个名字，要查找对应的成绩，就先要在names中找到对应的位置，再从scores取出对应的成绩，list越长，耗时越长。</p>

<p>如果用dict实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。用 Python 写一个 dict 如下：<span style="color:red;">这个无论这个表有多大，查找速度都不会变慢，还是要理解下的，这个特性可以用在什么地方呢？而且，这个背后是怎么实现的？</span></p>

<pre><code class="language-py">&gt;&gt;&gt; d = {'Michael': 95, 'Bob': 75, 'Tracy': 85}
&gt;&gt;&gt; d['Michael']
95
</code></pre>

<p>为什么dict查找速度这么快？因为dict的实现原理和查字典是一样的。假设字典包含了1万个汉字，我们要查某一个字，一个办法是把字典从第一页往后翻，直到找到我们想要的字为止，这种方法就是在list中查找元素的方法，list越大，查找越慢。</p>

<p>第二种方法是先在字典的索引表里（比如部首表）查这个字对应的页码，然后直接翻到该页，找到这个字。无论找哪个字，这种查找速度都非常快，不会随着字典大小的增加而变慢。</p>

<p>dict 就是第二种实现方式，给定一个名字，比如 <code>'Michael'</code>，dict在内部就可以直接计算出<code>Michael</code>对应的存放成绩的“页码”，也就是<code>95</code>这个数字存放的内存地址，直接取出来，所以速度非常快。</p>

<p>你可以猜到，这种 key-value 存储方式，在放进去的时候，必须根据key算出value的存放位置，这样，取的时候才能根据key直接拿到value。</p>

<p>把数据放入dict的方法，除了初始化时指定外，还可以通过key放入：</p>

<pre><code class="language-py">&gt;&gt;&gt; d['Adam'] = 67
&gt;&gt;&gt; d['Adam']
67
</code></pre>

<p>由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：</p>

<pre><code class="language-py">&gt;&gt;&gt; d['Jack'] = 90
&gt;&gt;&gt; d['Jack']
90
&gt;&gt;&gt; d['Jack'] = 88
&gt;&gt;&gt; d['Jack']
88
</code></pre>

<p>如果key不存在，dict就会报错：</p>

<pre><code>&gt;&gt;&gt; d['Thomas']
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
KeyError: 'Thomas'
</code></pre>

<p>要避免key不存在的错误，有两种办法，一是通过<code>in</code>判断key是否存在：<span style="color:red;">这个还是要注意使用的，如果不使用，还是不够严密的。</span></p>

<pre><code class="language-py">&gt;&gt;&gt; 'Thomas' in d
False
</code></pre>

<p>二是通过dict提供的<code>get()</code>方法，如果key不存在，可以返回<code>None</code>，或者自己指定的value：<span style="color:red;">嗯，这个更好，但是之前在 C++ 的时候已经习惯使用 <code>d[&quot;Tomas&quot;]</code> 这样的方式了。。嗯，还是要用 get 的方式，这样更加稳妥点，同时也能从字面上知道出现问题的时候返回的是什么。</span></p>

<pre><code class="language-py">&gt;&gt;&gt; d.get('Thomas')
&gt;&gt;&gt; d.get('Thomas', -1)
-1
</code></pre>

<p>注意：返回<code>None</code>的时候Python的交互环境不显示结果。<span style="color:red;">一直想知道，对于这种 None 的结果要怎么进行处理？python 好像特别喜欢返回 None 的结果。</span></p>

<p>要删除一个key，用 <code>pop(key)</code> 方法，对应的 value 也会从 dict 中删除：<span style="color:red;">哇塞，之前好像没有见到过这种，嗯，这种一般的应用的地方是什么？嗯，下次还是要想一下这个使用的时候是啥样的。</span></p>

<pre><code class="language-py">&gt;&gt;&gt; d.pop('Bob')
75
&gt;&gt;&gt; d
{'Michael': 95, 'Tracy': 85}
</code></pre>

<p>请务必注意，dict内部存放的顺序和key放入的顺序是没有关系的。<span style="color:red;">嗯，这个之前在别的地方看到过，嗯，这里又强调了下。</span></p>

<p>和list比较，dict有以下几个特点：</p>

<ol>
<li>查找和插入的速度极快，不会随着key的增加而变慢；</li>
<li>需要占用大量的内存，内存浪费多。 <span style="color:red;">嗯，这个倒是哦</span></li>
</ol>

<p>而list相反：</p>

<ol>
<li>查找和插入的时间随着元素的增加而增加；</li>
<li>占用空间小，浪费内存很少。</li>
</ol>

<p>所以，dict 是用空间来换取时间的一种方法。</p>

<p>dict 可以用在需要高速查找的很多地方，在 Python 代码中几乎无处不在，正确使用dict非常重要，需要牢记的第一条就是dict的key必须是<strong>不可变对象</strong>。<span style="color:red;">非常想知道高速查找的那些场景中使用了 dict ，到底是怎么使用的？还是要看下这方面的例子，对于 dict 还是要有更深的额理解。tuple 可以作为 key 吗？不知道有没有 tuple 作为 key 的例子。</span></p>

<p>这是因为 dict 根据 key 来计算value的存储位置，如果每次计算相同的 key 得出的结果不同，那 dict 内部就完全混乱了。这个通过 key 计算位置的算法称为哈希算法（Hash）。<span style="color:red;">嗯，对于 hash 还是要在理解下的，之前有些理解，但是还是想更深刻理解下的。以及现在的 hash 算法有没有什么发展，应用场景有没有什么新的场景。</span></p>

<p>要保证hash的正确性，作为key的对象就不能变。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key：<span style="color:red;">tuple 可以作为 key 吗？</span></p>

<pre><code class="language-py">&gt;&gt;&gt; key = [1, 2, 3]
&gt;&gt;&gt; d[key] = 'a list'
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: unhashable type: 'list'
</code></pre>

<p>下面看下这个例子：</p>

<pre><code class="language-py">b={1:'a',2:'dd'}
print(type(b))
print(b)
b={(1,2,3):'a',2:'bb'}
print(b)
b={(1,[1,2],3):'a',2:'bb'}
print(b)
</code></pre>

<p>输出：</p>

<pre><code>&lt;class 'dict'&gt;
{1: 'a', 2: 'dd'}
{(1, 2, 3): 'a', 2: 'bb'}
Traceback (most recent call last):
  File &quot;&lt;input&gt;&quot;, line 1, in &lt;module&gt;
  File &quot;D:\11.program_files\PyCharm 2018.3.1\helpers\pydev\_pydev_bundle\pydev_umd.py&quot;, line 198, in runfile
    pydev_imports.execfile(filename, global_vars, local_vars)  # execute the script
  File &quot;D:\11.program_files\PyCharm 2018.3.1\helpers\pydev\_pydev_imps\_pydev_execfile.py&quot;, line 18, in execfile
    exec(compile(contents+&quot;\n&quot;, file, 'exec'), glob, loc)
  File &quot;D:/03.software/learn_opencv/l.py&quot;, line 7, in &lt;module&gt;
    b={(1,[1,2],3):'a',2:'bb'}
TypeError: unhashable type: 'list'
</code></pre>

<p><span style="color:red;">嗯，可见，纯粹的 tuple 是可以作为 dict 的 key 的，但是含有 list 的 tuple 是不能作为 key 的。</span></p>

<h3 id="set">set</h3>

<p>set 和 dict 类似，也是一组 key 的集合，但不存储value。由于 key 不能重复，所以，在set中，没有重复的 key。</p>

<p>要创建一个 set，需要提供一个 list 作为输入集合：</p>

<pre><code class="language-py">&gt;&gt;&gt; s = set([1, 2, 3])
&gt;&gt;&gt; s
{1, 2, 3}
</code></pre>

<p>注意，传入的参数<code>[1, 2, 3]</code>是一个list，而显示的<code>{1, 2, 3}</code>只是告诉你这个set内部有1，2，3这3个元素，显示的顺序也不表示set是有序的。。<span style="color:red;">嗯。</span></p>

<p>看下下面这个例子：</p>

<pre><code class="language-py">a = set([(1, 2, 3), (1, 2, 3), 3])
print(a)
a = set([(1, [1,2], 3), (1, 2, 3), 3])
print(a)
</code></pre>

<p>输出：</p>

<pre><code>{3, (1, 2, 3)}
Traceback (most recent call last):
  File &quot;&lt;input&gt;&quot;, line 1, in &lt;module&gt;
  File &quot;D:\11.program_files\PyCharm 2018.3.1\helpers\pydev\_pydev_bundle\pydev_umd.py&quot;, line 198, in runfile
    pydev_imports.execfile(filename, global_vars, local_vars)  # execute the script
  File &quot;D:\11.program_files\PyCharm 2018.3.1\helpers\pydev\_pydev_imps\_pydev_execfile.py&quot;, line 18, in execfile
    exec(compile(contents+&quot;\n&quot;, file, 'exec'), glob, loc)
  File &quot;D:/03.software/learn_opencv/l.py&quot;, line 3, in &lt;module&gt;
    a = set([(1, [1,2], 3), (1, 2, 3), 3])
TypeError: unhashable type: 'list'
</code></pre>

<p><span style="color:red;">嗯，可见，纯粹的 tuple 是可以作为 set 的 key 的，但是里面含有 list 的 tuple 是无法作为 key 被 hash 的。</span></p>

<p>重复元素在set中自动被过滤：</p>

<pre><code>&gt;&gt;&gt; s = set([1, 1, 2, 2, 3, 3])
&gt;&gt;&gt; s
{1, 2, 3}
</code></pre>

<p>通过<code>add(key)</code>方法可以添加元素到set中，可以重复添加，但不会有效果：</p>

<pre><code>&gt;&gt;&gt; s.add(4)
&gt;&gt;&gt; s
{1, 2, 3, 4}
&gt;&gt;&gt; s.add(4)
&gt;&gt;&gt; s
{1, 2, 3, 4}
</code></pre>

<p>通过<code>remove(key)</code>方法可以删除元素：</p>

<pre><code>&gt;&gt;&gt; s.remove(4)
&gt;&gt;&gt; s
{1, 2, 3}
</code></pre>

<p>set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作：</p>

<pre><code class="language-py">&gt;&gt;&gt; s1 = set([1, 2, 3])
&gt;&gt;&gt; s2 = set([2, 3, 4])
&gt;&gt;&gt; s1 &amp; s2
{2, 3}
&gt;&gt;&gt; s1 | s2
{1, 2, 3, 4}
</code></pre>

<p><span style="color:red;">对于集合，之前只是在文字识别的时候，想在识别错误的时候尽可能匹配到对应的字符串的时候用到过，感觉平时的时候很少会使用到这个。嗯，用来去重好像也不错。</span></p>

<p>set和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证 set 内部“不会有重复元素”。试试把list放入set，看看是否会报错。<span style="color:red;">嗯，也不能放可变对象。</span></p>

<h3 id="再议不可变对象">再议不可变对象</h3>

<p>上面我们讲了，str是不变对象，而list是可变对象。<span style="color:red;">嗯，关于这一点再强调下，str 是不可变的对象，平时我们用的时候，感觉它好像也是可以修改的，但是实际上是用了一个新的 str 代替了旧的 str </span></p>

<p>对于可变对象，比如 list，对 list 进行操作，list 内部的内容是会变化的，比如：</p>

<pre><code class="language-py">&gt;&gt;&gt; a = ['c', 'b', 'a']
&gt;&gt;&gt; a.sort()
&gt;&gt;&gt; a
['a', 'b', 'c']
</code></pre>

<p><span style="color:red;">好像很少用到 a.sort() 来对列表进行排序。</span></p>

<p>而对于不可变对象，比如str，对str进行操作呢：</p>

<pre><code class="language-py">&gt;&gt;&gt; a = 'abc'
&gt;&gt;&gt; a.replace('a', 'A')
'Abc'
&gt;&gt;&gt; a
'abc'
</code></pre>

<p>虽然字符串有个<code>replace()</code>方法，也确实变出了<code>'Abc'</code>，但变量<code>a</code>最后仍是<code>'abc'</code>，应该怎么理解呢？<span style="color:red;">嗯，这个地方要注意的。</span></p>

<p>我们先把代码改成下面这样：</p>

<pre><code class="language-py">a = 'abc'
b = a.replace('a', 'A')
print(b)
print(a)
</code></pre>

<p>输出：</p>

<pre><code>Abc
abc
</code></pre>

<p>要始终牢记的是，<code>a</code>是变量，而<code>'abc'</code>才是字符串对象！有些时候，我们经常说，对象<code>a</code>的内容是<code>'abc'</code>，但其实是指，<code>a</code>本身是一个变量，它指向的对象的内容才是<code>'abc'</code>：<span style="color:red;">是的，这一点</span></p>

<pre><code class="language-ascii">┌───┐                  ┌───────┐
│ a │─────────────────&gt;│ 'abc' │
└───┘                  └───────┘
</code></pre>

<p>当我们调用<code>a.replace('a', 'A')</code>时，实际上调用方法<code>replace</code>是作用在字符串对象<code>'abc'</code>上的，而这个方法虽然名字叫<code>replace</code>，但却没有改变字符串<code>'abc'</code>的内容。相反，<code>replace</code>方法创建了一个新字符串<code>'Abc'</code>并返回，如果我们用变量<code>b</code>指向该新字符串，就容易理解了，变量<code>a</code>仍指向原有的字符串<code>'abc'</code>，但变量<code>b</code>却指向新字符串<code>'Abc'</code>了：<span style="color:red;"><code>replace</code>方法创建了一个新字符串<code>'Abc'</code>并返回，嗯。</span></p>

<pre><code class="language-ascii">┌───┐                  ┌───────┐
│ a │─────────────────&gt;│ 'abc' │
└───┘                  └───────┘
┌───┐                  ┌───────┐
│ b │─────────────────&gt;│ 'Abc' │
└───┘                  └───────┘
</code></pre>

<p>所以，对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。<span style="color:red;">是的，这种机制保证了不变对象本身永远是不变的。关于这一点的理解可以在有些时候明白一些困惑。</span></p>

<h3 id="小结">小结</h3>

<p>使用 key-value 存储结构的 dict 在 Python 中非常有用，选择不可变对象作为key很重要，最常用的key是字符串。</p>

<h1 id="相关资料">相关资料</h1>

<ul>
<li><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/00143167793538255adf33371774853a0ef943280573f4d000">使用dict和set</a></li>
</ul>

    </div>

    
    

    
    

    <footer class="post-footer">
      

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/02-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/03-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/99-%E5%85%B6%E5%AE%83%E9%A1%B9%E7%9B%AE/%E4%B8%83%E6%9C%88kaggle/03-%E6%8E%92%E5%BA%8F%E4%B8%8E-ctr%E9%A2%84%E4%BC%B0%E9%97%AE%E9%A2%98/05-%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E5%A4%84%E7%90%86/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default"></span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02-python/02-python-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/03-python-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/01-%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD/">
            <span class="next-text nav-default"></span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="iteratelyd@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="http://github.com/iterateself" class="iconfont icon-github" title="github"></a>
      <a href="https://www.zhihu.com/people/thebegin/activities" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="https://www.douban.com/people/68028070/" class="iconfont icon-douban" title="douban"></a>
  <a href="http://iterate.site/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> site pv: <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
    <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> site uv: <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2018
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">iterateself</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>


<script type="text/javascript" src="/dist/even.min.js?v=3.2.0"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>








</body>
</html>
