<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>03 1880年至2010年美国婴儿姓名 - 迭代自己</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="iterateself" />
  <meta name="description" content="14.3 US Baby Names 1880–2010（1880年至2010年美国婴儿姓名） 这个数据是从1880年到2010年婴儿名字频率数据。我们先看一下这个数据长什" />

  <meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.47.1" />


<link rel="canonical" href="http://iterate.site/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02-python/03-python-%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97/11-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BE%8B%E5%AD%90/03-1880%E5%B9%B4%E8%87%B32010%E5%B9%B4%E7%BE%8E%E5%9B%BD%E5%A9%B4%E5%84%BF%E5%A7%93%E5%90%8D/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">




<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<link href="/dist/even.min.css?v=3.2.0" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">




<meta property="og:title" content="03 1880年至2010年美国婴儿姓名" />
<meta property="og:description" content="14.3 US Baby Names 1880–2010（1880年至2010年美国婴儿姓名） 这个数据是从1880年到2010年婴儿名字频率数据。我们先看一下这个数据长什" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://iterate.site/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02-python/03-python-%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97/11-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BE%8B%E5%AD%90/03-1880%E5%B9%B4%E8%87%B32010%E5%B9%B4%E7%BE%8E%E5%9B%BD%E5%A9%B4%E5%84%BF%E5%A7%93%E5%90%8D/" /><meta property="article:published_time" content="2018-08-03T11:34:56&#43;00:00"/>
<meta property="article:modified_time" content="2018-08-03T11:34:56&#43;00:00"/>
<meta itemprop="name" content="03 1880年至2010年美国婴儿姓名">
<meta itemprop="description" content="14.3 US Baby Names 1880–2010（1880年至2010年美国婴儿姓名） 这个数据是从1880年到2010年婴儿名字频率数据。我们先看一下这个数据长什">


<meta itemprop="datePublished" content="2018-08-03T11:34:56&#43;00:00" />
<meta itemprop="dateModified" content="2018-08-03T11:34:56&#43;00:00" />
<meta itemprop="wordCount" content="4460">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="03 1880年至2010年美国婴儿姓名"/>
<meta name="twitter:description" content="14.3 US Baby Names 1880–2010（1880年至2010年美国婴儿姓名） 这个数据是从1880年到2010年婴儿名字频率数据。我们先看一下这个数据长什"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">迭代自己</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/recent/">
        <li class="mobile-menu-item">最新</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a><a href="/catalog/">
        <li class="mobile-menu-item">完整目录</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">迭代自己</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/recent/">最新</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/catalog/">完整目录</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">03 1880年至2010年美国婴儿姓名</h1>

      <div class="post-meta">
        <span class="post-time"> 2018-08-03 </span>
        
        <span class="more-meta"> 4460 words </span>
        <span class="more-meta"> 9 mins read </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> times read </span>
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  
  <div class="post-toc-content">
    <nav id="TableOfContents">
<ul>
<li><a href="#14-3-us-baby-names-1880-2010-1880年至2010年美国婴儿姓名">14.3 US Baby Names 1880–2010（1880年至2010年美国婴儿姓名）</a></li>
<li><a href="#1-analyzing-naming-trends-分析命名趋势">1 Analyzing Naming Trends（分析命名趋势）</a>
<ul>
<li><a href="#评价命名多样性的增长">评价命名多样性的增长</a></li>
<li><a href="#最后一个字母-的变革">“最后一个字母”的变革</a></li>
<li><a href="#变成女孩名字的男孩名字-以及相反的情况">变成女孩名字的男孩名字（以及相反的情况）</a></li>
</ul></li>
</ul>
</nav>
  </div>
</div>

    
    

    
    <div class="post-content">
      

<h1 id="14-3-us-baby-names-1880-2010-1880年至2010年美国婴儿姓名">14.3 US Baby Names 1880–2010（1880年至2010年美国婴儿姓名）</h1>

<p>这个数据是从1880年到2010年婴儿名字频率数据。我们先看一下这个数据长什么样子：</p>

<p><img src="http://pacdb2bfr.bkt.clouddn.com/blog/image/180803/068i0DjEd1.png?imageslim" alt="mark" /></p>

<p>个数据集可以用来做很多事，例如：</p>

<ul>
<li>计算指定名字的年度比例</li>
<li>计算某个名字的相对排名</li>
<li>计算各年度最流行的名字，以及增长或减少最快的名字</li>
<li>分析名字趋势：元音、辅音、长度、总体多样性、拼写变化、首尾字母等</li>
<li>分析外源性趋势：圣经中的名字、名人、人口结构变化等</li>
</ul>

<p>之后的教程会涉及到其中一些。另外可以去官网直接下载姓名数据，<a href="https://www.ssa.gov/oact/babynames/limits.html">Popular Baby Names</a>。</p>

<p>下载National data之后，会得到names.zip文件，解压后，可以看到一系列类似于yob1880.txt这样名字的文件，说明这些文件是按年份记录的。这里使用Unix head命令查看一下文件的前10行：</p>

<pre><code class="language-python">!head -n 10 ../datasets/babynames/yob1880.txt
</code></pre>

<p>由于这是一个非常标准的以逗号隔开的格式（即CSV文件），所以可以用pandas.read_csv将其加载到DataFrame中：</p>

<pre><code class="language-python">import pandas as pd
</code></pre>

<pre><code class="language-python"># Make display smaller
pd.options.display.max_rows = 10
</code></pre>

<pre><code class="language-python">names1880 = pd.read_csv('../datasets/babynames/yob1880.txt', names=['names', 'sex', 'births'])
</code></pre>

<pre><code class="language-python">names1880
</code></pre>

<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>names</th>
      <th>sex</th>
      <th>births</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Mary</td>
      <td>F</td>
      <td>7065</td>
    </tr>
    <tr>
      <th>1</th>
      <td>Anna</td>
      <td>F</td>
      <td>2604</td>
    </tr>
    <tr>
      <th>2</th>
      <td>Emma</td>
      <td>F</td>
      <td>2003</td>
    </tr>
    <tr>
      <th>3</th>
      <td>Elizabeth</td>
      <td>F</td>
      <td>1939</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Minnie</td>
      <td>F</td>
      <td>1746</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>1995</th>
      <td>Woodie</td>
      <td>M</td>
      <td>5</td>
    </tr>
    <tr>
      <th>1996</th>
      <td>Worthy</td>
      <td>M</td>
      <td>5</td>
    </tr>
    <tr>
      <th>1997</th>
      <td>Wright</td>
      <td>M</td>
      <td>5</td>
    </tr>
    <tr>
      <th>1998</th>
      <td>York</td>
      <td>M</td>
      <td>5</td>
    </tr>
    <tr>
      <th>1999</th>
      <td>Zachariah</td>
      <td>M</td>
      <td>5</td>
    </tr>
  </tbody>
</table>
<p>2000 rows × 3 columns</p>
</div>

<p>这些文件中仅含有当年出现超过5次以上的名字。为了简单化，我们可以用births列的sex分组小计，表示该年度的births总计：</p>

<pre><code class="language-python">names1880.groupby('sex').births.sum()
</code></pre>

<pre><code>sex
F     90993
M    110493
Name: births, dtype: int64
</code></pre>

<p>由于该数据集按年度被分割成了多个文件，所以第一件事情就是要将所有数据都组装到一个DataFrame里面，并加上一个year字段。使用pandas.concat可以做到：</p>

<pre><code class="language-python"># 2010是最后一个有效统计年度
years = range(1880, 2011)

pieces = []
columns = ['name', 'sex', 'births']

for year in years:
    path = '../datasets/babynames/yob%d.txt' % year
    frame = pd.read_csv(path, names=columns)

    frame['year'] = year
    pieces.append(frame)

# 将所有数据整合到单个DataFrame中
names = pd.concat(pieces, ignore_index=True)
</code></pre>

<p>这里要注意几件事。</p>

<ul>
<li>第一，concat默认是按行将多个DataFrame组合到一起的；</li>
<li>第二，必须指定ignore_index=True，因为我们不希望保留read_csv所返回的原始索引。</li>
</ul>

<p>现在我们得到了一个非常大的DataFrame，它含有全部的名字数据。现在names这个DataFrame看上去是：</p>

<pre><code class="language-python">names
</code></pre>

<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>name</th>
      <th>sex</th>
      <th>births</th>
      <th>year</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Mary</td>
      <td>F</td>
      <td>7065</td>
      <td>1880</td>
    </tr>
    <tr>
      <th>1</th>
      <td>Anna</td>
      <td>F</td>
      <td>2604</td>
      <td>1880</td>
    </tr>
    <tr>
      <th>2</th>
      <td>Emma</td>
      <td>F</td>
      <td>2003</td>
      <td>1880</td>
    </tr>
    <tr>
      <th>3</th>
      <td>Elizabeth</td>
      <td>F</td>
      <td>1939</td>
      <td>1880</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Minnie</td>
      <td>F</td>
      <td>1746</td>
      <td>1880</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>1690779</th>
      <td>Zymaire</td>
      <td>M</td>
      <td>5</td>
      <td>2010</td>
    </tr>
    <tr>
      <th>1690780</th>
      <td>Zyonne</td>
      <td>M</td>
      <td>5</td>
      <td>2010</td>
    </tr>
    <tr>
      <th>1690781</th>
      <td>Zyquarius</td>
      <td>M</td>
      <td>5</td>
      <td>2010</td>
    </tr>
    <tr>
      <th>1690782</th>
      <td>Zyran</td>
      <td>M</td>
      <td>5</td>
      <td>2010</td>
    </tr>
    <tr>
      <th>1690783</th>
      <td>Zzyzx</td>
      <td>M</td>
      <td>5</td>
      <td>2010</td>
    </tr>
  </tbody>
</table>
<p>1690784 rows × 4 columns</p>
</div>

<p>有了这些数据后，我们就可以利用groupby或pivot_table在year和sex界别上对其进行聚合了：</p>

<pre><code class="language-python">total_births = names.pivot_table('births', index='year',
                                columns='sex', aggfunc=sum)
</code></pre>

<pre><code class="language-python">total_births.tail()
</code></pre>

<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>sex</th>
      <th>F</th>
      <th>M</th>
    </tr>
    <tr>
      <th>year</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2006</th>
      <td>1896468</td>
      <td>2050234</td>
    </tr>
    <tr>
      <th>2007</th>
      <td>1916888</td>
      <td>2069242</td>
    </tr>
    <tr>
      <th>2008</th>
      <td>1883645</td>
      <td>2032310</td>
    </tr>
    <tr>
      <th>2009</th>
      <td>1827643</td>
      <td>1973359</td>
    </tr>
    <tr>
      <th>2010</th>
      <td>1759010</td>
      <td>1898382</td>
    </tr>
  </tbody>
</table>
</div>

<pre><code class="language-python">import seaborn as sns
%matplotlib inline
</code></pre>

<pre><code class="language-python">total_births.plot(title='Total births by sex and year', figsize=(15, 8))
</code></pre>

<pre><code>&lt;matplotlib.axes._subplots.AxesSubplot at 0x1289ad710&gt;
</code></pre>

<p><img src="http://pacdb2bfr.bkt.clouddn.com/blog/image/180708/30A8Ik5DAA.png?imageslim" alt="mark" /></p>

<p>下面我们来插入一个prop列，用于存放指定名字的婴儿数相对于总出生数的比列。prop值为0.02表示每100名婴儿中有2名取了当前这个名字。因此，我们先按year和sex分组，然后再将新列加到各个分组上：</p>

<pre><code class="language-python">def add_prop(group):
    group['prop'] = group.births / group.births.sum()
    return group
names = names.groupby(['year', 'sex']).apply(add_prop)
</code></pre>

<pre><code class="language-python">names
</code></pre>

<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>name</th>
      <th>sex</th>
      <th>births</th>
      <th>year</th>
      <th>prop</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Mary</td>
      <td>F</td>
      <td>7065</td>
      <td>1880</td>
      <td>0.077643</td>
    </tr>
    <tr>
      <th>1</th>
      <td>Anna</td>
      <td>F</td>
      <td>2604</td>
      <td>1880</td>
      <td>0.028618</td>
    </tr>
    <tr>
      <th>2</th>
      <td>Emma</td>
      <td>F</td>
      <td>2003</td>
      <td>1880</td>
      <td>0.022013</td>
    </tr>
    <tr>
      <th>3</th>
      <td>Elizabeth</td>
      <td>F</td>
      <td>1939</td>
      <td>1880</td>
      <td>0.021309</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Minnie</td>
      <td>F</td>
      <td>1746</td>
      <td>1880</td>
      <td>0.019188</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>1690779</th>
      <td>Zymaire</td>
      <td>M</td>
      <td>5</td>
      <td>2010</td>
      <td>0.000003</td>
    </tr>
    <tr>
      <th>1690780</th>
      <td>Zyonne</td>
      <td>M</td>
      <td>5</td>
      <td>2010</td>
      <td>0.000003</td>
    </tr>
    <tr>
      <th>1690781</th>
      <td>Zyquarius</td>
      <td>M</td>
      <td>5</td>
      <td>2010</td>
      <td>0.000003</td>
    </tr>
    <tr>
      <th>1690782</th>
      <td>Zyran</td>
      <td>M</td>
      <td>5</td>
      <td>2010</td>
      <td>0.000003</td>
    </tr>
    <tr>
      <th>1690783</th>
      <td>Zzyzx</td>
      <td>M</td>
      <td>5</td>
      <td>2010</td>
      <td>0.000003</td>
    </tr>
  </tbody>
</table>
<p>1690784 rows × 5 columns</p>
</div>

<p>在执行这样的分组处理时，一般都应该做一些有效性检查（sanity check），比如验证所有分组的prop的综合是否为1。由于这是一个浮点型数据，所以我们应该用np.allclose来检查这个分组总计值是否够近似于（可能不会精确等于）1：</p>

<pre><code class="language-python">names.groupby(['year', 'sex']).prop.sum()
</code></pre>

<pre><code>year  sex
1880  F      1.0
      M      1.0
1881  F      1.0
      M      1.0
1882  F      1.0
            ...
2008  M      1.0
2009  F      1.0
      M      1.0
2010  F      1.0
      M      1.0
Name: prop, Length: 262, dtype: float64
</code></pre>

<p>这样就算完活了。为了便于实现进一步的分析，我们需要取出该数据的一个子集：每对sex/year组合的前1000个名字。这又是一个分组操作：</p>

<pre><code class="language-python">def get_top1000(group):
    return group.sort_values(by='births', ascending=False)[:1000]

grouped = names.groupby(['year', 'sex'])
top1000 = grouped.apply(get_top1000)

# Drop the group index, not needed
top1000.reset_index(inplace=True, drop=True)
</code></pre>

<p>如果喜欢DIY的话，也可以这样：</p>

<pre><code class="language-python">pieces =[]
for year, group in names.groupby(['year', 'sex']):
    pieces.append(group.sort_values(by='births', ascending=False)[:1000])

top1000 = pd.concat(pieces, ignore_index=True)
</code></pre>

<pre><code class="language-python">top1000
</code></pre>

<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>name</th>
      <th>sex</th>
      <th>births</th>
      <th>year</th>
      <th>prop</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Mary</td>
      <td>F</td>
      <td>7065</td>
      <td>1880</td>
      <td>0.077643</td>
    </tr>
    <tr>
      <th>1</th>2
      <td>Anna</td>
      <td>F</td>
      <td>2604</td>
      <td>1880</td>
      <td>0.028618</td>
    </tr>
    <tr>
      <th>2</th>
      <td>Emma</td>
      <td>F</td>
      <td>2003</td>
      <td>1880</td>
      <td>0.022013</td>
    </tr>
    <tr>
      <th>3</th>
      <td>Elizabeth</td>
      <td>F</td>
      <td>1939</td>
      <td>1880</td>
      <td>0.021309</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Minnie</td>
      <td>F</td>
      <td>1746</td>
      <td>1880</td>
      <td>0.019188</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>261872</th>
      <td>Camilo</td>
      <td>M</td>
      <td>194</td>
      <td>2010</td>
      <td>0.000102</td>
    </tr>
    <tr>
      <th>261873</th>
      <td>Destin</td>
      <td>M</td>
      <td>194</td>
      <td>2010</td>
      <td>0.000102</td>
    </tr>
    <tr>
      <th>261874</th>
      <td>Jaquan</td>
      <td>M</td>
      <td>194</td>
      <td>2010</td>
      <td>0.000102</td>
    </tr>
    <tr>
      <th>261875</th>
      <td>Jaydan</td>
      <td>M</td>
      <td>194</td>
      <td>2010</td>
      <td>0.000102</td>
    </tr>
    <tr>
      <th>261876</th>
      <td>Maxton</td>
      <td>M</td>
      <td>193</td>
      <td>2010</td>
      <td>0.000102</td>
    </tr>
  </tbody>
</table>
<p>261877 rows × 5 columns</p>
</div>

<p>接下来针对这个top1000数据集，我们就可以开始数据分析工作了</p>

<h1 id="1-analyzing-naming-trends-分析命名趋势">1 Analyzing Naming Trends（分析命名趋势）</h1>

<p>有了完整的数据集和刚才生成的top1000数据集，我们就可以开始分析各种命名趋势了。首先将前1000个名字分为男女两个部分：</p>

<pre><code class="language-python">boys = top1000[top1000.sex=='M']
girls = top1000[top1000.sex=='F']
</code></pre>

<p>这是两个简单的时间序列，只需要稍作整理即可绘制出相应的图标，比如每年叫做John和Mary的婴儿数。我们先生成一张按year和name统计的总出生数透视表：</p>

<pre><code class="language-python">total_births = top1000.pivot_table('births', index='year',
                                   columns='name', aggfunc=sum)

total_births
</code></pre>

<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>name</th>
      <th>Aaden</th>
      <th>Aaliyah</th>
      <th>Aarav</th>
      <th>Aaron</th>
      <th>Aarush</th>
      <th>Ab</th>
      <th>Abagail</th>
      <th>Abb</th>
      <th>Abbey</th>
      <th>Abbie</th>
      <th>...</th>
      <th>Zoa</th>
      <th>Zoe</th>
      <th>Zoey</th>
      <th>Zoie</th>
      <th>Zola</th>
      <th>Zollie</th>
      <th>Zona</th>
      <th>Zora</th>
      <th>Zula</th>
      <th>Zuri</th>
    </tr>
    <tr>
      <th>year</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1880</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>102.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>71.0</td>
      <td>...</td>
      <td>8.0</td>
      <td>23.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>7.0</td>
      <td>NaN</td>
      <td>8.0</td>
      <td>28.0</td>
      <td>27.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>1881</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>94.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>81.0</td>
      <td>...</td>
      <td>NaN</td>
      <td>22.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>10.0</td>
      <td>NaN</td>
      <td>9.0</td>
      <td>21.0</td>
      <td>27.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>1882</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>85.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>80.0</td>
      <td>...</td>
      <td>8.0</td>
      <td>25.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>9.0</td>
      <td>NaN</td>
      <td>17.0</td>
      <td>32.0</td>
      <td>21.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>1883</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>105.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>79.0</td>
      <td>...</td>
      <td>NaN</td>
      <td>23.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>10.0</td>
      <td>NaN</td>
      <td>11.0</td>
      <td>35.0</td>
      <td>25.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>1884</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>97.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>98.0</td>
      <td>...</td>
      <td>13.0</td>
      <td>31.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>14.0</td>
      <td>6.0</td>
      <td>8.0</td>
      <td>58.0</td>
      <td>27.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>2006</th>
      <td>NaN</td>
      <td>3737.0</td>
      <td>NaN</td>
      <td>8279.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>297.0</td>
      <td>NaN</td>
      <td>404.0</td>
      <td>440.0</td>
      <td>...</td>
      <td>NaN</td>
      <td>5145.0</td>
      <td>2839.0</td>
      <td>530.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2007</th>
      <td>NaN</td>
      <td>3941.0</td>
      <td>NaN</td>
      <td>8914.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>313.0</td>
      <td>NaN</td>
      <td>349.0</td>
      <td>468.0</td>
      <td>...</td>
      <td>NaN</td>
      <td>4925.0</td>
      <td>3028.0</td>
      <td>526.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2008</th>
      <td>955.0</td>
      <td>4028.0</td>
      <td>219.0</td>
      <td>8511.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>317.0</td>
      <td>NaN</td>
      <td>344.0</td>
      <td>400.0</td>
      <td>...</td>
      <td>NaN</td>
      <td>4764.0</td>
      <td>3438.0</td>
      <td>492.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2009</th>
      <td>1265.0</td>
      <td>4352.0</td>
      <td>270.0</td>
      <td>7936.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>296.0</td>
      <td>NaN</td>
      <td>307.0</td>
      <td>369.0</td>
      <td>...</td>
      <td>NaN</td>
      <td>5120.0</td>
      <td>3981.0</td>
      <td>496.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2010</th>
      <td>448.0</td>
      <td>4628.0</td>
      <td>438.0</td>
      <td>7374.0</td>
      <td>226.0</td>
      <td>NaN</td>
      <td>277.0</td>
      <td>NaN</td>
      <td>295.0</td>
      <td>324.0</td>
      <td>...</td>
      <td>NaN</td>
      <td>6200.0</td>
      <td>5164.0</td>
      <td>504.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>258.0</td>
    </tr>
  </tbody>
</table>
<p>131 rows × 6868 columns</p>
</div>

<p>接下来使用DataFrame中的plot方法：</p>

<pre><code class="language-python">total_births.info()
</code></pre>

<pre><code>&lt;class 'pandas.core.frame.DataFrame'&gt;
Int64Index: 131 entries, 1880 to 2010
Columns: 6868 entries, Aaden to Zuri
dtypes: float64(6868)
memory usage: 6.9 MB
</code></pre>

<pre><code class="language-python">subset = total_births[['John', 'Harry', 'Mary', 'Marilyn']]
</code></pre>

<pre><code class="language-python">subset.plot(subplots=True, figsize=(12, 10), grid=False,
            title=&quot;Number of births per year&quot;)
</code></pre>

<pre><code>array([&lt;matplotlib.axes._subplots.AxesSubplot object at 0x1132a4828&gt;,
       &lt;matplotlib.axes._subplots.AxesSubplot object at 0x116933080&gt;,
       &lt;matplotlib.axes._subplots.AxesSubplot object at 0x117d24710&gt;,
       &lt;matplotlib.axes._subplots.AxesSubplot object at 0x117d70b70&gt;], dtype=object)
</code></pre>

<p><img src="http://pacdb2bfr.bkt.clouddn.com/blog/image/180708/f7eCmchcH0.png?imageslim" alt="mark" /></p>

<h2 id="评价命名多样性的增长">评价命名多样性的增长</h2>

<p>上图反应的降低情况可能意味着父母愿意给小孩起常见的名字越来越少。这个假设可以从数据中得到验证。一个办法是计算最流行的1000个名字所占的比例，我们按year和sex进行聚合并绘图：</p>

<pre><code class="language-python">import numpy as np
</code></pre>

<pre><code class="language-python">table = top1000.pivot_table('prop', index='year',
                           columns='sex', aggfunc=sum)
</code></pre>

<pre><code class="language-python">table.plot(title='Sum of table1000.prop by year and sex',
           yticks=np.linspace(0, 1.2, 13), xticks=range(1880, 2020, 10),
           figsize=(15, 8))
</code></pre>

<pre><code>&lt;matplotlib.axes._subplots.AxesSubplot at 0x11b325128&gt;
</code></pre>

<p><img src="http://pacdb2bfr.bkt.clouddn.com/blog/image/180708/Flmk6IegFf.png?imageslim" alt="mark" /></p>

<p>从图中可以看出，名字的多样性确实出现了增长（前1000项的比例降低）。另一个办法是计算占总出生人数前50%的不同名字的数量，这个数字不太好计算。我们只考虑2010年男孩的名字：</p>

<pre><code class="language-python">df = boys[boys.year == 2010]
</code></pre>

<pre><code class="language-python">df
</code></pre>

<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>name</th>
      <th>sex</th>
      <th>births</th>
      <th>year</th>
      <th>prop</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>260877</th>
      <td>Jacob</td>
      <td>M</td>
      <td>21875</td>
      <td>2010</td>
      <td>0.011523</td>
    </tr>
    <tr>
      <th>260878</th>
      <td>Ethan</td>
      <td>M</td>
      <td>17866</td>
      <td>2010</td>
      <td>0.009411</td>
    </tr>
    <tr>
      <th>260879</th>
      <td>Michael</td>
      <td>M</td>
      <td>17133</td>
      <td>2010</td>
      <td>0.009025</td>
    </tr>
    <tr>
      <th>260880</th>
      <td>Jayden</td>
      <td>M</td>
      <td>17030</td>
      <td>2010</td>
      <td>0.008971</td>
    </tr>
    <tr>
      <th>260881</th>
      <td>William</td>
      <td>M</td>
      <td>16870</td>
      <td>2010</td>
      <td>0.008887</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>261872</th>
      <td>Camilo</td>
      <td>M</td>
      <td>194</td>
      <td>2010</td>
      <td>0.000102</td>
    </tr>
    <tr>
      <th>261873</th>
      <td>Destin</td>
      <td>M</td>
      <td>194</td>
      <td>2010</td>
      <td>0.000102</td>
    </tr>
    <tr>
      <th>261874</th>
      <td>Jaquan</td>
      <td>M</td>
      <td>194</td>
      <td>2010</td>
      <td>0.000102</td>
    </tr>
    <tr>
      <th>261875</th>
      <td>Jaydan</td>
      <td>M</td>
      <td>194</td>
      <td>2010</td>
      <td>0.000102</td>
    </tr>
    <tr>
      <th>261876</th>
      <td>Maxton</td>
      <td>M</td>
      <td>193</td>
      <td>2010</td>
      <td>0.000102</td>
    </tr>
  </tbody>
</table>
<p>1000 rows × 5 columns</p>
</div>

<p>对prop降序排列后，我们想知道前面多少个名字的人数加起来才够50%。虽然编写一个for循环也能达到目的，但NumPy有一种更聪明的矢量方式。先计算prop的累计和cumsum，，然后再通过searchsorted方法找出0.5应该被插入在哪个位置才能保证不破坏顺序：</p>

<pre><code class="language-python">prop_cumsum = df.sort_values(by='prop', ascending=False).prop.cumsum()
</code></pre>

<pre><code class="language-python">prop_cumsum[:10]
</code></pre>

<pre><code>260877    0.011523
260878    0.020934
260879    0.029959
260880    0.038930
260881    0.047817
260882    0.056579
260883    0.065155
260884    0.073414
260885    0.081528
260886    0.089621
Name: prop, dtype: float64
</code></pre>

<pre><code class="language-python">prop_cumsum.searchsorted(0.5)
</code></pre>

<pre><code>array([116])
</code></pre>

<p>由于数组索引是从0开始的，因此我们要给这个结果加1，即最终结果为117。拿1900年的数据来做个比较，这个数字要小得多：</p>

<pre><code class="language-python">df = boys[boys.year == 1900]
in1900 = df.sort_values(by='prop', ascending=False).prop.cumsum()
in1900[-10:]
</code></pre>

<pre><code>41853    0.979223
41852    0.979277
41851    0.979330
41850    0.979383
41849    0.979436
41848    0.979489
41847    0.979542
41846    0.979595
41845    0.979648
41876    0.979702
Name: prop, dtype: float64
</code></pre>

<pre><code class="language-python">in1900.searchsorted(0.5) + 1
</code></pre>

<pre><code>array([25])
</code></pre>

<p>现在就可以对所有year/sex组合执行这个计算了。按这两个字段进行groupby处理，然后用一个函数计算各分组的这个值：</p>

<pre><code class="language-python">def get_quantile_count(group, q=0.5):
    group = group.sort_values(by='prop', ascending=False)
    return group.prop.cumsum().searchsorted(q) + 1

diversity = top1000.groupby(['year', 'sex']).apply(get_quantile_count)
diversity = diversity.unstack('sex')
</code></pre>

<p>现在，这个diversity有两个时间序列（每个性别各一个，按年度索引）。通过IPython，可以看到其内容，还可以绘制图标</p>

<pre><code class="language-python">diversity.head()
</code></pre>

<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>sex</th>
      <th>F</th>
      <th>M</th>
    </tr>
    <tr>
      <th>year</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1880</th>
      <td>[38]</td>
      <td>[14]</td>
    </tr>
    <tr>
      <th>1881</th>
      <td>[38]</td>
      <td>[14]</td>
    </tr>
    <tr>
      <th>1882</th>
      <td>[38]</td>
      <td>[15]</td>
    </tr>
    <tr>
      <th>1883</th>
      <td>[39]</td>
      <td>[15]</td>
    </tr>
    <tr>
      <th>1884</th>
      <td>[39]</td>
      <td>[16]</td>
    </tr>
  </tbody>
</table>
</div>

<p>可以看到上面表格中的值为list，如果不加diversity=diversity.astype(float)的话，会报错显示，“no numeric data to plot” error。通过加上这句来更改数据类型，就能正常绘图了：</p>

<pre><code class="language-python">diversity = diversity.astype('float')
diversity
</code></pre>

<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>sex</th>
      <th>F</th>
      <th>M</th>
    </tr>
    <tr>
      <th>year</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1880</th>
      <td>38.0</td>
      <td>14.0</td>
    </tr>
    <tr>
      <th>1881</th>
      <td>38.0</td>
      <td>14.0</td>
    </tr>
    <tr>
      <th>1882</th>
      <td>38.0</td>
      <td>15.0</td>
    </tr>
    <tr>
      <th>1883</th>
      <td>39.0</td>
      <td>15.0</td>
    </tr>
    <tr>
      <th>1884</th>
      <td>39.0</td>
      <td>16.0</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>2006</th>
      <td>209.0</td>
      <td>99.0</td>
    </tr>
    <tr>
      <th>2007</th>
      <td>223.0</td>
      <td>103.0</td>
    </tr>
    <tr>
      <th>2008</th>
      <td>234.0</td>
      <td>109.0</td>
    </tr>
    <tr>
      <th>2009</th>
      <td>241.0</td>
      <td>114.0</td>
    </tr>
    <tr>
      <th>2010</th>
      <td>246.0</td>
      <td>117.0</td>
    </tr>
  </tbody>
</table>
<p>131 rows × 2 columns</p>
</div>

<pre><code class="language-python">diversity.plot(title='Number of popular names in top 50%', figsize=(15, 8))
</code></pre>

<pre><code>&lt;matplotlib.axes._subplots.AxesSubplot at 0x11b3b7eb8&gt;
</code></pre>

<p><img src="http://pacdb2bfr.bkt.clouddn.com/blog/image/180708/Fm9gl7Ei8F.png?imageslim" alt="mark" /></p>

<p>从图中可以看出，女孩名字的多样性总是比男孩高，而且还变得越来越高。我们可以自己分析一下具体是什么在驱动这个多样性（比如拼写形式的变化）。</p>

<h2 id="最后一个字母-的变革">“最后一个字母”的变革</h2>

<p>一位研究人员指出：近百年来，男孩名字在最后一个字母上的分布发生了显著的变化。为了了解具体的情况，我们首先将全部出生数据在年度、性别以及末字母上进行了聚合：</p>

<pre><code class="language-python"># 从name列中取出最后一个字母
get_last_letter = lambda x: x[-1]
last_letters = names.name.map(get_last_letter)
last_letters.name = 'last_letter'

table = names.pivot_table('births', index=last_letters,
                          columns=['sex', 'year'], aggfunc=sum)
</code></pre>

<pre><code class="language-python">print(type(last_letters))
print(last_letters[:5])
</code></pre>

<pre><code>&lt;class 'pandas.core.series.Series'&gt;
0    y
1    a
2    a
3    h
4    e
Name: last_letter, dtype: object
</code></pre>

<p>然后，我们选出具有一个代表性的三年，并输出前几行：</p>

<pre><code class="language-python">subtable = table.reindex(columns=[1910, 1960, 2010], level='year')
subtable.head()
</code></pre>

<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th>sex</th>
      <th colspan="3" halign="left">F</th>
      <th colspan="3" halign="left">M</th>
    </tr>
    <tr>
      <th>year</th>
      <th>1910</th>
      <th>1960</th>
      <th>2010</th>
      <th>1910</th>
      <th>1960</th>
      <th>2010</th>
    </tr>
    <tr>
      <th>last_letter</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <td>108376.0</td>
      <td>691247.0</td>
      <td>670605.0</td>
      <td>977.0</td>
      <td>5204.0</td>
      <td>28438.0</td>
    </tr>
    <tr>
      <th>b</th>
      <td>NaN</td>
      <td>694.0</td>
      <td>450.0</td>
      <td>411.0</td>
      <td>3912.0</td>
      <td>38859.0</td>
    </tr>
    <tr>
      <th>c</th>
      <td>5.0</td>
      <td>49.0</td>
      <td>946.0</td>
      <td>482.0</td>
      <td>15476.0</td>
      <td>23125.0</td>
    </tr>
    <tr>
      <th>d</th>
      <td>6750.0</td>
      <td>3729.0</td>
      <td>2607.0</td>
      <td>22111.0</td>
      <td>262112.0</td>
      <td>44398.0</td>
    </tr>
    <tr>
      <th>e</th>
      <td>133569.0</td>
      <td>435013.0</td>
      <td>313833.0</td>
      <td>28655.0</td>
      <td>178823.0</td>
      <td>129012.0</td>
    </tr>
  </tbody>
</table>
</div>

<p>接下来我们需要安总出生数对该表进行规范化处理，一遍计算出个性别各末字母站总出生人数的比例：</p>

<pre><code class="language-python">subtable.sum()
</code></pre>

<pre><code>sex  year
F    1910     396416.0
     1960    2022062.0
     2010    1759010.0
M    1910     194198.0
     1960    2132588.0
     2010    1898382.0
dtype: float64
</code></pre>

<pre><code class="language-python">letter_prop = subtable / subtable.sum()
letter_prop
</code></pre>

<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th>sex</th>
      <th colspan="3" halign="left">F</th>
      <th colspan="3" halign="left">M</th>
    </tr>
    <tr>
      <th>year</th>
      <th>1910</th>
      <th>1960</th>
      <th>2010</th>
      <th>1910</th>
      <th>1960</th>
      <th>2010</th>
    </tr>
    <tr>
      <th>last_letter</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <td>0.273390</td>
      <td>0.341853</td>
      <td>0.381240</td>
      <td>0.005031</td>
      <td>0.002440</td>
      <td>0.014980</td>
    </tr>
    <tr>
      <th>b</th>
      <td>NaN</td>
      <td>0.000343</td>
      <td>0.000256</td>
      <td>0.002116</td>
      <td>0.001834</td>
      <td>0.020470</td>
    </tr>
    <tr>
      <th>c</th>
      <td>0.000013</td>
      <td>0.000024</td>
      <td>0.000538</td>
      <td>0.002482</td>
      <td>0.007257</td>
      <td>0.012181</td>
    </tr>
    <tr>
      <th>d</th>
      <td>0.017028</td>
      <td>0.001844</td>
      <td>0.001482</td>
      <td>0.113858</td>
      <td>0.122908</td>
      <td>0.023387</td>
    </tr>
    <tr>
      <th>e</th>
      <td>0.336941</td>
      <td>0.215133</td>
      <td>0.178415</td>
      <td>0.147556</td>
      <td>0.083853</td>
      <td>0.067959</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>v</th>
      <td>NaN</td>
      <td>0.000060</td>
      <td>0.000117</td>
      <td>0.000113</td>
      <td>0.000037</td>
      <td>0.001434</td>
    </tr>
    <tr>
      <th>w</th>
      <td>0.000020</td>
      <td>0.000031</td>
      <td>0.001182</td>
      <td>0.006329</td>
      <td>0.007711</td>
      <td>0.016148</td>
    </tr>
    <tr>
      <th>x</th>
      <td>0.000015</td>
      <td>0.000037</td>
      <td>0.000727</td>
      <td>0.003965</td>
      <td>0.001851</td>
      <td>0.008614</td>
    </tr>
    <tr>
      <th>y</th>
      <td>0.110972</td>
      <td>0.152569</td>
      <td>0.116828</td>
      <td>0.077349</td>
      <td>0.160987</td>
      <td>0.058168</td>
    </tr>
    <tr>
      <th>z</th>
      <td>0.002439</td>
      <td>0.000659</td>
      <td>0.000704</td>
      <td>0.000170</td>
      <td>0.000184</td>
      <td>0.001831</td>
    </tr>
  </tbody>
</table>
<p>26 rows × 6 columns</p>
</div>

<p>有了这个字母比例数据后，就可以生成一张各年度各性别的条形图了：</p>

<pre><code class="language-python">import matplotlib.pyplot as plt
</code></pre>

<pre><code class="language-python">fig, axes = plt.subplots(2, 1, figsize=(10, 8))
letter_prop['M'].plot(kind='bar', rot=0, ax=axes[0], title='Male')
letter_prop['F'].plot(kind='bar', rot=0, ax=axes[1], title='Femal', legend=False)
</code></pre>

<pre><code>&lt;matplotlib.axes._subplots.AxesSubplot at 0x11bb53b00&gt;
</code></pre>

<p><img src="http://pacdb2bfr.bkt.clouddn.com/blog/image/180708/h8C3bCkHbi.png?imageslim" alt="mark" /></p>

<p>从上图可以看出来，从20世纪60年代开始，以字母&rsquo;n&rsquo;结尾的男孩名字出现了显著的增长。回到之前创建的那个完整表，按年度和性别对其进行规范化处理，并在男孩名字中选取几个字母，最后进行转置以便将各个列做成一个时间序列：</p>

<pre><code class="language-python">letter_prop = table / table.sum()
letter_prop.head()
</code></pre>

<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th>sex</th>
      <th colspan="10" halign="left">F</th>
      <th>...</th>
      <th colspan="10" halign="left">M</th>
    </tr>
    <tr>
      <th>year</th>
      <th>1880</th>
      <th>1881</th>
      <th>1882</th>
      <th>1883</th>
      <th>1884</th>
      <th>1885</th>
      <th>1886</th>
      <th>1887</th>
      <th>1888</th>
      <th>1889</th>
      <th>...</th>
      <th>2001</th>
      <th>2002</th>
      <th>2003</th>
      <th>2004</th>
      <th>2005</th>
      <th>2006</th>
      <th>2007</th>
      <th>2008</th>
      <th>2009</th>
      <th>2010</th>
    </tr>
    <tr>
      <th>last_letter</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <td>0.345587</td>
      <td>0.343440</td>
      <td>0.338764</td>
      <td>0.341251</td>
      <td>0.338550</td>
      <td>0.341270</td>
      <td>0.339703</td>
      <td>0.335258</td>
      <td>0.332764</td>
      <td>0.328706</td>
      <td>...</td>
      <td>0.020162</td>
      <td>0.020019</td>
      <td>0.019177</td>
      <td>0.019505</td>
      <td>0.018481</td>
      <td>0.017635</td>
      <td>0.016747</td>
      <td>0.016189</td>
      <td>0.015927</td>
      <td>0.014980</td>
    </tr>
    <tr>
      <th>b</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>...</td>
      <td>0.026256</td>
      <td>0.025418</td>
      <td>0.024368</td>
      <td>0.023171</td>
      <td>0.021645</td>
      <td>0.020778</td>
      <td>0.020357</td>
      <td>0.019655</td>
      <td>0.019693</td>
      <td>0.020470</td>
    </tr>
    <tr>
      <th>c</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>0.000046</td>
      <td>0.000045</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>...</td>
      <td>0.013972</td>
      <td>0.014048</td>
      <td>0.014042</td>
      <td>0.013514</td>
      <td>0.013083</td>
      <td>0.012991</td>
      <td>0.012983</td>
      <td>0.012458</td>
      <td>0.012186</td>
      <td>0.012181</td>
    </tr>
    <tr>
      <th>d</th>
      <td>0.006693</td>
      <td>0.006601</td>
      <td>0.006806</td>
      <td>0.007211</td>
      <td>0.007100</td>
      <td>0.006478</td>
      <td>0.006967</td>
      <td>0.007035</td>
      <td>0.007266</td>
      <td>0.007703</td>
      <td>...</td>
      <td>0.031352</td>
      <td>0.028794</td>
      <td>0.027069</td>
      <td>0.026118</td>
      <td>0.025420</td>
      <td>0.025075</td>
      <td>0.024451</td>
      <td>0.023574</td>
      <td>0.023398</td>
      <td>0.023387</td>
    </tr>
    <tr>
      <th>e</th>
      <td>0.366819</td>
      <td>0.370616</td>
      <td>0.374582</td>
      <td>0.373159</td>
      <td>0.372722</td>
      <td>0.372896</td>
      <td>0.372802</td>
      <td>0.372324</td>
      <td>0.373675</td>
      <td>0.373736</td>
      <td>...</td>
      <td>0.074927</td>
      <td>0.074603</td>
      <td>0.073396</td>
      <td>0.071710</td>
      <td>0.070799</td>
      <td>0.069748</td>
      <td>0.069445</td>
      <td>0.069362</td>
      <td>0.068663</td>
      <td>0.067959</td>
    </tr>
  </tbody>
</table>
<p>5 rows × 262 columns</p>
</div>

<pre><code class="language-python">dny_ts = letter_prop.loc[['d', 'n', 'y'], 'M'].T
dny_ts.head()
</code></pre>

<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>last_letter</th>
      <th>d</th>
      <th>n</th>
      <th>y</th>
    </tr>
    <tr>
      <th>year</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1880</th>
      <td>0.083055</td>
      <td>0.153213</td>
      <td>0.075760</td>
    </tr>
    <tr>
      <th>1881</th>
      <td>0.083247</td>
      <td>0.153214</td>
      <td>0.077451</td>
    </tr>
    <tr>
      <th>1882</th>
      <td>0.085340</td>
      <td>0.149560</td>
      <td>0.077537</td>
    </tr>
    <tr>
      <th>1883</th>
      <td>0.084066</td>
      <td>0.151646</td>
      <td>0.079144</td>
    </tr>
    <tr>
      <th>1884</th>
      <td>0.086120</td>
      <td>0.149915</td>
      <td>0.080405</td>
    </tr>
  </tbody>
</table>
</div>

<p>有了这个时间序列的DataFrame后，就可以通过其plot方法绘制出一张趋势图：</p>

<pre><code class="language-python">dny_ts.plot(figsize=(10, 8))
</code></pre>

<pre><code>&lt;matplotlib.axes._subplots.AxesSubplot at 0x11bbb0390&gt;
</code></pre>

<p><img src="http://pacdb2bfr.bkt.clouddn.com/blog/image/180708/G3g34a56KG.png?imageslim" alt="mark" /></p>

<h2 id="变成女孩名字的男孩名字-以及相反的情况">变成女孩名字的男孩名字（以及相反的情况）</h2>

<p>另一个有趣的趋势是，早年流行于男孩的名字近年来“变性了”，列入Lesley或Leslie。回到top1000数据集，找出其中以&rdquo;lesl&rdquo;开头的一组名字：</p>

<pre><code class="language-python">all_names = pd.Series(top1000.name.unique())
lesley_like = all_names[all_names.str.lower().str.contains('lesl')]
lesley_like
</code></pre>

<pre><code>632     Leslie
2294    Lesley
4262    Leslee
4728     Lesli
6103     Lesly
dtype: object
</code></pre>

<p>然后利用这个结果过滤其他的名字，并按名字分组计算出生数以查看相对频率：</p>

<pre><code class="language-python">filtered = top1000[top1000.name.isin(lesley_like)]
filtered.groupby('name').births.sum()
</code></pre>

<pre><code>name
Leslee      1082
Lesley     35022
Lesli        929
Leslie    370429
Lesly      10067
Name: births, dtype: int64
</code></pre>

<p>接下来，我们按性别和年度进行聚合，并按年度进行规范化处理：</p>

<pre><code class="language-python">table = filtered.pivot_table('births', index='year',
                             columns='sex', aggfunc='sum')

table = table.div(table.sum(1), axis=0)
</code></pre>

<pre><code class="language-python">table
</code></pre>

<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>sex</th>
      <th>F</th>
      <th>M</th>
    </tr>
    <tr>
      <th>year</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1880</th>
      <td>0.091954</td>
      <td>0.908046</td>
    </tr>
    <tr>
      <th>1881</th>
      <td>0.106796</td>
      <td>0.893204</td>
    </tr>
    <tr>
      <th>1882</th>
      <td>0.065693</td>
      <td>0.934307</td>
    </tr>
    <tr>
      <th>1883</th>
      <td>0.053030</td>
      <td>0.946970</td>
    </tr>
    <tr>
      <th>1884</th>
      <td>0.107143</td>
      <td>0.892857</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>2006</th>
      <td>1.000000</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2007</th>
      <td>1.000000</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2008</th>
      <td>1.000000</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2009</th>
      <td>1.000000</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2010</th>
      <td>1.000000</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
<p>131 rows × 2 columns</p>
</div>

<p>现在，我们可以轻松绘制一张分性别的年度曲线图了：</p>

<pre><code class="language-python">table.plot(style={'M': 'k-', 'F': 'k--'}, figsize=(10, 8))
</code></pre>

<pre><code>&lt;matplotlib.axes._subplots.AxesSubplot at 0x11f0640b8&gt;
</code></pre>

<p><img src="http://pacdb2bfr.bkt.clouddn.com/blog/image/180708/fkAEc8mac8.png?imageslim" alt="mark" /></p>

    </div>

    
    

    
    

    <footer class="post-footer">
      

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02-python/03-python-%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97/12-%E5%85%B6%E4%BB%96/02-%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%A4%E4%BA%92/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">02 与操作系统交互</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02-python/03-python-%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97/08-%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97/06-%E9%87%8D%E9%87%87%E6%A0%B7%E5%92%8C%E9%A2%91%E5%BA%A6%E8%BD%AC%E6%8D%A2/">
            <span class="next-text nav-default">06 重采样和频度转换</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="iteratelyd@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="http://github.com/iterateself" class="iconfont icon-github" title="github"></a>
      <a href="https://www.zhihu.com/people/thebegin/activities" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="https://www.douban.com/people/68028070/" class="iconfont icon-douban" title="douban"></a>
  <a href="http://iterate.site/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> site pv: <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
    <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> site uv: <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2018
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">iterateself</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>


<script type="text/javascript" src="/dist/even.min.js?v=3.2.0"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>








</body>
</html>
