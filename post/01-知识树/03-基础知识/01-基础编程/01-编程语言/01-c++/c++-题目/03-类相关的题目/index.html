<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>03 类相关的题目 - 迭代自己</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="iterateself" />
  <meta name="description" content="构造函数的初始化列表 Q 14 :这题没看懂 题目： 有哪几种情况只能用 intialization list 而不能用 assignment？ 答案*: 1. 当类中含有const成员变量；con" />

  <meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.47.1" />


<link rel="canonical" href="http://iterate.site/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01-c&#43;&#43;/c&#43;&#43;-%E9%A2%98%E7%9B%AE/03-%E7%B1%BB%E7%9B%B8%E5%85%B3%E7%9A%84%E9%A2%98%E7%9B%AE/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">




<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<link href="/dist/even.min.css?v=3.2.0" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">




<meta property="og:title" content="03 类相关的题目" />
<meta property="og:description" content="构造函数的初始化列表 Q 14 :这题没看懂 题目： 有哪几种情况只能用 intialization list 而不能用 assignment？ 答案*: 1. 当类中含有const成员变量；con" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://iterate.site/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01-c&#43;&#43;/c&#43;&#43;-%E9%A2%98%E7%9B%AE/03-%E7%B1%BB%E7%9B%B8%E5%85%B3%E7%9A%84%E9%A2%98%E7%9B%AE/" /><meta property="article:published_time" content="2018-08-28T00:00:00&#43;00:00"/>
<meta property="article:modified_time" content="2018-08-28T00:00:00&#43;00:00"/>
<meta itemprop="name" content="03 类相关的题目">
<meta itemprop="description" content="构造函数的初始化列表 Q 14 :这题没看懂 题目： 有哪几种情况只能用 intialization list 而不能用 assignment？ 答案*: 1. 当类中含有const成员变量；con">


<meta itemprop="datePublished" content="2018-08-28T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2018-08-28T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="5505">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="03 类相关的题目"/>
<meta name="twitter:description" content="构造函数的初始化列表 Q 14 :这题没看懂 题目： 有哪几种情况只能用 intialization list 而不能用 assignment？ 答案*: 1. 当类中含有const成员变量；con"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">迭代自己</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">最近</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a><a href="/catalog/">
        <li class="mobile-menu-item">完整目录</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">迭代自己</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">最近</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/catalog/">完整目录</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">03 类相关的题目</h1>

      <div class="post-meta">
        <span class="post-time"> 2018-08-28 </span>
        
        <span class="more-meta"> 5505 words </span>
        <span class="more-meta"> 11 mins read </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> times read </span>
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  
  <div class="post-toc-content">
    <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#构造函数的初始化列表">构造函数的初始化列表</a>
<ul>
<li>
<ul>
<li><a href="#q-14-span-style-color-red-这题没看懂-span">Q 14 :<span style="color:red;">这题没看懂</span></a></li>
<li><a href="#q-34">Q 34 :</a></li>
</ul></li>
</ul></li>
<li><a href="#析构函数">析构函数</a>
<ul>
<li>
<ul>
<li><a href="#q-47">Q 47 :</a></li>
</ul></li>
</ul></li>
<li><a href="#重载">重载</a>
<ul>
<li>
<ul>
<li><a href="#q-28-http-www-cnblogs-com-skynet-archive-2010-09-05-1818636-html"><a href="http://www.cnblogs.com/skynet/archive/2010/09/05/1818636.html">Q 28</a> :</a></li>
<li><a href="#q-74">Q 74 :</a></li>
</ul></li>
</ul></li>
<li><a href="#拷贝构造函数">拷贝构造函数</a>
<ul>
<li>
<ul>
<li><a href="#q-31-span-style-color-red-关于拷贝构造函数有些不清楚-span">Q 31 :<span style="color:red;">关于拷贝构造函数有些不清楚</span></a></li>
<li><a href="#q-67-http-www-cnblogs-com-wangguchangqing-p-6141743-html"><a href="http://www.cnblogs.com/wangguchangqing/p/6141743.html">Q 67</a> :</a></li>
</ul></li>
</ul></li>
<li><a href="#类与结构体的大小">类与结构体的大小</a>
<ul>
<li>
<ul>
<li><a href="#q-70">Q 70 :</a></li>
<li><a href="#q-15-http-blog-csdn-net-yby4769250-article-details-7294696"><a href="http://blog.csdn.net/yby4769250/article/details/7294696">Q 15</a> :</a></li>
<li><a href="#q-3-http-www-cnblogs-com-motadou-archive-2009-01-17-1558438-html"><a href="http://www.cnblogs.com/motadou/archive/2009/01/17/1558438.html">Q 3</a> :</a></li>
<li><a href="#q-53">Q 53 :</a></li>
<li><a href="#q-35">Q 35 :</a></li>
<li><a href="#q-23">Q 23 :</a></li>
<li><a href="#q-63">Q 63 :</a></li>
</ul></li>
</ul></li>
<li><a href="#继承-虚函数">继承 虚函数</a>
<ul>
<li>
<ul>
<li><a href="#q-1-http-www-cnblogs-com-skynet-p-3343726-html"><a href="http://www.cnblogs.com/skynet/p/3343726.html">Q 1</a> :</a></li>
<li><a href="#q-2-http-www-cnblogs-com-qlwy-archive-2011-08-25-2153584-html"><a href="http://www.cnblogs.com/qlwy/archive/2011/08/25/2153584.html">Q 2</a> :</a></li>
<li><a href="#q-13-span-style-color-red-这题没看懂-span">Q 13 :<span style="color:red;">这题没看懂</span></a></li>
<li><a href="#q-20">Q 20 :</a></li>
<li><a href="#q-25-http-www-cnblogs-com-klcf0220-p-6889122-htmls"><a href="http://www.cnblogs.com/klcf0220/p/6889122.htmls">Q 25*</a> :</a></li>
<li><a href="#q-44">Q 44 :</a></li>
<li><a href="#q-39-http-blog-csdn-net-crystal-avast-article-details-7678704"><a href="http://blog.csdn.net/crystal_avast/article/details/7678704">Q 39</a> :</a></li>
<li><a href="#q-82">Q 82 :</a></li>
<li><a href="#q-61">Q 61 :</a></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</nav>
  </div>
</div>

    
    

    
    <div class="post-content">
      

<h2 id="构造函数的初始化列表">构造函数的初始化列表</h2>

<h4 id="q-14-span-style-color-red-这题没看懂-span">Q 14 :<span style="color:red;">这题没看懂</span></h4>

<p>题目：
有哪几种情况只能用 intialization list 而不能用 assignment？</p>

<p>答案*:
1. 当类中含有const成员变量；<span style="color:red;">const 成员变量可以在 initialization list 里面初始化吗？</span>
2. 基类无默认构造函数时，有参的构造函数都需要初始化表；<span style="color:red;">这个时候不能用 assignment 吗？</span>
3. 当类中含有reference成员变量。<span style="color:red;">怎么会有 referenece 成员变量？</span></p>

<p>解答:
1. 见答案。</p>

<h4 id="q-34">Q 34 :</h4>

<p>题目：
有一个类A，其数据成员如下：</p>

<pre><code>class A {
private:
    int a;
public:
    const int b;
    float* &amp;c;
    static const char* d;
    static double* e;
};
</code></pre>

<p>则构造函数中，成员变量一定要通过初始化列表来初始化的是：</p>

<p>答案:
b
c</p>

<p>解答:
考察构造函数初始化列表的使用。
1. 构造函数中，成员变量一定要通过初始化列表来初始化的有以下几种情况：
    const 常量成员：因为常量只能在初始化，不能赋值，所以必须放在初始化列表中。
    引用类型：引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表中。
    没有默认构造函数的类类型：因为使用初始化列表可以不必调用默认构造函数来初始化，而是直接调用拷贝构造函数。<span style="color:red;">什么是初始化列表可以不必调用默认构造函数来初始化？而是直接调用拷贝构造函数？</span></p>

<p><span style="color:red;">上面的 float* &amp;c 是什么？static const char* d 是什么？</span></p>

<h2 id="析构函数">析构函数</h2>

<h4 id="q-47">Q 47 :</h4>

<p>题目：
看以下代码：</p>

<pre><code>class A{
public:
    ~A();
};
A::~A(){
    printf(&quot;delete A&quot;);
}
class B : public A{
public:
    ~B();
};
B::~B(){
    printf(&quot;delete B&quot;);
}
</code></pre>

<p>请问执行以下代码的输出是：</p>

<pre><code>A *pa = new B();
delete pa;
</code></pre>

<p>答案:
delete A</p>

<p>解答:
考察虚析构函数。
1. 若B *pb = new B()，则本题会同时输出delete A和delete B。
2. 但如果delete的是一个指向派生类的基类指针，则需要虚构造函数。
3. 这里基类没有定义虚析构函数，属未定义行为。</p>

<h2 id="重载">重载</h2>

<h4 id="q-28-http-www-cnblogs-com-skynet-archive-2010-09-05-1818636-html"><a href="http://www.cnblogs.com/skynet/archive/2010/09/05/1818636.html">Q 28</a> :</h4>

<p>题目：
下列对函数double add(int a, int b)进行重载，正确的是：</p>

<p>答案:</p>

<pre><code>int add(int a, int b, int c)
int add(double a, double b)
double add(double a, double b)
</code></pre>

<p>解答:
考察重载概念。
1. 在使用重载时只能通过相同的方法名，不同的参数形式实现。<span style="color:red;">重载时要相同的方法名，不同的参数</span>
2. 不同参数形式包括：<span style="color:red;">这三种形式不知道，之前只知道第一个。</span>
    参数类型不同（至少有一个）
    参数个数不同
    *如果同时在类中，对于函数名相同的 const 函数和非 const 函数能够构成重载
3. 编译器区分重载函数是通过“返回类型 + 函数名 + 参数列表”重新改写函数名还区分重载函数的，但返回值类型在C++中并不作为重载标记。<span style="color:red;">返回值类型在 C++中并不作为重载标记。但是编译器区分重载函数是通过“返回类型+函数名+参数列表”重新改写函数名来区分重载函数的。</span></p>

<h4 id="q-74">Q 74 :</h4>

<p>题目：
下列关于赋值运算符“=”重载的叙述中，正确的是：</p>

<p>答案：
赋值运算符只能作为类的成员函数重载</p>

<p>解答：
1. 不能被重载的运算符：
    ::  ,  *  .  ?  :
2. 必须作为成员函数重载的运算符：
    =  []  ()  -&gt;</p>

<h2 id="拷贝构造函数">拷贝构造函数</h2>

<h4 id="q-31-span-style-color-red-关于拷贝构造函数有些不清楚-span">Q 31 :<span style="color:red;">关于拷贝构造函数有些不清楚</span></h4>

<p>题目：
分析一下这段程序的输出：</p>

<pre><code>#include&lt;iostream&gt;
using namespace std;
class B{
public:
    B(){
        cout &lt;&lt; &quot;default constructor&quot; &lt;&lt; &quot; &quot;;
    }
    ~B(){
        cout &lt;&lt; &quot;destructed&quot; &lt;&lt; &quot; &quot;;
    }
    B(int i):data(i){
        cout &lt;&lt; &quot;constructed by parameter&quot; &lt;&lt; data &lt;&lt; &quot; &quot;;
    }
private:
    int data;
};
B Play(B b){
    return b;
}
int main(int argc, char *argv[]){
    B temp = Play(5);
    return 0;
}
</code></pre>

<p>答案:
constructed by parameter5
destructed
destructed</p>

<p><span style="color:red;">为什么会调用两次 destructed ？</span></p>

<p>解答:
考察赋值运算顺序以及拷贝构造函数。
1. B temp = Play(5) 从右向左执行。
2. 先将&rdquo;5&rdquo;转为形式参数B的类型，之后调用B(int i)打印&rdquo;constructed by parameter&rdquo;。
3. B temp调用B的默认浅拷贝构造函数，完成赋值，由于拷贝构造函数没有输出，所以没有打印东西。<span style="color:red;">什么是默认浅拷贝构造函数？拷贝构造函数什么时候会被调用？这个地方为什么是调用的浅拷贝构造函数？为什么这一步是在 Play() 结束之前进行的？</span>
4. Play()生命周期结束后，b析构打印&rdquo;destructed&rdquo;。
5. main()生命周期结束后，temp析构打印&rdquo;destructed&rdquo;。</p>

<h4 id="q-67-http-www-cnblogs-com-wangguchangqing-p-6141743-html"><a href="http://www.cnblogs.com/wangguchangqing/p/6141743.html">Q 67</a> :</h4>

<p>题目：</p>

<pre><code>#include&lt;iostream&gt;
using namespace std;
class MyClass{
public:
    MyClass(int i = 0){
        cout &lt;&lt; i;
    }
    MyClass(const MyClass &amp;x){
        cout &lt;&lt; 2;
    }
    MyClass &amp;operator=(const MyClass &amp;x){
        cout &lt;&lt; 3;
        return *this;
    }
    ~MyClass(){
        cout &lt;&lt; 4;
    }
};
int main(){
    MyClass obj1(1), obj2(2);
    MyClass obj3 = obj1;
    return 0;
}
</code></pre>

<p>运行时的输出结果是：</p>

<p>答案：
122444</p>

<p>解答：
考察拷贝构造函数和赋值运算符的区别。
1. 前两个1和2没有疑问，最后三个析构输出4也没有疑问。
2. C MyClass obj3 = obj1;
    若obj3还不存在，调用拷贝构造函数输出2。
    若obj3存在，obj3 = obj，则调用赋值运算符重载函数。</p>

<h2 id="类与结构体的大小">类与结构体的大小</h2>

<h4 id="q-70">Q 70 :</h4>

<p>题目：
在32位机器上，设有以下说明和定义：</p>

<pre><code>typedef union{
    long i;
    int k[5];
    char c;
}DATE;
struct data{
    int cat;
    DATE cow;
    double dog;
}too;
DATE max;
</code></pre>

<p>则sizeof(struct data) + sizeof(max)的执行结果是：</p>

<p>答案：
52</p>

<p>解答：
1. 联合体大小为20。
2. 如果最大的基本元素小于等于机器位宽，按照最大基本元素大小对齐，否则按照机器字长对齐，此处对齐单位为4字节。</p>

<h4 id="q-15-http-blog-csdn-net-yby4769250-article-details-7294696"><a href="http://blog.csdn.net/yby4769250/article/details/7294696">Q 15</a> :</h4>

<p>题目：
对以下数据结构中data的处理方式描述正确的是：</p>

<pre><code>struct Node{
    int size;
    char data[0];
};
</code></pre>

<p>答案:
编译器会认为这就是一个长度为0的数组,而且会支持对于数组data的越界访问。</p>

<p>解答:
考察柔性数组。
1*. 柔性数组，作为占位符放在结构体末尾，使得结构体的大小动态可变，在声明结构体变量的时候可根据需要动态分配内存。<span style="color:red;">什么意思？什么是柔性数组？怎么使得结构体的大小动态可变的？怎么根据需要动态分配内存的？有什么好处？有坏处吗？</span>
2. 长度为0的数组并不占用空间，因为数组名本身不占空间，它只是一个偏移量， 数组名这个符号本身代表了一个不可修改的地址常量。<span style="color:red;">数组名本身不占空间，只是一个偏移量是什么意思？相对于结构体的一个偏移量吗？确认下。</span>
3. 常用于网络通信中构造不定长数据包，不会浪费空间浪费网络流量。<span style="color:red;">想具体知道他在实际中是怎么应用的。</span></p>

<h4 id="q-3-http-www-cnblogs-com-motadou-archive-2009-01-17-1558438-html"><a href="http://www.cnblogs.com/motadou/archive/2009/01/17/1558438.html">Q 3</a> :</h4>

<p>题目：
下面两个结构体：</p>

<pre><code>struct One{
    double d;
    char c;
    int i;
}
struct Two{
    char c;
    double d;
    int i;
}
</code></pre>

<p>在 #pragma pack(4) 和 #pragma pack(8) 的情况下，结构体的大小分别是：<span style="color:red;">这个 #pragma pack(4) 是在哪里写的？在程序中可以指定这种对其的字节数吗？一般什么时候需要指定？</span></p>

<p>答案:
16，16
16，24</p>

<p>解答:
考察结构体对齐。
1. 4字节对齐：Struct One[8 + (1 + 3(pading)) + 4], struct Two[(1 + 3(pading)) + 8 + 4]。
2. 8字节对齐：Struct One[8 + (1 + 3(pading) + 4)], struct Two[(1 + 7(pading)) + 8 + (4 + 4(pading))]。
3. 一句话总结：按序存储，装得下尽量装，装不下换一行。</p>

<h4 id="q-53">Q 53 :</h4>

<p>题目：</p>

<pre><code>typedef struct{
    char flag[3];
    short value;
}sampleStruct;
union{
    char flag[3];
    short value;
}sampleUnion;
</code></pre>

<p>假设 sizeof(char)=1，sizeof(short)=2
那么 sizeof(sampleStruct) = ()
     sizeof(sampleUnion) = ()</p>

<p>答案：
6
4</p>

<p>解答：
考察结构体、联合体大小及对齐问题。
1. union：sizeof的取值不仅考虑sizeof最大的成员，还要考虑对齐字节。
2. 注：如果结构体内类型的最大字节小于系统位数对应的字节，那么按类型的最大字节对齐。所以本题结构体按2字节对齐。</p>

<h4 id="q-35">Q 35 :</h4>

<p>题目：</p>

<p>在一个64位的操作系统中定义如下结构体：</p>

<pre><code>struct st_task{
    uint16_t id;
    uint32_t value;
    uint64_t timestamp;
};
</code></pre>

<p>同时定义fool函数如下：</p>

<pre><code>void fool(){
    st_task task = {};
    uint64_t a = 0x00010001;
    memcpy(&amp;task, &amp;a, sizeof(uint64_t));
    printf(&quot;%11u, %11u, %11u&quot;, task.id, task.value, task.timestamp);
}
</code></pre>

<p>上述fool()程序的执行结果为：</p>

<p>答案:</p>

<ul>
<li>1</li>
<li>0</li>
<li>0</li>
</ul>

<p>解答:</p>

<p>考察结构体对齐。</p>

<ol>
<li>假设低地址在低位，最低16 bits被赋给低16位的id变量。</li>
<li>接下来16 bits的0x0001部分被赋值给了pading部分，没有被使用。</li>
<li>value和timestamp均未被赋值。</li>
</ol>

<h4 id="q-23">Q 23 :</h4>

<p>题目：
当一个类A中没有声明任何成员变量与成员函数,这时sizeof(A)的值是多少？</p>

<p>答案:
1</p>

<p>解答:
1. 一个空类对象的大小是 1byte 。这是被编译器安插进去的一个字节，这样就使得这个空类的两个实例得以在内存中配置独一无二的地址。<span style="color:red;">之前看到过，但是不知道这个字节是被编译器安插进去的。</span></p>

<h4 id="q-63">Q 63 :</h4>

<p>题目：</p>

<pre><code>#pragma pack(2)
class BU{
    int number;
    union UBffer{
        char buffer[13];
        int number;
    }ubuf;
    void foo(){}
    typedef char*(*f)(void*);
    enum{hdd,ssd,blueray}disk;
}bu;
</code></pre>

<p>答案：
22</p>

<p>解答：
考察结构体、联合体、枚举大小综合题。
1. pack(2)，所以int num和union大小分别为4和14没有疑问。
2. 其他部分：
    void foo(){}：0。
    typedef char*(<em>f)(void</em>)：0。
    enum{hdd,ssd,blueray}disk：4。
    无虚函数，不存在虚函数指针的4字节。
3. 枚举类型的sizeof值都是4。</p>

<h2 id="继承-虚函数">继承 虚函数</h2>

<h4 id="q-1-http-www-cnblogs-com-skynet-p-3343726-html"><a href="http://www.cnblogs.com/skynet/p/3343726.html">Q 1</a> :</h4>

<p>题目：</p>

<p>以下代码：</p>

<pre><code>class ClassA{
public:
    virtual ~ClassA(){};
    virtual void FunctionA(){};
};
class ClassB{
public:
    virtual void FunctionB(){};
};
class ClassC:public ClassA, public ClassB{
    public:
};
ClassC Object;
ClassA* pA = &amp;Object;
ClassB* pB = &amp;Object;
ClassC* pC = &amp;Object;
</code></pre>

<p>关于pA,pB,pC的取值,下面的描述中正确的是:</p>

<p>答案:
pA和pB不相同</p>

<p>解答:
考察多继承且有虚函数情况下C++存储对象模型。
1. 多继承按继承顺序组织对象模型，有虚函数时低地址包含指向虚函数表的指针。
2. 对象Object的存储模型：类A虚函数表指针(ptrA) | 类A数据 | 类B虚函数表指针(ptrB) | 类B数据 | 类C数据。
3. 子类的虚函数被放到了第一个基类的虚函数表最后（ptrA指向的虚函数表结构：类A虚函数 | 类C虚函数）。<span style="color:red;">这个地方没懂</span>
4. 有虚函数的继承，对象地址为指向虚函数表的指针的地址，即pC = &amp;Object = &amp;ptrA。<span style="color:red;">都是这样的吗？</span>
6. pC = pA = &amp;ptrA = &amp;Object，(pC = pA) &lt; pB。</p>

<h4 id="q-2-http-www-cnblogs-com-qlwy-archive-2011-08-25-2153584-html"><a href="http://www.cnblogs.com/qlwy/archive/2011/08/25/2153584.html">Q 2</a> :</h4>

<p>题目：</p>

<p>下列程序的输出结果：</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;
class A{
public:
    void print(){
        cout &lt;&lt; &quot;A:print()&quot;;
    }
};
class B:private A{
public:
    void print(){
      cout &lt;&lt; &quot;B:print()&quot;;
    }
};
class C:public B{
public:
   void print(){
        A::print();
    }
};
int main(){
    C b;
    b.print();
}
</code></pre>

<p>答案:
编译出错</p>

<p>解答:
考察C++继承问题。
1. 类B私有继承类A。
2. 私有继承：类A的公有成员和保护成员都作为类B的私有成员，并且不能被类B的子类（如类C）所访问。<span style="color:red;">嗯，知道了，那么这个会使用在什么场景下？</span></p>

<h4 id="q-13-span-style-color-red-这题没看懂-span">Q 13 :<span style="color:red;">这题没看懂</span></h4>

<p>题目：
下列代码的输出为：</p>

<pre><code>class parent{
public:
    virtual void output();
};
void parent::output(){
    printf(&quot;parent!&quot;);
}
class son : public parent{
public:
    virtual void output();
};
void son::output(){
    printf(&quot;son!&quot;);
}
son s;
memset(&amp;s, 0, sizeof(s));
parent&amp; p = s;
p.output();
</code></pre>

<p><span style="color:red;">有两点不知道，一个是虚函数的继承到底是什么样的？还有一个是 memset(&amp;s,0,sizeof(s)) 这句是什么？</span></p>

<p>答案:
没有输出结果，程序运行出错。</p>

<p>解答:
考察 memset 和虚函数指针。
1. 虚函数表地址被清空。<span style="color:red;">什么是虚函数表地址被清空？如果没有那句 memset，那么输出的是什么？</span></p>

<h4 id="q-20">Q 20 :</h4>

<p>题目：
请选择下列程序的运行结果:</p>

<pre><code>#include&lt;iostream&gt;
using namespace std;
class B0{
public:
    virtual void display(){
        cout &lt;&lt; &quot;B0::display0&quot; &lt;&lt; endl;
    }
};
class B1:public B0{
public:
    void display(){
        cout &lt;&lt; &quot;B1::display0&quot; &lt;&lt; endl;
    }
};
class D1: public B1{
public:
    void display(){
        cout &lt;&lt; &quot;D1::display0&quot; &lt;&lt; endl;
    }
};
void fun(B0 ptr){
    ptr.display();
}
int main(){
    B0 b0;
    B1 b1;
    D1 d1;
    fun(b0);
    fun(b1);
    fun(d1);
}
</code></pre>

<p>答案:
B0::display0
B0::display0
B0::display0
解答:
1. 这里传递的是对象本身而非指针，对象被直接转为基类对象，调用基类的函数。<span style="color:red;">这个不知道，对象被直接转为基类对象，调用基类的函数，那么虚函数也会被调用吗？</span>
2. 如果要实现虚函数动态绑定需要将 B0 ptr 改为 B0* ptr，ptr-&gt;display()。<span style="color:red;">也就是说，如果传递进去的是指针，那么就可以动态调用不同的基类里面的函数？</span>
3. 对象的形参传递需要先使用拷贝构造函数（默认）生成 B0 类型的临时变量，只拷贝基类部分数据（只有指向基类虚函数表的虚函数指针）。<span style="color:red;">嗯，也就是说，如果传递进去的是对象本身，那么实际上是会通过默认的拷贝构造函数生成一个 B0 类型的临时变量，所以，调用的 display() 是这个 B0 类型的临时变量的函数。嗯，这个还是很好的。</span></p>

<h4 id="q-25-http-www-cnblogs-com-klcf0220-p-6889122-htmls"><a href="http://www.cnblogs.com/klcf0220/p/6889122.htmls">Q 25*</a> :</h4>

<p>题目：
在32位操作系统gcc编译器环境下，下面程序的运行结果为：</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;
class A{
public:
    int b;
    char c;
    virtual void print(){
        cout &lt;&lt; &quot;this is father’s fuction! &quot; &lt;&lt; endl;
    }
};
class B: A{
public:
    virtual void print(){
        cout &lt;&lt; &quot;this is children’s fuction! &quot; &lt;&lt; endl;
    }
};
int main(int argc, char * argv[]){
    cout &lt;&lt; sizeof(A) &lt;&lt; &quot; &quot; &lt;&lt; sizeof(B) &lt;&lt; endl;
    return 0;
}
</code></pre>

<p>答案:
12
12</p>

<p>解答:
考察结构体对齐及虚继承和虚函数继承的区别。
1. A的大小包括本身的虚函数指针及定义的变量。
2. B的大小包括本身的虚函数指针和继承自A的变量b和c。<span style="color:red;">A 的虚函数指针没有吗？</span>
3. 如果是虚继承，则B的大小会增加4字节，增加的内容为指向虚继承的指针。<span style="color:red;">什么是虚继承？什么是指向虚继承的指针？</span></p>

<h4 id="q-44">Q 44 :</h4>

<p>题目：</p>

<pre><code>class Base{
public:
    Base(){
        Init();
    }
    virtual void Init(){
        printf(&quot;Base Init\n&quot;);
    }
    void func(){
        printf(&quot;Base func\n&quot;);
    }
};
class Derived: public Base{
public:
    virtual void Init(){
        printf(&quot;Derived Init\n&quot;);
    }
    void func(){
        printf(&quot;Derived func\n&quot;);
    }
};
int main(){
    Derived d;
    ((Base *)&amp;d)-&gt;func();
    return 0;
}
</code></pre>

<p>答案：
Base Init
Base func</p>

<p>解答：
考察虚函数。
1. 类Derived继承自Base，先调用基类构造函数Base()，再调用基类的init()，输出Base Init。
    构造子类对象，基类中不会调用子类的虚函数：
        基类构造函数 -&gt; 子类构造函数
        子类还没有构造，还没有初始化，属于未初始化对象
        基类不会去调用子类虚函数（哪怕子类中确实声明为虚函数）
2. 虽然 ((Base *)&amp;d)-&gt;func()是虚函数调用的样子，但func()跟本没有被定义为虚函数，基类指针访问基类的func()。</p>

<h4 id="q-39-http-blog-csdn-net-crystal-avast-article-details-7678704"><a href="http://blog.csdn.net/crystal_avast/article/details/7678704">Q 39</a> :</h4>

<p>题目：
下面程序输出结果是什么：</p>

<pre><code>#include&lt;iostream&gt;
using namespace std;
class A{
public:
    A(char *s){
        cout &lt;&lt; s &lt;&lt; endl;
    }
    ~A(){}
};
class B:virtual public A{
public:
    B(char *s1, char*s2):A(s1){
        cout &lt;&lt; s2 &lt;&lt; endl;
    }
};
class C:virtual public A{
public:
    C(char *s1, char*s2):A(s1){
        cout &lt;&lt; s2 &lt;&lt; endl;
    }
};
class D:public B, public C{
public:
    D(char *s1, char *s2, char *s3, char *s4):B(s1, s2), C(s1, s3), A(s1){
        cout &lt;&lt; s4 &lt;&lt; endl;
    }
};
int main() {
    D *p = new D(&quot;class A&quot;, &quot;class B&quot;, &quot;class C&quot;, &quot;class D&quot;);
    delete p;
    return 0;
}
</code></pre>

<p>答案:
class A
class B
class C
class D</p>

<p>解答:
考察虚继承的继承顺序。
1. class B, class C为虚继承。
2. 虚继承（class 派生类:virtual 继承方式 基类名）：从不同的路径继承过来的同名数据成员在内存中就只有一个拷贝。
3. 继承顺序：
    执行基类构造函数，多个基类的构造函数按照被继承的顺序构造。
    执行成员对象的构造函数，多个成员对象的构造函数按照声明的顺序构造。
    执行派生类自己的构造函数。
4. 要执行D构造函数必须先执行参数列表，欲构造B, C必须先构造A，其B, C虚继承A，所以只要执行一次构造函数。</p>

<h4 id="q-82">Q 82 :</h4>

<p>题目：
以下程序输出结果是：</p>

<pre><code>class A{
    public:
    virtual void func(int val = 1){
        std::cout &lt;&lt; &quot;A-&gt;&quot; &lt;&lt; val &lt;&lt; std::endl;
    }
    virtual void test(){
        func();
    }
};
class B : public A{
    public:
        void func(int val = 0){
            std::cout &lt;&lt; &quot;B-&gt;&quot; &lt;&lt; val &lt;&lt; std::endl;
        }
};
int main(int argc ,char* argv[]){
    B*p = new B;
    p-&gt;test();
    return 0;
}
</code></pre>

<p>答案：
B-&gt;1</p>

<p>解答：
1. 由于B类中没有覆盖（重写）基类中的虚函数test，指向派生类B的指针p调用继承自基类的函数test。
2. test函数中继续调用虚函数func，因为虚函数执行动态绑定，p此时的动态类型为B*，因此执行的是B类中的func，输出&rdquo;B-&gt;&ldquo;。
3. 缺省参数值是静态绑定，即此时val的值使用的是基类A中的缺省参数值，其值在编译阶段已经绑定，值为1。
4. 结论：
    virtual函数是动态绑定，而缺省参数值却是静态绑定。
    绝不重新定义继承而来的缺省参数值。</p>

<h4 id="q-61">Q 61 :</h4>

<p>题目：</p>

<pre><code>class Eye{
    public:
    void Look(void);
};
</code></pre>

<p>现在希望定义一个Head类，也想实现Look的功能，应该使用()方法，实现代码重用。</p>

<p>答案：</p>

<p>组合</p>

<p>解答：</p>

<p>考察组合和继承的使用场景。</p>

<ol>
<li>继承是细化的继承公共的，被继承的基类是抽象出的公共部分。</li>
<li>组合就是在定义类时直接在新类中以原有类的对象作为数据成员。<span style="color:red;">组合到底是什么？之前好像没有听说过组合</span></li>
<li>继承是派生类对基类的扩展和包含，组合是原有类被包含，这里Eye应该被包含在Head内。</li>
<li>优先使用对象组合，而不是继承。</li>
</ol>

    </div>

    
    

    
    

    <footer class="post-footer">
      

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01-c&#43;&#43;/c&#43;&#43;-%E9%A2%98%E7%9B%AE/02-%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E4%B8%8E%E8%BF%94%E5%9B%9E%E5%80%BC/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">02 函数的参数与返回值</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01-c&#43;&#43;/c&#43;&#43;-%E9%A2%98%E7%9B%AE/04-%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/">
            <span class="next-text nav-default">04 数组与指针相关题目</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="iteratelyd@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="http://github.com/iterateself" class="iconfont icon-github" title="github"></a>
      <a href="https://www.zhihu.com/people/thebegin/activities" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="https://www.douban.com/people/68028070/" class="iconfont icon-douban" title="douban"></a>
  <a href="http://iterate.site/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> site pv: <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
    <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> site uv: <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2018
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">iterateself</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>


<script type="text/javascript" src="/dist/even.min.js?v=3.2.0"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>








</body>
</html>
