<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>C&#43;&#43; 习题 - 迭代自己</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="iterateself" />
  <meta name="description" content="Q 24 :这个没明白 题目： 有以下程序： #include&amp;lt;stdio.h&amp;gt; #include&amp;lt;stdlib.h&amp;gt; void fun(int *pl, int *p2, int *s){ s = (int*)calloc(1, sizeof(int)); *s = *pl &#43; *p2; free(s); } int main(){ int a[2] = {1, 2}, b[2] = {40, 50}, *q = a; fun(a, b, q); printf(&amp;quot;%d\n&amp;quot;, *q); } 答案: 1 解答: 考察形参不改" />

  <meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.47.1" />


<link rel="canonical" href="http://iterate.site/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01-c&#43;&#43;/c&#43;&#43;-%E9%A2%98%E7%9B%AE/c&#43;&#43;-%E4%B9%A0%E9%A2%98/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">




<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<link href="/dist/even.min.css?v=3.2.0" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">




<meta property="og:title" content="C&#43;&#43; 习题" />
<meta property="og:description" content="Q 24 :这个没明白 题目： 有以下程序： #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; void fun(int *pl, int *p2, int *s){ s = (int*)calloc(1, sizeof(int)); *s = *pl &#43; *p2; free(s); } int main(){ int a[2] = {1, 2}, b[2] = {40, 50}, *q = a; fun(a, b, q); printf(&quot;%d\n&quot;, *q); } 答案: 1 解答: 考察形参不改" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://iterate.site/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01-c&#43;&#43;/c&#43;&#43;-%E9%A2%98%E7%9B%AE/c&#43;&#43;-%E4%B9%A0%E9%A2%98/" /><meta property="article:published_time" content="2018-08-21T18:16:23&#43;00:00"/>
<meta property="article:modified_time" content="2018-08-21T18:16:23&#43;00:00"/>
<meta itemprop="name" content="C&#43;&#43; 习题">
<meta itemprop="description" content="Q 24 :这个没明白 题目： 有以下程序： #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; void fun(int *pl, int *p2, int *s){ s = (int*)calloc(1, sizeof(int)); *s = *pl &#43; *p2; free(s); } int main(){ int a[2] = {1, 2}, b[2] = {40, 50}, *q = a; fun(a, b, q); printf(&quot;%d\n&quot;, *q); } 答案: 1 解答: 考察形参不改">


<meta itemprop="datePublished" content="2018-08-21T18:16:23&#43;00:00" />
<meta itemprop="dateModified" content="2018-08-21T18:16:23&#43;00:00" />
<meta itemprop="wordCount" content="12439">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="C&#43;&#43; 习题"/>
<meta name="twitter:description" content="Q 24 :这个没明白 题目： 有以下程序： #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; void fun(int *pl, int *p2, int *s){ s = (int*)calloc(1, sizeof(int)); *s = *pl &#43; *p2; free(s); } int main(){ int a[2] = {1, 2}, b[2] = {40, 50}, *q = a; fun(a, b, q); printf(&quot;%d\n&quot;, *q); } 答案: 1 解答: 考察形参不改"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">迭代自己</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">主页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a><a href="/catalog/">
        <li class="mobile-menu-item">完整目录</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">迭代自己</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">主页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/catalog/">完整目录</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">C&#43;&#43; 习题</h1>

      <div class="post-meta">
        <span class="post-time"> 2018-08-21 </span>
        
        <span class="more-meta"> 12439 words </span>
        <span class="more-meta"> 25 mins read </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> times read </span>
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  
  <div class="post-toc-content">
    <nav id="TableOfContents">
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li><a href="#q-24-span-style-color-red-这个没明白-span">Q 24 :<span style="color:red;">这个没明白</span></a></li>
<li><a href="#q-25-http-www-cnblogs-com-klcf0220-p-6889122-htmls"><a href="http://www.cnblogs.com/klcf0220/p/6889122.htmls">Q 25*</a> :</a></li>
<li><a href="#q-26">Q 26 :</a></li>
<li><a href="#q-27-span-style-color-red-这个没看懂-span">Q 27 :<span style="color:red;">这个没看懂</span></a></li>
<li><a href="#q-28-http-www-cnblogs-com-skynet-archive-2010-09-05-1818636-html"><a href="http://www.cnblogs.com/skynet/archive/2010/09/05/1818636.html">Q 28</a> :</a></li>
<li><a href="#q-29">Q 29 :</a></li>
<li><a href="#q-30">Q 30 :</a></li>
<li><a href="#q-31-span-style-color-red-关于拷贝构造函数有些不清楚-span">Q 31 :<span style="color:red;">关于拷贝构造函数有些不清楚</span></a></li>
<li><a href="#q-32">Q 32 :</a></li>
<li><a href="#q-33">Q 33 :</a></li>
<li><a href="#q-34">Q 34 :</a></li>
<li><a href="#q-35">Q 35 :</a></li>
<li><a href="#q-36">Q 36 :</a></li>
<li><a href="#q-37">Q 37 :</a></li>
<li><a href="#q-38">Q 38 :</a></li>
<li><a href="#q-39-http-blog-csdn-net-crystal-avast-article-details-7678704"><a href="http://blog.csdn.net/crystal_avast/article/details/7678704">Q 39</a> :</a></li>
<li><a href="#q-40">Q 40 :</a></li>
<li><a href="#q-41">Q 41 :</a></li>
<li><a href="#q-42-http-www-cnblogs-com-lizhenghn-p-3630405-html"><a href="http://www.cnblogs.com/lizhenghn/p/3630405.html">Q 42</a> :</a></li>
<li><a href="#q-43">Q 43 :</a></li>
<li><a href="#q-44">Q 44 :</a></li>
<li><a href="#q-45">Q 45 :</a></li>
<li><a href="#q-46">Q 46 :</a></li>
<li><a href="#q-47">Q 47 :</a></li>
<li><a href="#q-48">Q 48 :</a></li>
<li><a href="#q-49">Q 49 :</a></li>
<li><a href="#q-50">Q 50 :</a></li>
<li><a href="#q-51">Q 51 :</a></li>
<li><a href="#q-52">Q 52 :</a></li>
<li><a href="#q-53">Q 53 :</a></li>
<li><a href="#q-54">Q 54 :</a></li>
<li><a href="#q-55">Q 55 :</a></li>
<li><a href="#q-56">Q 56 :</a></li>
<li><a href="#q-57">Q 57 :</a></li>
<li><a href="#q-58">Q 58 :</a></li>
<li><a href="#q-59">Q 59 :</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#toc_36">++</a>
<ul>
<li>
<ul>
<li>
<ul>
<li><a href="#q-60">Q 60 :</a></li>
<li><a href="#q-61">Q 61 :</a></li>
<li><a href="#q-62">Q 62 :</a></li>
<li><a href="#q-63">Q 63 :</a></li>
<li><a href="#q-64">Q 64 :</a></li>
<li><a href="#q-65">Q 65 :</a></li>
<li><a href="#q-66">Q 66 :</a></li>
<li><a href="#q-67-http-www-cnblogs-com-wangguchangqing-p-6141743-html"><a href="http://www.cnblogs.com/wangguchangqing/p/6141743.html">Q 67</a> :</a></li>
<li><a href="#q-68">Q 68 :</a></li>
<li><a href="#q-69">Q 69 :</a></li>
<li><a href="#q-70">Q 70 :</a></li>
<li><a href="#q-71-http-blog-csdn-net-sunxx1986-article-details-6619144"><a href="http://blog.csdn.net/sunxx1986/article/details/6619144">Q 71</a> :</a></li>
<li><a href="#q-72-http-blog-csdn-net-zerocboy-article-details-51638828"><a href="http://blog.csdn.net/zerocboy/article/details/51638828">Q 72</a> :</a></li>
<li><a href="#q-73">Q 73 :</a></li>
<li><a href="#q-74">Q 74 :</a></li>
<li><a href="#q-75">Q 75 :</a></li>
<li><a href="#q-76">Q 76 :</a></li>
<li><a href="#q-77-http-www-cnblogs-com-always-chang-p-6107437-html"><a href="http://www.cnblogs.com/always-chang/p/6107437.html">Q 77</a> :</a></li>
<li><a href="#q-78">Q 78 :</a></li>
<li><a href="#q-79">Q 79 :</a></li>
<li><a href="#q-80">Q 80 :</a></li>
<li><a href="#q-81">Q 81 :</a></li>
<li><a href="#q-82">Q 82 :</a></li>
<li><a href="#q-82-1">Q 82 :</a></li>
</ul></li>
</ul></li>
<li><a href="#span-id-prog-其他-span"><span id = "prog">其他</span></a>
<ul>
<li><a href="#数据结构与算法">数据结构与算法</a></li>
<li><a href="#计算机网络">计算机网络</a></li>
<li><a href="#操作系统">操作系统</a>
<ul>
<li><a href="#q-1">Q 1 :</a></li>
<li><a href="#q-2">Q 2 :</a></li>
<li><a href="#q-3">Q 3 :</a></li>
<li><a href="#q-4">Q 4 :</a></li>
<li><a href="#q-5">Q 5 :</a></li>
<li><a href="#q-6">Q 6 :</a></li>
<li><a href="#q-7">Q 7 :</a></li>
<li><a href="#q-8">Q 8 :</a></li>
<li><a href="#q-9">Q 9 :</a></li>
<li><a href="#q-10">Q 10 :</a></li>
<li><a href="#q-11">Q 11 :</a></li>
<li><a href="#q-12">Q 12 :</a></li>
<li><a href="#q-13">Q 13 :</a></li>
</ul></li>
</ul></li>
<li><a href="#相关资料">相关资料</a></li>
</ul></li>
</ul>
</nav>
  </div>
</div>

    
    

    
    <div class="post-content">
      

<h4 id="q-24-span-style-color-red-这个没明白-span">Q 24 :<span style="color:red;">这个没明白</span></h4>

<p>题目：
有以下程序：</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
void fun(int *pl, int *p2, int *s){
    s = (int*)calloc(1, sizeof(int));
    *s = *pl + *p2;
    free(s);
}
int main(){
    int a[2] = {1, 2}, b[2] = {40, 50}, *q = a;
    fun(a, b, q);
    printf(&quot;%d\n&quot;, *q);
}
</code></pre>

<p>答案:</p>

<p>1</p>

<p>解答:
考察形参不改变变量值问题。
1. p是指针变量，但是是值传递，其值(指向数组a首元素的地址)并没有改变。<span style="color:red;">为什么 p 是值传递？</span>
2. 通过解引用*p才是数组a的地址，才能改变数组a的值。</p>

<h4 id="q-25-http-www-cnblogs-com-klcf0220-p-6889122-htmls"><a href="http://www.cnblogs.com/klcf0220/p/6889122.htmls">Q 25*</a> :</h4>

<p>题目：
在32位操作系统gcc编译器环境下，下面程序的运行结果为：</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;
class A{
public:
    int b;
    char c;
    virtual void print(){
        cout &lt;&lt; &quot;this is father’s fuction! &quot; &lt;&lt; endl;
    }
};
class B: A{
public:
    virtual void print(){
        cout &lt;&lt; &quot;this is children’s fuction! &quot; &lt;&lt; endl;
    }
};
int main(int argc, char * argv[]){
    cout &lt;&lt; sizeof(A) &lt;&lt; &quot; &quot; &lt;&lt; sizeof(B) &lt;&lt; endl;
    return 0;
}
</code></pre>

<p>答案:
12
12</p>

<p>解答:
考察结构体对齐及虚继承和虚函数继承的区别。
1. A的大小包括本身的虚函数指针及定义的变量。
2. B的大小包括本身的虚函数指针和继承自A的变量b和c。<span style="color:red;">A 的虚函数指针没有吗？</span>
3. 如果是虚继承，则B的大小会增加4字节，增加的内容为指向虚继承的指针。<span style="color:red;">什么是虚继承？什么是指向虚继承的指针？</span></p>

<h4 id="q-26">Q 26 :</h4>

<p>题目：
有如下语句序列：</p>

<pre><code>char str[10]；
cin &gt;&gt; str；
</code></pre>

<p>当从键盘输入&rdquo;I love this game&rdquo;时，str中的字符串是:</p>

<p>答案:
I
解答:
1*. cin遇空格，结束输入。<span style="color:red;">好吧，这个之前没有留意过</span></p>

<h4 id="q-27-span-style-color-red-这个没看懂-span">Q 27 :<span style="color:red;">这个没看懂</span></h4>

<p>题目：
阅读下面代码，程序会打印出来的值是：</p>

<pre><code>#include &lt;stdio.h&gt;
void f(char** p){
    *p += 2;
}
int main(){
    char *a[] = {&quot;123&quot;, &quot;abc&quot;, &quot;456&quot;}, **p;
    p = a;
    f(p);
    printf(&quot;%s\r\n&quot;, *p);
}
</code></pre>

<p>答案:
3</p>

<p>解答:
1. p的类型为char **，(*P)的类型为char *。
2. p原本指向字符串&rdquo;123&rdquo;。
3. *p是char *类型的，*p + 2表示指向第一个字符串第三个字符。
4. p是char *<em>类型的，p + 2表示只想第三个字符串，</em>(p + 2) = &ldquo;456&rdquo;。
5. p的值是*p的地址，虽然p是形参本身值未变，但*p的值在调用函数中被改变。</p>

<h4 id="q-28-http-www-cnblogs-com-skynet-archive-2010-09-05-1818636-html"><a href="http://www.cnblogs.com/skynet/archive/2010/09/05/1818636.html">Q 28</a> :</h4>

<p>题目：
下列对函数double add(int a, int b)进行重载，正确的是：</p>

<p>答案:</p>

<pre><code>int add(int a, int b, int c)
int add(double a, double b)
double add(double a, double b)
</code></pre>

<p>解答:
考察重载概念。
1. 在使用重载时只能通过相同的方法名，不同的参数形式实现。<span style="color:red;">重载时要相同的方法名，不同的参数</span>
2. 不同参数形式包括：<span style="color:red;">这三种形式不知道，之前只知道第一个。</span>
    参数类型不同（至少有一个）
    参数个数不同
    *如果同时在类中，对于函数名相同的 const 函数和非 const 函数能够构成重载
3. 编译器区分重载函数是通过“返回类型 + 函数名 + 参数列表”重新改写函数名还区分重载函数的，但返回值类型在C++中并不作为重载标记。<span style="color:red;">返回值类型在 C++中并不作为重载标记。但是编译器区分重载函数是通过“返回类型+函数名+参数列表”重新改写函数名来区分重载函数的。</span></p>

<h4 id="q-29">Q 29 :</h4>

<p>题目：
在linux gcc下，关于以下代码，正确的是：</p>

<pre><code>std::string&amp; test_str(){
    std::string str = &quot;test&quot;;
    return str;
}
int main(){
    std::string&amp; str_ref = test_str();
    std::cout &lt;&lt; str_ref &lt;&lt; std::endl;
    return 0;
}
</code></pre>

<p><span style="color:red;">有两个地方没看懂，返回的这个 str 的引用真的可以返回吗？而且，为什么 str_ref 是 std::string&amp; 类型的？</span></p>

<p>答案:
编译警告
返回局部变量的引用，运行时出现未知错误。
把代码里的 &amp; 都去掉之后,程序可以正常运行。</p>

<p>解答:
考察调用函数返回值和变量生命周期问题。
1. 返回值为局部变量时可以正确运行。<span style="color:red;">返回值为局部变量时可以正确运行。</span>
2. 返回值为指针时，看指针指向的变量实体定义的位置，如果是定义在栈上的变量则会出错，指向静态区则不会有问题。<span style="color:red;">嗯。</span>
3. 引用返回的是局部变量本身，而不是复制一份再返回，所以结果难以预料。<span style="color:red;">什么意思？什么是返回局部变量自身？什么是复制一份返回？</span>
4. 如果去掉 &amp; ，string类会调用复制构造函数，形同局部变量返回，可以正常运行。<span style="color:red;">这个真的不知道，还可以这样。string 会调用复制构造函数。</span></p>

<h4 id="q-30">Q 30 :</h4>

<p>题目：
下面有关继承、多态、组合的描述，说法<strong>错误</strong>的是：</p>

<p>答案:
继承可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展
覆盖是指不同的函数使用相同的函数名，但是函数的参数个数或类型不同</p>

<p>解答:
考察继承、多态概念。
1. 父类只有非private的部分才能被子类继承访问。<span style="color:red;">嗯。</span>
2. 重载（overload）：函数名相同 、函数参数不同、 必须位于同一个域（类）中。
3. 覆盖（override）：函数名相同 、函数参数相同、 分别位于派生类和基类中（虚函数）。<span style="color:red;">嗯，这个是覆盖，与重载还是不同的，这一点以前看的时候还是没有怎么注意，现在又明确了些。</span></p>

<h4 id="q-31-span-style-color-red-关于拷贝构造函数有些不清楚-span">Q 31 :<span style="color:red;">关于拷贝构造函数有些不清楚</span></h4>

<p>题目：
分析一下这段程序的输出：</p>

<pre><code>#include&lt;iostream&gt;
using namespace std;
class B{
public:
    B(){
        cout &lt;&lt; &quot;default constructor&quot; &lt;&lt; &quot; &quot;;
    }
    ~B(){
        cout &lt;&lt; &quot;destructed&quot; &lt;&lt; &quot; &quot;;
    }
    B(int i):data(i){
        cout &lt;&lt; &quot;constructed by parameter&quot; &lt;&lt; data &lt;&lt; &quot; &quot;;
    }
private:
    int data;
};
B Play(B b){
    return b;
}
int main(int argc, char *argv[]){
    B temp = Play(5);
    return 0;
}
</code></pre>

<p>答案:
constructed by parameter5
destructed
destructed</p>

<p><span style="color:red;">为什么会调用两次 destructed ？</span></p>

<p>解答:
考察赋值运算顺序以及拷贝构造函数。
1. B temp = Play(5) 从右向左执行。
2. 先将&rdquo;5&rdquo;转为形式参数B的类型，之后调用B(int i)打印&rdquo;constructed by parameter&rdquo;。
3. B temp调用B的默认浅拷贝构造函数，完成赋值，由于拷贝构造函数没有输出，所以没有打印东西。<span style="color:red;">什么是默认浅拷贝构造函数？拷贝构造函数什么时候会被调用？这个地方为什么是调用的浅拷贝构造函数？为什么这一步是在 Play() 结束之前进行的？</span>
4. Play()生命周期结束后，b析构打印&rdquo;destructed&rdquo;。
5. main()生命周期结束后，temp析构打印&rdquo;destructed&rdquo;。</p>

<h4 id="q-32">Q 32 :</h4>

<p>题目：</p>

<pre><code>int i=10, j=10, k=3;
k*=i+j;
</code></pre>

<p>k最后的值是？</p>

<p>答案:
60</p>

<p>解答:
考察运算符优先级。
1. +优先级高于*=，等价于k = k * (i +j)。</p>

<h4 id="q-33">Q 33 :</h4>

<p>题目：
#include 命令的功能是：</p>

<p>答案:
在命令处插入一个文本文件</p>

<p>解答:
1. &ldquo;#include&rdquo;在命令处插入，插入文本过程为预处理过程。<span style="color:red;">之前不清楚，这个 #include 在处理的时候是直接把对应的文本加入到这个地方来吗？</span></p>

<h4 id="q-34">Q 34 :</h4>

<p>题目：
有一个类A，其数据成员如下：</p>

<pre><code>class A {
private:
    int a;
public:
    const int b;
    float* &amp;c;
    static const char* d;
    static double* e;
};
</code></pre>

<p>则构造函数中，成员变量一定要通过初始化列表来初始化的是：</p>

<p>答案:
b
c</p>

<p>解答:
考察构造函数初始化列表的使用。
1. 构造函数中，成员变量一定要通过初始化列表来初始化的有以下几种情况：
    const 常量成员：因为常量只能在初始化，不能赋值，所以必须放在初始化列表中。
    引用类型：引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表中。
    没有默认构造函数的类类型：因为使用初始化列表可以不必调用默认构造函数来初始化，而是直接调用拷贝构造函数。<span style="color:red;">什么是初始化列表可以不必调用默认构造函数来初始化？而是直接调用拷贝构造函数？</span></p>

<p><span style="color:red;">上面的 float* &amp;c 是什么？static const char* d 是什么？</span></p>

<h4 id="q-35">Q 35 :</h4>

<p>题目：
在一个64位的操作系统中定义如下结构体：</p>

<pre><code>struct st_task{
    uint16_t id;
    uint32_t value;
    uint64_t timestamp;
};
</code></pre>

<p>同时定义fool函数如下：</p>

<pre><code>void fool(){
    st_task task = {};
    uint64_t a = 0x00010001;
    memcpy(&amp;task, &amp;a, sizeof(uint64_t));
    printf(&quot;%11u, %11u, %11u&quot;, task.id, task.value, task.timestamp);
}
</code></pre>

<p>上述fool()程序的执行结果为：</p>

<p>答案:
1
0
0</p>

<p>解答:
考察结构体对齐。
1. 假设低地址在低位，最低16 bits被赋给低16位的id变量。
2. 接下来16 bits的0x0001部分被赋值给了pading部分，没有被使用。
3. value和timestamp均未被赋值。</p>

<h4 id="q-36">Q 36 :</h4>

<p>题目：
在32位系统中：</p>

<pre><code>char arr[] = {4, 3, 9, 9, 2, 0, 1, 5};
char *str = arr;
sizeof(arr) = (1);
sizeof(str) = (2);
strlen(str) = (3);
</code></pre>

<p>答案:
8；4；5</p>

<p>解答:
考察指针和数组名使用sizeof时区别及转义字符。
1. 数字0对应&rsquo;\0&rsquo;。
2. strlen求字符串长到&rsquo;\0&rsquo;前。</p>

<h4 id="q-37">Q 37 :</h4>

<p>题目：
下面代码输出什么：</p>

<pre><code>#include&lt;stdio.h&gt;
int main( ){
    unsigned int a = 6;
    int b = -20;
    (a + b &gt; 6) ? printf(&quot;&gt;6&quot;) : printf(&quot;&lt;=6&quot;);
    return 0;
}
</code></pre>

<p>答案:
&gt;6</p>

<p>解答:
考察强制类型转换。
1. 必须先明确：int与unsigned相加，int -&gt; unsigned int。
2. int b = -20，首位位&rdquo;1&rdquo;，用无符号型表示是非常大的正整数。</p>

<h4 id="q-38">Q 38 :</h4>

<p>题目：
对于下面的C语言声明描述正确的一项是:</p>

<pre><code>char (*p)[16]
</code></pre>

<p>答案:
p是指向长度为16的字符数组的指针</p>

<p>解答:
考察运算符优先级。
1. p先和那个运算符结合就是什么。
2. char *p[16]：p是一个包含16个元素的Char型指针数组，[]优于*，p[]先结合，是数组。
3. char (*p)[16]：p是一个指针，指向一个包含16个元素的char数组，由于()出现，先和*结合，是指针。</p>

<h4 id="q-39-http-blog-csdn-net-crystal-avast-article-details-7678704"><a href="http://blog.csdn.net/crystal_avast/article/details/7678704">Q 39</a> :</h4>

<p>题目：
下面程序输出结果是什么：</p>

<pre><code>#include&lt;iostream&gt;
using namespace std;
class A{
public:
    A(char *s){
        cout &lt;&lt; s &lt;&lt; endl;
    }
    ~A(){}
};
class B:virtual public A{
public:
    B(char *s1, char*s2):A(s1){
        cout &lt;&lt; s2 &lt;&lt; endl;
    }
};
class C:virtual public A{
public:
    C(char *s1, char*s2):A(s1){
        cout &lt;&lt; s2 &lt;&lt; endl;
    }
};
class D:public B, public C{
public:
    D(char *s1, char *s2, char *s3, char *s4):B(s1, s2), C(s1, s3), A(s1){
        cout &lt;&lt; s4 &lt;&lt; endl;
    }
};
int main() {
    D *p = new D(&quot;class A&quot;, &quot;class B&quot;, &quot;class C&quot;, &quot;class D&quot;);
    delete p;
    return 0;
}
</code></pre>

<p>答案:
class A
class B
class C
class D</p>

<p>解答:
考察虚继承的继承顺序。
1. class B, class C为虚继承。
2. 虚继承（class 派生类:virtual 继承方式 基类名）：从不同的路径继承过来的同名数据成员在内存中就只有一个拷贝。
3. 继承顺序：
    执行基类构造函数，多个基类的构造函数按照被继承的顺序构造。
    执行成员对象的构造函数，多个成员对象的构造函数按照声明的顺序构造。
    执行派生类自己的构造函数。
4. 要执行D构造函数必须先执行参数列表，欲构造B, C必须先构造A，其B, C虚继承A，所以只要执行一次构造函数。</p>

<h4 id="q-40">Q 40 :</h4>

<p>题目：
如下程序段：</p>

<pre><code>char a[] = &quot;xyz&quot;, b[] = {'x', 'y', 'z'};
if(strlen(a) &gt; strlen(b))
    printf(&quot;a &gt; b\n&quot;);
else
    printf(&quot;a &lt;= b\n&quot;);
</code></pre>

<p>则程序输出：</p>

<p>答案:
a&lt;=b</p>

<p>解答:
考察对strlen实现的理解。
1. strlen函数判断字符串长仅仅是通过字符串末的&rsquo;\0&rsquo;（字符0）来确定。
2. 数组b为标识具体&rsquo;\0&rsquo;位置，所以使用strlen结果至少大于等于3。</p>

<h4 id="q-41">Q 41 :</h4>

<p>题目：
执行以下语句，输出结果为：</p>

<pre><code>char *p1 = &quot;hello&quot;;
char *p2 = &quot;world&quot;;
char *p3 = &quot;a piece of cake&quot;;
char *str[] = {p1, p2, p3};
printf(&quot;%c&quot;, *(str[0] + 1));
</code></pre>

<p>答案:
e</p>

<p>解答:
考察指针、指针函数及其操作。
1. str是指针数组，每个元素都是指针。str[0]代表的是char *类型指针p1。
2. p1是char *类型，只想字符串&rdquo;hello&rdquo;，所以这里“+1”代表以字符为单位，结果为&rsquo;e&rsquo;。</p>

<h4 id="q-42-http-www-cnblogs-com-lizhenghn-p-3630405-html"><a href="http://www.cnblogs.com/lizhenghn/p/3630405.html">Q 42</a> :</h4>

<p>题目：
以下表达式那些会被编译器禁止：</p>

<pre><code>int a = 248, b = 4;
int const c = 21;
const int *d = &amp;a;
int *const e = &amp;b;
int const * const f = &amp;a;
</code></pre>

<p>答案:
*c = 32
*d = 43
e = &amp;a
f = 0x321f</p>

<p>解答:
考察指针常量、常量指针。
1. 区分是指针的值不会变还是指针指向的变量值不会变。
2. 方法：
    如果 const 位于 * 的左侧，则 const 就是用来修饰指针所指向的变量，即指针指向为常量。
    如果 const 位于 * 的右侧， const 就是修饰指针本身，即指针本身是常量。
3. 方法使用：
    int const c -&gt; 变量c的值不可改变。
    const int *d -&gt; const在*左（离指针远），修饰指向的变量 -&gt; 指针d指向的变量不可变。
    int *const e-&gt; const在*右（例指针近），修饰指针 -&gt; 指针e的值不可变。
    int const * const f -&gt; 有左有右 -&gt; 值和指针均不可变。</p>

<h4 id="q-43">Q 43 :</h4>

<p>题目：
以下描述正确的是：</p>

<p>答案:
虚函数不能是内联函数
父类的析构函数是非虚的，但是子类的析构函数是虚的，delete子类对象指针会调用父类的析构函数</p>

<p>解答:
1. 虚函数不能是内联函数（编译时展开，必须有实体），不能是静态函数（属于自身类，不属于对象，而虚函数要求有实体），不能是构造函数（尚未建立虚函数表）。
2. delete子类对象是一定会调用父类的析构函数的先调用子类的析构函数然后调用父类的析构函数。</p>

<h4 id="q-44">Q 44 :</h4>

<p>题目：</p>

<pre><code>class Base{
public:
    Base(){
        Init();
    }
    virtual void Init(){
        printf(&quot;Base Init\n&quot;);
    }
    void func(){
        printf(&quot;Base func\n&quot;);
    }
};
class Derived: public Base{
public:
    virtual void Init(){
        printf(&quot;Derived Init\n&quot;);
    }
    void func(){
        printf(&quot;Derived func\n&quot;);
    }
};
int main(){
    Derived d;
    ((Base *)&amp;d)-&gt;func();
    return 0;
}
</code></pre>

<p>答案：
Base Init
Base func</p>

<p>解答：
考察虚函数。
1. 类Derived继承自Base，先调用基类构造函数Base()，再调用基类的init()，输出Base Init。
    构造子类对象，基类中不会调用子类的虚函数：
        基类构造函数 -&gt; 子类构造函数
        子类还没有构造，还没有初始化，属于未初始化对象
        基类不会去调用子类虚函数（哪怕子类中确实声明为虚函数）
2. 虽然 ((Base *)&amp;d)-&gt;func()是虚函数调用的样子，但func()跟本没有被定义为虚函数，基类指针访问基类的func()。</p>

<h4 id="q-45">Q 45 :</h4>

<p>题目：
采用多路复用I/O监听3个套接字的数据时，如果套接字描述符分别是：5,17,19,则：
select(int maxfd, struct fd_set* rdset, NULL, NULL)
中的maxfd应取为：</p>

<p>答案:
20</p>

<p>解答:
 1. maxfd是三个套接字描述符中最大数字加上1。</p>

<h4 id="q-46">Q 46 :</h4>

<p>题目：</p>

<p>下面的说法那个正确：</p>

<pre><code>#define NUMA 10000000
#define NUMB 1000
int a[NUMA], b[NUMB];
void pa(){
    int i, j;
    for(i = 0; i &lt; NUMB; ++i)
        for(j = 0; j &lt; NUMA; ++j)
            ++a[j];
}
void pb(){
    int i, j;
    for(i = 0; i &lt; NUMA; ++i)
        for(j = 0; j &lt; NUMB; ++j)
            ++b[j];
}
</code></pre>

<p>答案:
pb比pa快</p>

<p>解答:
1. 二维数组操作时，因为缓存的原因，外层放小循环，内层放大循环效率高。
2. 个人觉得这题是因为在给大数组赋值时会发生缺页，而小数组赋值不会，所以pb比较快。</p>

<h4 id="q-47">Q 47 :</h4>

<p>题目：
看以下代码：</p>

<pre><code>class A{
public:
    ~A();
};
A::~A(){
    printf(&quot;delete A&quot;);
}
class B : public A{
public:
    ~B();
};
B::~B(){
    printf(&quot;delete B&quot;);
}
</code></pre>

<p>请问执行以下代码的输出是：</p>

<pre><code>A *pa = new B();
delete pa;
</code></pre>

<p>答案:
delete A</p>

<p>解答:
考察虚析构函数。
1. 若B *pb = new B()，则本题会同时输出delete A和delete B。
2. 但如果delete的是一个指向派生类的基类指针，则需要虚构造函数。
3. 这里基类没有定义虚析构函数，属未定义行为。</p>

<h4 id="q-48">Q 48 :</h4>

<p>题目：
下面程序输出结果为？</p>

<pre><code>#include&lt;iostream.h&gt;
#define SUB(X,Y) (X)*Y
int main(){
    int a = 3, b = 4;
    cout &lt;&lt; SUB（a++, ++b);
    return 0;
}
</code></pre>

<p>答案：
15</p>

<p>解答：
考察宏定义命令和自加运算。
1. SUB(3++, ++4) = (3++) * ++4 = 3 * 5 =15
2. 3++是否有括号并不影响，后置自增变量值在本条语句结束前（分号之前）均不改变。
3. 前置自增值在本条语句内立即改变且自增优先级高于*。</p>

<h4 id="q-49">Q 49 :</h4>

<p>题目：
以下代码输出结果为：</p>

<pre><code>int main(){
    int a[2][5] = { {1, 2, 3, 4, 5}, {6, 7, 8, 9, 10} };
    int *ptr = (int *)(&amp;a + 1);
    printf(&quot;%d\n&quot;, *(ptr - 3));
}
</code></pre>

<p>答案：
8</p>

<p>解答：
考察指针运算。
1. 首先需要明确a为二维数组，其类型是int **。
2. 此时对a进行加1操作，操作的单位的每个一维数组。
3. &amp;a的单位可以理解为int ***，对其操作单位是整个二维数组。
4. ptr = (int *)(&amp;a + 1)指向的是二维数组后一个单元。
5. 进行输出操作时，&amp;a + 1被强制转换为int *类型，按四字节读取。
6. ptr - 3从数组末尾回退3个int大小，指向数字8。</p>

<h4 id="q-50">Q 50 :</h4>

<p>题目：
在一台主流配置的PC机上，调用f(35)所需的时间大概是：</p>

<pre><code>int f(int x){
    int s = 0;
    while(x-- &gt; 0)
        s += f(x);
    return max(s, 1);
}
</code></pre>

<p>答案：
几分钟</p>

<p>解答：
考察递归时间复杂度。
1.   O(f(n)) = O(f(n - 1)) + O(f(n - 2)) + &hellip; + O(f(0))
   = 2<em>O(f(n - 2)) + 2</em>(O(f(n - 3)) + &hellip; + 2*O(f(0))
   = 2^35*O(f(0))</p>

<h4 id="q-51">Q 51 :</h4>

<p>题目：
以下代码执行后，val的值是：</p>

<pre><code>unsigned long val = 0;
char a = 0x48;
char b = 0x52;
val = b &lt;&lt; 8 | a;
</code></pre>

<p>答案：
21064</p>

<p>解答：
考察默认类型转换和移位运算及优先级。
1. 移位运算&gt;&gt;优先级高于|，val = (b &lt;&lt; 8) | a;
2. 类型转换：
    运算前转换：
        char/short -&gt; int
        float -&gt; double
        这里的b &lt;&lt; 8计算时先需要把char转为int（b &lt;&lt; 8 = 0x00005200, a = 0x00000048）
    运算中转换：
        int -&gt; long -&gt; unsigned -&gt; double
3. val = 0x00005248 =  21064</p>

<h4 id="q-52">Q 52 :</h4>

<p>题目：
下列说法错误的有：</p>

<p>答案：
在类方法中可用this来调用本类的类方法。
在类方法中只能调用本类中的类方法。
在类方法中绝对不能调用实例方法。</p>

<p>解答：
1. 成员方法又称为实例方法，静态方法又称为类方法。
2. 类方法（静态方法）不属于特定的类，没有this指针。
3. 可以通过类名作用域的方式调用ClassName::fun()。
4. 类中申请一个类对象或者参数传递一个对象或者指针都可以调用实例方法。</p>

<h4 id="q-53">Q 53 :</h4>

<p>题目：</p>

<pre><code>typedef struct{
    char flag[3];
    short value;
}sampleStruct;
union{
    char flag[3];
    short value;
}sampleUnion;
</code></pre>

<p>假设sizeof(char)=1，sizeof(short)=2
那么sizeof(sampleStruct) = ()
    sizeof(sampleUnion) = ()</p>

<p>答案：
6
4</p>

<p>解答：
考察结构体、联合体大小及对齐问题。
1. union：sizeof的取值不仅考虑sizeof最大的成员，还要考虑对齐字节。
2. 注：如果结构体内类型的最大字节小于系统位数对应的字节，那么按类型的最大字节对齐。所以本题结构体按2字节对齐。</p>

<h4 id="q-54">Q 54 :</h4>

<p>题目：
以下程序的输出结果为：</p>

<pre><code>#include &quot;stdio.h&quot;
int func(int x, int y){
    return (x + y);
}
int main(){
    int a = 1, b = 2, c = 3, d = 4, e = 5;
    printf(&quot; %d\n&quot;, func((a + b, b + c, c + a), (d, e)));
    return 0;
}
</code></pre>

<p>答案：
9</p>

<p>解答：
考察逗号运算符。
1. 逗号表达式的结果是其最右边表达式的值。
2. (a + b, b + c, c + a)取最右边的值c + a = 4，(d, e)取最右边的值e = 5。</p>

<h4 id="q-55">Q 55 :</h4>

<p>题目：
当参数*x=1, *y=1, *z=1时，下列不可能是函数add的返回值的：</p>

<pre><code>int add(int *x, int *y, int *z){
    *x += *x;
    *y += *x;
    *z += *y;
    return *z;
}
</code></pre>

<p>答案：
7</p>

<p>解答：
1. 此题考虑x, y, z是否可能指向同一个变量。
2. 可能情况：
    x, y, z指向同一区域：8
    x, y指向同一区域：5
    x, z指向同一区域：5
    y, z指向同一区域：6
    x, y, z指向不同区域：4</p>

<h4 id="q-56">Q 56 :</h4>

<p>题目：
以下涉及到内存管理的代码段中，有错误的是：</p>

<p>答案：
1. int *a = new int(12);
   free(a);
2. int <em>ip = static_cast&lt;int</em>&gt;(malloc(sizeof(int)));
   *ip = 10;
   delete ip;
3. int *ip = new int(12);
   for(int i = 0; i &lt; 12; ++i)
       ip[i] = i;
   delete []ip;</p>

<p>解答：
考察动态内存分配与释放。
1. malloc和free，new和delete配套使用。
2. int *ip = new int(12)：动态分配一个int类型变量并赋值为12，ip指向这个变量。
3. int *ip = new int[12]，表示分配大小为12的int类型数组，ip指向这个数组。</p>

<h4 id="q-57">Q 57 :</h4>

<p>题目：
关于内联函数正确的是：</p>

<p>答案：
在所有类说明中内部定义的成员函数都是内联函数</p>

<p>解答：
考察内联函数。
1. 见答案。
2. 使用内联函数的地方会在编译阶段用内联函数体替换掉。</p>

<h4 id="q-58">Q 58 :</h4>

<p>题目：
以下函数中，和其他函数不属于一类的是：</p>

<p>答案：
pwrite</p>

<p>解答：
考察系统调用和库函数。
1. 常见文件系统的系统函数：
    fcntl 文件控制
    open 打开文件
    creat 创建新文件
    close 关闭文件描述字
    read 读文件
    write 写文件
    read 从文件读入数据到缓冲数组中
    write 将缓冲数组里的数据写入文件
    pread 对文件随机读
    pwrite 对文件随机写</p>

<h4 id="q-59">Q 59 :</h4>

<p>题目：
std::vector::iterator重载了下面哪些运算符：</p>

<p>答案：</p>

<h1 id="toc_36">++</h1>

<p>*</p>

<p>解答：
考察迭代器基本概念。
1. ++和&ndash;用于迭代器以后移动。
2. ==用于判断迭代器是否相等。
3. *用于对迭代器指向的变量的引用。</p>

<h4 id="q-60">Q 60 :</h4>

<p>题目：
请问func(2012,2102)的结果是：</p>

<pre><code>int fuc(int m,int n){
    if(m%n == 0)
        return n；
    else
        return fuc(n,   m%n)；
}
</code></pre>

<p>答案：
2</p>

<p>解答：
考察辗转相除法。
1. 辗转相除法求两个数的最大公约数。</p>

<h4 id="q-61">Q 61 :</h4>

<p>题目：</p>

<pre><code>class Eye{
    public:
    void Look(void);
};
</code></pre>

<p>现在希望定义一个Head类，也想实现Look的功能，应该使用()方法，实现代码重用。</p>

<p>答案：
组合</p>

<p>解答：
考察组合和继承的使用场景。
1. 继承是细化的继承公共的，被继承的基类是抽象出的公共部分。
2. 组合就是在定义类时直接在新类中以原有类的对象作为数据成员。
3. 继承是派生类对基类的扩展和包含，组合是原有类被包含，这里Eye应该被包含在Head内。
4. 优先使用对象组合，而不是继承。</p>

<h4 id="q-62">Q 62 :</h4>

<p>题目：
设m和n都是int类型，那么以下for循环语句：</p>

<pre><code>for(m = 0, n = -1; n = 0; m++, n++)
    n++;
</code></pre>

<p>答案：
循环体一次也不执行</p>

<p>解答：
1. 见答案。</p>

<h4 id="q-63">Q 63 :</h4>

<p>题目：</p>

<pre><code>#pragma pack(2)
class BU{
    int number;
    union UBffer{
        char buffer[13];
        int number;
    }ubuf;
    void foo(){}
    typedef char*(*f)(void*);
    enum{hdd,ssd,blueray}disk;
}bu;
</code></pre>

<p>答案：
22</p>

<p>解答：
考察结构体、联合体、枚举大小综合题。
1. pack(2)，所以int num和union大小分别为4和14没有疑问。
2. 其他部分：
    void foo(){}：0。
    typedef char*(<em>f)(void</em>)：0。
    enum{hdd,ssd,blueray}disk：4。
    无虚函数，不存在虚函数指针的4字节。
3. 枚举类型的sizeof值都是4。</p>

<h4 id="q-64">Q 64 :</h4>

<p>题目：
设变量已正确定义，以下不能统计出一行中输入字符个数（不包含回车符）的程序段是：</p>

<p>答案：
int n = 0;
for(ch = getchar(); ch != &lsquo;\n&rsquo;; n++);</p>

<p>解答：
1. 对于for循环，其初始条件只执行一次，因此ch只从输入流中取一个字符，之后就再不会取字符，因此会死循环。
2. int n = 0; while(getchar() != &lsquo;\n&rsquo;) n++;和int n = 0; while(ch = getchar() != &lsquo;\n&rsquo;) n++;均可。</p>

<h4 id="q-65">Q 65 :</h4>

<p>题目：
假设下面的函数foo会被多线程调用，那么让i、j、k三个变量哪些因为线程间共享访问需要加锁保护:</p>

<pre><code>int i = 0;
void foo(){
    static int j = 0;
    int k = 0;
    i++;
    j++;
    k++;
}
</code></pre>

<p>答案：
i和j</p>

<p>解答：
考察多线程情况下数据加锁问题。
1. 多线程调用时要进行保护时，主要是针对全局变量和静态变量（无论局部或全局）的，函数内的局部变量不会受到影响。
2. i是全局变量，j是静态局部变量。</p>

<h4 id="q-66">Q 66 :</h4>

<p>题目：
在C++面向对象编程语言中，以下阐述不正确的是：</p>

<p>答案：
接口中可以用虚方法
接口中可以包含已经实现的方法</p>

<p>解答：
考察C++抽象类。
1. 接口是一个概念，它在C++中用抽象类来实现。
2. 抽象类必须是纯虚函数。</p>

<h4 id="q-67-http-www-cnblogs-com-wangguchangqing-p-6141743-html"><a href="http://www.cnblogs.com/wangguchangqing/p/6141743.html">Q 67</a> :</h4>

<p>题目：</p>

<pre><code>#include&lt;iostream&gt;
using namespace std;
class MyClass{
public:
    MyClass(int i = 0){
        cout &lt;&lt; i;
    }
    MyClass(const MyClass &amp;x){
        cout &lt;&lt; 2;
    }
    MyClass &amp;operator=(const MyClass &amp;x){
        cout &lt;&lt; 3;
        return *this;
    }
    ~MyClass(){
        cout &lt;&lt; 4;
    }
};
int main(){
    MyClass obj1(1), obj2(2);
    MyClass obj3 = obj1;
    return 0;
}
</code></pre>

<p>运行时的输出结果是：</p>

<p>答案：
122444</p>

<p>解答：
考察拷贝构造函数和赋值运算符的区别。
1. 前两个1和2没有疑问，最后三个析构输出4也没有疑问。
2. C MyClass obj3 = obj1;
    若obj3还不存在，调用拷贝构造函数输出2。
    若obj3存在，obj3 = obj，则调用赋值运算符重载函数。</p>

<h4 id="q-68">Q 68 :</h4>

<p>题目：
有以下程序:</p>

<pre><code>#include &lt; stdio.h &gt;
int main(){
    char a[5][10] ={&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;};
    int i, j;
    char t;
    for (i = 0; i &lt; 2; i++){
        for(j = i + 1; j &lt; 5; j++ ){
            if(a[i][0] &gt; a[j][0]){
                t = a[i][0];
                a[i][0] = a[j][0];
                a[j][0] = t;
            }
        }
    }
    puts(a[1]);
}
</code></pre>

<p>答案：
fwo</p>

<p>解答：
1. 对五个字符串首字母进行冒泡排序。</p>

<h4 id="q-69">Q 69 :</h4>

<p>题目：
两个等价线程并发的执行下列程序，a为全局变量，初始为0，假设printf、++、&ndash;操作都是原子性的，则输出肯定不是哪个：</p>

<p>答案：
0
1</p>

<p>解答：
考察多线程并发结果。</p>

<h4 id="q-70">Q 70 :</h4>

<p>题目：
在32位机器上，设有以下说明和定义：</p>

<pre><code>typedef union{
    long i;
    int k[5];
    char c;
}DATE;
struct data{
    int cat;
    DATE cow;
    double dog;
}too;
DATE max;
</code></pre>

<p>则sizeof(struct data) + sizeof(max)的执行结果是：</p>

<p>答案：
52</p>

<p>解答：
1. 联合体大小为20。
2. 如果最大的基本元素小于等于机器位宽，按照最大基本元素大小对齐，否则按照机器字长对齐，此处对齐单位为4字节。</p>

<h4 id="q-71-http-blog-csdn-net-sunxx1986-article-details-6619144"><a href="http://blog.csdn.net/sunxx1986/article/details/6619144">Q 71</a> :</h4>

<p>题目：
若PAT是一个类，则程序运行时，语句“PAT(*ad)[3];”调用PAT的构造函数的次数是：</p>

<p>答案：
0</p>

<p>解答：
考察数组指针。
1. PAT *at[3]表示指针数组，本质是数组，数组元素是指向PAT的指针，数组大小为3。
2. PAT(*ad)[3]表示数组指针，本质是指针，但该指针指向的是一个数组且数组大小为3。
3. 同理，int *fun()是指针函数，int (*fun)()是函数指针。
4. 这里并未构造PAT对象。</p>

<h4 id="q-72-http-blog-csdn-net-zerocboy-article-details-51638828"><a href="http://blog.csdn.net/zerocboy/article/details/51638828">Q 72</a> :</h4>

<p>题目：
下面有关volatile说法正确的有：</p>

<p>答案：
当读取一个变量时，为提高存取速度，编译器优化时有时会先把变量读取到一个寄存器中，以后再取变量值时，就直接从寄存器中取值
优化器在用到volatile变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份
volatile适用于多线程应用中被几个任务共享的变量</p>

<p>解答：
考察volatile关键字修饰的变量。
1. volatile作用是避免编译器优化，它是随时会变的。和const不矛盾，被const修饰的变量只是在当前作用范围无法修改，但是可能被其它程序修改。
2. const volatile int i = 0; 表示：任何对i的直接修改都是错误的，但是i可能被意外情况修改掉。</p>

<h4 id="q-73">Q 73 :</h4>

<p>题目：
C++中32位单精度浮点数能表示的十进制有效数字是多少位：</p>

<p>答案：
7</p>

<p>解答：
考察浮点数表示。
1. float浮点数含有1bit符号位，8bit阶码，23bit位尾数，加上隐藏位的1，实际可直接表示的数在2^24以内。
2. float可以表示的十进制有效数字7位，double为16位。</p>

<h4 id="q-74">Q 74 :</h4>

<p>题目：
下列关于赋值运算符“=”重载的叙述中，正确的是：</p>

<p>答案：
赋值运算符只能作为类的成员函数重载</p>

<p>解答：
1. 不能被重载的运算符：
    ::  ,  *  .  ?  :
2. 必须作为成员函数重载的运算符：
    =  []  ()  -&gt;</p>

<h4 id="q-75">Q 75 :</h4>

<p>题目：
函数fun的声明为int fun(int *p[4]),以下哪个变量可以作为fun的合法参数：</p>

<p>答案：
int **a</p>

<p>解答：
1. 函数参数为指针数组，数组大小为4。
2.</p>

<h4 id="q-76">Q 76 :</h4>

<p>题目：</p>

<pre><code>char* getmemory(void){
    char p[] = &quot;hello world&quot;;
    return p;
}
void test(void){
    char *str = NULL;
    str = getmemory();
    printf(str);
}
</code></pre>

<p>请问运行Test函数会有什么样的结果</p>

<p>答案：
输出乱码</p>

<p>解答：
1. p是数组，是局部变量。
2. 数组p的生命周期仅存在于getmemory函数中。
3. 返回的指针指向的数据已经在调用结束后被销毁，输出乱码。
4. 可以通过编译，只不过结果非预期。</p>

<h4 id="q-77-http-www-cnblogs-com-always-chang-p-6107437-html"><a href="http://www.cnblogs.com/always-chang/p/6107437.html">Q 77</a> :</h4>

<p>题目：
关于浅复制和深复制的说法，下列说法正确的是：</p>

<p>答案：
浅层复制：只复制指向对象的指针，而不复制引用对象本身。
深层复制：复制引用对象本身。
如果是深拷贝，修改一个对象不会影响到另外一个对象。</p>

<p>解答：
考察深拷贝和浅拷贝。
1. 对象里有指针时，浅拷贝只拷贝指针字面值，并不拷贝指针指向的内容。
2. 深拷贝会重新分配一块空间，并把被拷贝对象中指向的数据逐一复制过去。
3. 对象中有指针时，使用深拷贝。
4. 因为拷贝者和被拷贝里的指针指向同一区域，所以任意一个对数据的修改都会影响到另一个。</p>

<h4 id="q-78">Q 78 :</h4>

<p>题目：
STL中的一级容器有：</p>

<p>答案：
vector, deque, list</p>

<p>解答：
考察STL容器概念。
1. STL中一级容器是容器元素本身是基本类型，非组合类型。</p>

<h4 id="q-79">Q 79 :</h4>

<p>题目：
程序出错在什么阶段：</p>

<pre><code>int main(void){
    http://www.taobao.com
    cout &lt;&lt; &quot;welcome to taobao&quot; &lt;&lt; endl;
}
</code></pre>

<p>答案：
正常运行</p>

<p>解答：
这题有毒。
1. //后面被当做注释了。
2. http本身是label。</p>

<h4 id="q-80">Q 80 :</h4>

<p>题目：
有如下程序段：</p>

<pre><code>class A{
    int _a;
public:
    A(int a): _a(a){}
    friend int f1(A &amp;);
    friend int f2(const A &amp;);
    friend int f3(A);
    friend int f4(const A);
};
</code></pre>

<p>答案：
f1(0)</p>

<p>解答：</p>

<h4 id="q-81">Q 81 :</h4>

<p>题目：
下面叙述错误的是：</p>

<pre><code>char acX[] = &quot;abc&quot;;
char acY[] = {'a', 'b', 'c'};
char *szX = &quot;abc&quot;;
char *szY = &quot;abc&quot;;
</code></pre>

<p>答案：
szX的内容修改后，szY的内容也会被更改</p>

<p>解答：
考察常量区字符串。
1. szX和szY的值（指向的位置）相同。
2. szX和szY指向的&rdquo;abc&rdquo;定义在常量区，不可以修改。</p>

<h4 id="q-82">Q 82 :</h4>

<p>题目：
以下程序输出结果是：</p>

<pre><code>class A{
    public:
    virtual void func(int val = 1){
        std::cout &lt;&lt; &quot;A-&gt;&quot; &lt;&lt; val &lt;&lt; std::endl;
    }
    virtual void test(){
        func();
    }
};
class B : public A{
    public:
        void func(int val = 0){
            std::cout &lt;&lt; &quot;B-&gt;&quot; &lt;&lt; val &lt;&lt; std::endl;
        }
};
int main(int argc ,char* argv[]){
    B*p = new B;
    p-&gt;test();
    return 0;
}
</code></pre>

<p>答案：
B-&gt;1</p>

<p>解答：
1. 由于B类中没有覆盖（重写）基类中的虚函数test，指向派生类B的指针p调用继承自基类的函数test。
2. test函数中继续调用虚函数func，因为虚函数执行动态绑定，p此时的动态类型为B*，因此执行的是B类中的func，输出&rdquo;B-&gt;&ldquo;。
3. 缺省参数值是静态绑定，即此时val的值使用的是基类A中的缺省参数值，其值在编译阶段已经绑定，值为1。
4. 结论：
    virtual函数是动态绑定，而缺省参数值却是静态绑定。
    绝不重新定义继承而来的缺省参数值。</p>

<h4 id="q-82-1">Q 82 :</h4>

<p>题目：
以下程序输出结果是：</p>

<pre><code>class A{
    public:
    virtual void func(int val = 1){
        std::cout &lt;&lt; &quot;A-&gt;&quot; &lt;&lt; val &lt;&lt; std::endl;
    }
    virtual void test(){
        func();
    }
};
class B : public A{
    public:
        void func(int val = 0){
            std::cout &lt;&lt; &quot;B-&gt;&quot; &lt;&lt; val &lt;&lt; std::endl;
        }
};
int main(int argc ,char* argv[]){
    B*p = new B;
    p-&gt;test();
    return 0;
}
</code></pre>

<p>答案：
B-&gt;1</p>

<p>解答：
1. 由于B类中没有覆盖（重写）基类中的虚函数test，指向派生类B的指针p调用继承自基类的函数test。
2. test函数中继续调用虚函数func，因为虚函数执行动态绑定，p此时的动态类型为B*，因此执行的是B类中的func，输出&rdquo;B-&gt;&ldquo;。
3. 缺省参数值是静态绑定，即此时val的值使用的是基类A中的缺省参数值，其值在编译阶段已经绑定，值为1。
4. 结论：
    virtual函数是动态绑定，而缺省参数值却是静态绑定。
    绝不重新定义继承而来的缺省参数值。</p>

<hr />

<h2 id="span-id-prog-其他-span"><span id = "prog">其他</span></h2>

<h3 id="数据结构与算法">数据结构与算法</h3>

<h3 id="计算机网络">计算机网络</h3>

<h3 id="操作系统">操作系统</h3>

<h4 id="q-1">Q 1 :</h4>

<p>题目：
一次I/O操作的结束，有可能导致：</p>

<p>答案：
一个进程由睡眠变就绪</p>

<p>解答：
1. 独占设备：
    进程间互斥的访问这类设备，设备一旦被分配给某个进程，便由该进程独占。I/O操作后自然只有这个进程由等待进入就绪。
2. 共享设备：
    一段时间内允许多个进程同时访问的设备。对I/O设备的访问是并发，而不是并行。一次I/O操作的结束，只是其对应的进程I/O操作的结束，只会唤醒这一个进程。</p>

<h4 id="q-2">Q 2 :</h4>

<p>题目：</p>

<p>在多道程序系统中，系统的现有空闲可用资源能否满足后备作业J的资源要求，是选择作业J进入内存的必要条件。</p>

<p>答案：
错</p>

<p>解答：
进入内存不一定有全部的资源。</p>

<h4 id="q-3">Q 3 :</h4>

<p>题目：
对进程和线程的描述，以下错误的是：</p>

<p>答案：
父进程里的所有线程共享相同的地址空间，父进程的所有子进程共享相同的地址空间
改变进程里面主线程的状态会影响其他线程的行为，改变父进程的状态不会影响其他子进程
多线程会引起死锁，而多进程则不会</p>

<p>解答：
1. 子进程拥有独立的地址空间。
2. 多进程也会死锁。</p>

<h4 id="q-4">Q 4 :</h4>

<p>题目：
在下列说法中，哪个是错误的：</p>

<p>答案：
若进程A和进程B在临界段上互斥，那么当进程A处于该临界段时，它不能被进程B中断
虚拟存储管理中的抖动(thrashing)现象是指页面置换(page replacement)时用于换页的时间远多于执行程序的时间</p>

<p>解答：
1. A进程是可以被B进程中断的，只是B不能进入临界区。
2. 页面抖动现象是由于分配给进程的内存空间过小 + 不合理的置换算法导致的。</p>

<h4 id="q-5">Q 5 :</h4>

<p>题目：
关于读写锁的描述，以下正确的是：</p>

<p>答案：
读写锁在读加锁的状态下，可用进行读共享</p>

<p>解答：
1. 写加锁状态时，其他进行写操作线程会阻塞。
2. 写锁就是防止其他进程读或写. 读锁就是防止在读的时候有写进程进入。</p>

<h4 id="q-6">Q 6 :</h4>

<p>题目：
采用可重定位分区分配方式：</p>

<p>答案：
解决了碎片问题</p>

<p>解答：
1. 通过移动内存中作业的位置，把原来多个分散的小分区拼接成一个大分区的方法称为拼接或紧凑。</p>

<h4 id="q-7">Q 7 :</h4>

<p>题目：
若一个用户进程通过read 系统调用读取一个磁盘文件中的数据，则下列关于此过程的叙述中，正确的是：
Ⅰ. 若该文件的数据不在内存中，则该进程进入睡眠等待状态
Ⅱ. 请求read系统调用会导致CPU从用户态切换到核心态
Ⅲ. read系统调用的参数应包含文件的名称</p>

<p>答案：
Ⅰ &amp; Ⅱ</p>

<p>解答：
1. 通过移动内存中作业的位置，把原来多个分散的小分区拼接成一个大分区的方法称为拼接或紧凑。
2. open系统调用应该包含文件的名称，read只是包含输入流。</p>

<h4 id="q-8">Q 8 :</h4>

<p>题目：
在Bash中，以下哪些说法是正确的：</p>

<p>答案：
$?表示前一个命令的返回值
$#表示参数的数量</p>

<p>解答：
1. $# 是传给脚本的参数个数
2. $0 是脚本本身的名字
3. $1 是传递给该shell脚本的第一个参数
4. $2 是传递给该shell脚本的第二个参数$@ 是传给脚本的所有参数的列表
5. $* 是以一个单字符串显示所有向脚本传递的参数，与位置变量不同，参数可超过9个
6. $$ 是脚本运行的当前进程ID号$? 是显示最后命令的退出状态，0表示没有错误，其他表示有错误</p>

<h4 id="q-9">Q 9 :</h4>

<p>题目：
下列关于线程调度的叙述中，错误的是：</p>

<p>答案：
调用线程的yeild()方法，只会使与当前线程相同优先级的线程获得运行机会
具有相同优先级的多个线程的调度一定是分时的</p>

<p>解答：</p>

<ol>
<li>yeild()使当前线程进入就绪队列，给相同优先级或者高优先级线程机会。</li>
<li>slssp()方法会给其他任何线程提供运行的机会，不论优先级高低均可以。</li>
</ol>

<h4 id="q-10">Q 10 :</h4>

<p>题目：
在存储管理中，采用覆盖与交换技术的目的是:</p>

<p>答案：
减少程序占用的主存空间</p>

<p>解答：
1. 覆盖技术的实现是把程序划分为若干个功能上相对独立的程序段，按照其自身的逻辑结构使那些不会同时运行的程序段共享同一块内存区域。程序段先保存在磁盘上，当有关程序的前一部分执行结束后，把后续程序段调入内存，覆盖前面的程序段。
2. 在分时系统中，用户的进程比内存能容纳的数量更多，系统将那些不再运行的进程或某一部分调出内存，暂时放在外存上的一个后备存储区，通常称为交换区，当需要运行这些进程时，再将它们装入内存。</p>

<h4 id="q-11">Q 11 :</h4>

<p>题目：
下面有关线程的说法错误的是：</p>

<p>答案：
每个线程有自己独立的地址空间
线程包含CPU现场，可以独立执行程序</p>

<p>解答：
1. 在多线程中，多个线程共享一个进程中的地址空间。
2. 线程是CPU调度的最小单位，但不能独立执行程序。</p>

<h4 id="q-12">Q 12 :</h4>

<p>题目：
关于子进程和父进程的说法，下面哪一个是正确的：</p>

<p>答案：
一个进程可以没有父进程或子进程</p>

<p>解答：
1. init进程就没有父进程。</p>

<h4 id="q-13">Q 13 :</h4>

<p>题目：
下面关于软连接的描述，正确的是：</p>

<p>答案：
软链接也叫符号链接
如果原始文件被删除，所有指向它的软链接也都被破坏
软链接指明了原始文件的位置，用户需要对原始文件的位置有访问权限才可以使用</p>

<p>解答：
1. 软链接克服了硬链接的不足，没有任何文件系统的限制，任何用户可以创建指向目录的符号链接。因而现在更为广泛使用，它具有更大的灵活性，甚至可以跨越不同机器、不同网络对文件进行链接。</p>

<h2 id="相关资料">相关资料</h2>

<ul>
<li><a href="https://github.com/linw7/Skill-Tree">Skill-Tree</a></li>
</ul>

    </div>

    
    

    
    

    <footer class="post-footer">
      

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/02-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/01-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%90%86%E8%AE%BA/02-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/04-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/15-%E6%A8%A1%E5%9E%8B%E8%9E%8D%E5%90%88/04-/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">4</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/05-%E5%9F%BA%E7%A1%80%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/03-%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/js/js12-dom2%E5%92%8Cdom3/">
            <span class="next-text nav-default">JS12 DOM2和DOM3</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="iteratelyd@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="http://github.com/iterateself" class="iconfont icon-github" title="github"></a>
      <a href="https://www.zhihu.com/people/thebegin/activities" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="https://www.douban.com/people/68028070/" class="iconfont icon-douban" title="douban"></a>
  <a href="http://iterate.site/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> site pv: <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
    <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> site uv: <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2018
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">iterateself</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>


<script type="text/javascript" src="/dist/even.min.js?v=3.2.0"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>








</body>
</html>
