<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>10 数学概念与方法 - 迭代自己</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="iterateself" />
  <meta name="description" content="10.1 数论初步 10.2 计数与概率基础 10.3 其他数学专题 10.4 竞赛题目选讲 炉⑷=/7(1-丄)(1_丄)…(I -丄) 10.5 训练参考 10章 数学概念与方法 学习目标 E熟练" />

  <meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.47.1" />


<link rel="canonical" href="http://iterate.site/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/04-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8/10-%E6%95%B0%E5%AD%A6%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%96%B9%E6%B3%95/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">




<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<link href="/dist/even.min.css?v=3.2.0" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">




<meta property="og:title" content="10 数学概念与方法" />
<meta property="og:description" content="10.1 数论初步 10.2 计数与概率基础 10.3 其他数学专题 10.4 竞赛题目选讲 炉⑷=/7(1-丄)(1_丄)…(I -丄) 10.5 训练参考 10章 数学概念与方法 学习目标 E熟练" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://iterate.site/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/04-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8/10-%E6%95%B0%E5%AD%A6%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%96%B9%E6%B3%95/" /><meta property="article:published_time" content="2018-06-27T08:59:39&#43;00:00"/>
<meta property="article:modified_time" content="2018-06-27T08:59:39&#43;00:00"/>
<meta itemprop="name" content="10 数学概念与方法">
<meta itemprop="description" content="10.1 数论初步 10.2 计数与概率基础 10.3 其他数学专题 10.4 竞赛题目选讲 炉⑷=/7(1-丄)(1_丄)…(I -丄) 10.5 训练参考 10章 数学概念与方法 学习目标 E熟练">


<meta itemprop="datePublished" content="2018-06-27T08:59:39&#43;00:00" />
<meta itemprop="dateModified" content="2018-06-27T08:59:39&#43;00:00" />
<meta itemprop="wordCount" content="36886">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="10 数学概念与方法"/>
<meta name="twitter:description" content="10.1 数论初步 10.2 计数与概率基础 10.3 其他数学专题 10.4 竞赛题目选讲 炉⑷=/7(1-丄)(1_丄)…(I -丄) 10.5 训练参考 10章 数学概念与方法 学习目标 E熟练"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">迭代自己</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/recent/">
        <li class="mobile-menu-item">最新</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a><a href="/catalog/">
        <li class="mobile-menu-item">完整目录</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">迭代自己</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/recent/">最新</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/catalog/">完整目录</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">10 数学概念与方法</h1>

      <div class="post-meta">
        <span class="post-time"> 2018-06-27 </span>
        
        <span class="more-meta"> 36886 words </span>
        <span class="more-meta"> 74 mins read </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> times read </span>
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  
  <div class="post-toc-content">
    
  </div>
</div>

    
    

    
    <div class="post-content">
      <nav>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li><a href="#10-1-数论初步">10.1 数论初步</a></li>
<li><a href="#10-2-计数与概率基础">10.2 计数与概率基础</a></li>
<li><a href="#10-3-其他数学专题">10.3 其他数学专题</a></li>
<li><a href="#10-4-竞赛题目选讲">10.4 竞赛题目选讲</a></li>
<li><a href="#炉⑷-7-1-丄-1-丄-i-丄">炉⑷=/7(1-丄)(1_丄)…(I -丄)</a></li>
<li><a href="#10-5-训练参考">10.5 训练参考</a></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</nav>

<p>10章 数学概念与方法</p>

<p>学习目标</p>

<p>E熟练掌握扩展欧几里德算法和它的时间复杂度 叵熟练掌握用筛法构造素数表，了解素数定理 E学会求二元线性不定方程的整数解</p>

<p>E熟练掌握模运算规则、快速幂取模算法和模线性方程的解法 E熟悉杨辉三角、二项式定理和组合数的基本性质 E学会推导约数个数公式和欧拉函数公式 E熟练掌握可重集全排列的编码和解码算法</p>

<p>E理解样本空间、事件和概率，学会用组合计数的方法计算离散概率 叵理解条件概率的概念和计算方法 叵理解连续概率和数学期望的概念和计算方法 E熟悉常见计数序列，如Fibonacci数列、Catalan数列等 E熟悉建立递推关系的基本方法、常见错误和实现技巧</p>

<p>没有数学就没有算法；没有好的数学基础，也很难在算法上有所成就。本章介绍算法竞</p>

<p>赛中涉及的常见数学概念和方法，包括数论、排列组合、递推关系和离散概率等。</p>

<h6 id="10-1-数论初步">10.1 数论初步</h6>

<p>数论被“数学王子”高斯誉为整个数学王国的皇后。在算法竞赛中，数论常常以各种面貌</p>

<p>出现，但万变不离其宗，大部分数论题目并不涉及多少特殊的知识，但对数学思维和能力要</p>

<p>求较高。本节介绍几个最为常用的算法，并通过例题展示一些常用的思维方式。</p>

<p>10.1.1 欧几里德算法和唯一分解定理</p>

<p>除法表达式。给出一个这样的除法表达式：；/;/;厂../;，其中；是正整数。除法</p>

<p>表达式应当按照从左到右的顺序求和，例如，表达式1/2/1/2的值为1/4。但可以在表达式中</p>

<p>嵌入括号以改变计算顺序，例如，表达式(<sup>1</sup>&frasl;<sub>2</sub>)/(<sup>1</sup>&frasl;<sub>2</sub>)的值为1。</p>

<p>输入；，    ；，    &hellip;，Xk ,判断是否可以通过添加括号，使表达式的值为整</p>

<p>数。 K&lt;10000， Xi&lt;109。</p>

<p>分析】</p>

<p>表达式的值一定可以写成的形式：^是其中一些七的乘积，而5是其他数的乘积。不 难发现，X2必须放在分母位置，那其他数呢？</p>

<p>幸运的是，其他数都可以在分子位置：</p>

<p>E=XJ(X,iX,/^X^</p>

<p>林&rsquo;…A</p>

<p><img src="97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-193.jpg" alt="img" /></p>

<p>接下来的问题就变成了：判断冗是否为整数。</p>

<p>第1种方法是利用前面介绍的高精度运算：k次乘法加一次除法。显然，这个方法是正确</p>

<p>的，但却比较麻烦。</p>

<p>第2种方法是利用唯一分解定理，把X2写成若干素数相乘的形式：</p>

<p><img src="97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-194.jpg" alt="img" /></p>

<p>然后依次判断每个的约数。这次不用高精度乘法了，只需把所 有^中巧的指数加起来。如果结果比％小，说明还会有巧约不掉，因此冗不是整数。这种方法 在第5章中已经用过，这里不再赘述。</p>

<p>第3种方法是直接约分：每次约掉^和為的最大公约数gcd(A, A2)，则当且仅当约分结束 后；=1时冗为整数，程序如下：</p>

<p>int judge(int* X) {</p>

<p>X[2] /= gcd(X[2], X[1]);</p>

<p>for(int i = 3; i &lt;= k; i++) X[2] /= gcd(X[i], X[2]); return X[2] == 1;</p>

<p>}</p>

<p>整个算法的时间效率取决于这里的gcd算法。尽管依次试除也能得到正确的结果，但还 有一个简单、高效，而且相当优美的算法——辗转相除法。它也许是最广为人知的数论算 法。</p>

<p>辗转相除法的关键在于如下恒等式：gcd(A^) = gcd(6, mod幻。它和边界条件gcd(^, 0)=^一起构成了下面的程序：</p>

<p>int gcd(int a, int b) { return b == 0 ? a : gcd(b, a%b);</p>

<p>这个算法称为欧几里德算法(Euclid algorithm )。既然是递归，那么免不了问一句：会 栈溢出吗？答案是不会。可以证明，gcd函数的递归层数不超过4.785lg^    +    1.6723，其</p>

<p>中#=max{^6}。值得一提的是，让gcd递归层数最多的是gcdCF^&amp;j，其中&amp;是后文要介绍 的 Fibonacci 数。</p>

<p>利用gcd还可以求出两个整数和的最小公倍数lcm(^力)。这个结论很容易由唯一分解定 理得到。设</p>

<p>a = Px&rsquo; P疒…P，</p>

<p>b = p&rsquo;f&rsquo; p/2 …p/r</p>

<p>则</p>

<p>gcd(a,Z?)=乃吨〜广⑽…夕，，/；} lcm(6Z，Z0 = prn^Ml} p^{e2,f2} .. . p^{er,fr}</p>

<p>由此不难验证gcd(^力)*lcm(^力)=^*办。不过即使有了公式也不要大意。如果把lcm写成a * b/gcd(a,b)，可能会因此丢掉不少分数——a*b可能会溢出！正确的写法是先除后乘，即 a/gcd(a,b) * b。这样一来，只要题面上保证最终结果在int范围之内，这个函数就不会出错。 但前一份代码却不是这样：即使最终答案在int范围之内，也有可能中间过程越界。注意这样 的细节，毕竟算法竞赛不是数学竞赛。</p>

<p>10.1.2 Eratosthenes 筛法</p>

<p>无平方因子的数。给出正整数《和讲，区间[«，    m]内的“无平方因子”的数有多少个？整</p>

<p>数^无平方因子，当且仅当不存在A&gt;1，使彳得是女2的倍数。1$必m^1012，m-«&lt;107。</p>

<p>【分析】</p>

<p>对于这样的限制，直接枚举判断会超时：需要判断107个整数，而每个整数还需要花费</p>

<p>一定的时间判断是否没有平方因子。怎么办呢？在介绍具体算法之前，需要学会用 Eratosthenes筛法构造1的素数表。</p>

<p>筛法的思想特别简单：对于不超过《的每个非负整数^，删除2A 3A 4p，&hellip;，当处理完所 有数之后，还没有被删除的就是素数。如果用vis[i]表示/已经被删除，筛法的代码可以写 成：</p>

<p>memset(vis, 0, sizeof(vis));</p>

<p>for(int i = 2; i &lt;= n; i++) for(int j = i*2; j &lt;= n; j+=i) vis[j] = 1;</p>

<p>尽管可以继续改进，但这份代码已经相当高效了。为什么呢？给定外层循环变量/，内 层循环的次数是- , i这样，循环的总次数小于    。这个结论来</p>

<p>源于欧拉在1734年得到的结果：-丁-丁——-=kn.,.,其中欧拉常数产0.577218。这 样低的时间复杂度允许在很短的时间内得到106以内的所有素数。</p>

<p>下面来改进这份代码。首先，在“对于不超过n的每个非负整数中^可以限定为素数 ——只需在第二重循环前加一个判断if(!vis[i])即可。另外，内层循环也不必从/*2开始——它 已经在/=2时被筛掉了。改进后的代码如下：</p>

<p>int m = sqrt(n+0.5);</p>

<p>memset(vis, 0, sizeof(vis));</p>

<p>for(int i = 2; i &lt;= m; i++) if(!vis[i]) for(int j = i*i; j &lt;= n; j+=i) vis[j] = 1;</p>

<p>这里有一个有意思的问题：给定的n , c的值是多少呢？换句话说，不超过n的正整数 中，有多少个是素数呢？</p>

<p>素数定理：「I .」</p>

<p>lnx</p>

<p>其中，我表示不超过的素数的个数。上述定理的直观含义是：它和x/lnx比较接近—— 对于算法入门来说，这已足够。表10-1给出了一些值来加深读者的印象。</p>

<p>表10-1 素数定理的直观验证</p>

<table>
<thead>
<tr>
<th>N</th>
<th>102</th>
<th>103</th>
<th>104</th>
<th>105</th>
<th>106</th>
<th>107</th>
<th>108</th>
</tr>
</thead>

<tbody>
<tr>
<td>酬</td>
<td>25</td>
<td>168</td>
<td>1229</td>
<td>9592</td>
<td>78498</td>
<td>664579</td>
<td>5761455</td>
</tr>

<tr>
<td>n/lnn</td>
<td>22</td>
<td>145</td>
<td>1086</td>
<td>8686</td>
<td>72382</td>
<td>620421</td>
<td>5428681</td>
</tr>
</tbody>
</table>

<p>最后回到原题：如何求出区间内无平方因子的数？方法和筛素数是类似的：对于不超过: 的所有素数^ ,筛掉区间[n, m]内的所有倍数。</p>

<p>10.1.3 扩展欧几里德算法</p>

<p>直线上的点。求直线ox+^y+c=0上有多少个整点(x,y)满足妖^，勾，yeLy^ys]。</p>

<p>【分析】</p>

<p>在解决这个问题之前，首先学习扩展欧几里德算法——找出一对整数(x，y),使得似+吵= gcd(^，^)。注意，这里的和y不一定是正数，也可能是负数或者0。例如，gcd(6,15)=3 , 6*3-</p>

<p>15*1=3，其中^=3，尸-1。这个方程还有其他解，如^=-2，y=1。 下面是扩展欧几里德算法的程序：</p>

<p>void gcd(int a, int b, int&amp; d, int&amp; x, int&amp; y) {</p>

<p>if(!b){ d = a; x = 1; y = 0; }</p>

<p>else{ gcd(b, a%b, d, y, x); y -= x*(a/b); }</p>

<p>}</p>

<p>用数学归纳法并不难证明算法的正确性，此处略去。注意在递归调用时，和y的顺序变 了，而边界也是不难得出的：gcd(^,0)=1*^-0<em>0=^。这样，唯一需要记忆的是y-=x</em>(W)，哪 怕暂时不懂得其中的原因也不要紧。</p>

<p>上面求出了ax+^y=gcd(“力)的一组解(^乃)，那么其他解呢？任取另外一组解(x2,y2)，</p>

<p>则^+咖二^+批(它们都等于gcd(a》))，变形得^^2)=办加-乃)。假设gcd(^》)=g，方程 左右两边同时除以<a href="#bookmark9">g</a><a href="#bookmark9">m</a>，得“&rsquo;(^-^2)=^&rsquo; (y2-y1)，其中“&rsquo;=“/g，b&rsquo;=blg。注意，此时和b互素， 因此^-^一定是b的整数倍。设它为妫&rsquo;，计算得y2-y1=^&lsquo;。注意，上面的推导过程并没有用 到“似+by的右边是什么”，因此得出如下结论。</p>

<p>提示10-1 :设a, b, c为任意整数。若方程3乂+匕丫=〔的一组整数解为(x0,y0)，则它的任 意整数解都可以写成(x0+kb&rsquo;, y0-ka&rsquo;)，其中a&rsquo;=a/gcd(a,b)，b&rsquo;=b/gcd(a,b)，k取任意整数。</p>

<p>有了这个结论，移项得似+by=-c，然后求出一组解即可。例如：</p>

<p>例1 : 6^+15y=9。根据欧几里德算法，已经得到了6x(-2)+15x1=3，两边同时乘以3得6x(-6)+15^3=9，即_x=-6，y=3时6_x+15y=9。</p>

<p>例2 : 6^+15=8，两边除以3得2针5=8/3。左边是整数，右边不是整数，显然无解。综合 起来，有下面的结论。</p>

<p>提示10-2 :设a, b, c为任意整数，g=gcd(a,b)，方程ax+by=g的一组解是(x0,y0)，则 当c是g的倍数时ax+by=c的一组解是(x0c/g, y0c/g);当c不是g的倍数时无整数解。</p>

<p>这样，即完整地解决了本问题。顺便说一句，本题的名称为什么叫“直线上的点”呢？这 是因为在平面坐标系下，ox+^y+c=0是一条直线的方程。</p>

<p>10.1.4 同余与模算术</p>

<p>你需要花多少时间做下面这道题目呢？</p>

<p>123456789*987654321=( )</p>

<p>A．121932631112635266</p>

<p>B．121932631112635267</p>

<p>C．121932631112635268</p>

<p>D．121932631112635269</p>

<p>既然是选择题，不必费力把答案完整地计算出来——4个选项的个位数都不相同，因此</p>

<p>只需要计算出答案的最后一位即可。不难得出，它等于1*9=9。把刚才的解题过程抽象出来</p>

<p>就是下面的式子：</p>

<p>123456789<em>987654321 mod10=((123456789 mod10)</em>(987654321 mod10)) mod10</p>

<p>其中mod 表示除以的余数，C语言表达式是a °% ^。在本章中，一定是正整数，尽 管办＜ 0时表达式a °% b也是合法的(但b=0时会出现除零错)。</p>

<p>不难得到下面的公式：</p>

<p>(ei + b) mod n = ((a mod /?) + (/; mod /?)) mod/?</p>

<p>( a - b) mod n =    — (Z)mod/?) + n) mod n</p>

<p>abniod n = (amod n)(b mod n)mod/?</p>

<p>注意在减法中，由于mod n可能小于b mod n ,需要在结果加上n ,而在乘法中，需要注 意a mod n和b mod n相乘是否会溢出。例如，当n=109时，ab mod n—定在int范围内，但a mod n和b mod n的乘积可能会超过int。需要用long long保存中间结果，例如：</p>

<p>int mul_mod(int a, int b, int n) {</p>

<p>return (int)((long long)a * b % n);</p>

<p>}</p>

<p>当然，如果《本身超过int但又在long long范围内，上述方法就不适用了。在这种情况下，</p>

<p>建议初学者使用高精度乘法——尽管有办法可以避免，但技巧性很强，不推荐初学者学习。</p>

<p>大整数取模。输入正整数《和讲，输出《 mod m的值。«&lt;10100，m&lt;109。</p>

<p>【分析】</p>

<p>首先，把大整数写成“自左向右”的形式： 1234=((1*10+2)*10+3)*10+4，然后用前面的公 式，每步取模，例如：</p>

<table>
<thead>
<tr>
<th>scanf(&rdquo;</th>
<th>%s%d&rdquo;, n, &amp;m);</th>
<th></th>
<th></th>
</tr>
</thead>

<tbody>
<tr>
<td>int len</td>
<td>= strlen(n);</td>
<td></td>
<td></td>
</tr>

<tr>
<td>int ans</td>
<td>= 0;</td>
<td></td>
<td></td>
</tr>

<tr>
<td>for(int</td>
<td>i = 0; i &lt; len;</td>
<td>i++)</td>
<td></td>
</tr>

<tr>
<td>ans</td>
<td>= (int)(((long</td>
<td>long)ans*10 + n[i] -</td>
<td>&lsquo;0&rsquo;) % m);</td>
</tr>

<tr>
<td>printf(</td>
<td>&rdquo;%d\n&rdquo;,ans);</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

<p>当然，也可以把ans声明成long long类型的，然后在输出时临时转换为int，但要注意乘法 溢出的问题。</p>

<p>幕取模。输入正整数“、《和讲，输出mod m的值。久《，m&lt;109。</p>

<p>【分析】</p>

<p>很容易写出下面的代码：</p>

<p>int pow_mod(int a, int n, int m) { int ans = 1;</p>

<p>for(int i = 0; i &lt; n; i++) ans = (int)((long long)ans * n % m);</p>

<p>这个函数的时间复杂度为0(«)，当《很大时速度很不理想。有没有办法算得更快呢？可</p>

<p>以利用分治法：</p>

<p>int pow_mod(int a, int n, int m) { if(n == 0) return 1; int x = pow_mod(a, n/2, m); long long ans = (long long)x * x % m; if (n%2 == 1) ans = ans * a % m; return (int)ans;</p>

<p>}</p>

<p>例如， “29=(“14)2*“，而“14=(“7)2， “7=(“3)2*“， “3=“2*“，一共只做了7次乘法。不知读者</p>

<p>有没有发现，上述递归方式和二分查找很类似——每次规模近似减小一半。因此，时间复杂 度为O(log«)，比0(«)好了很多。</p>

<p>模线性方程组。输入正整数b, «，解方程似三b(mod «)。“, b, «&lt;109。</p>

<p>【分析】</p>

<p>本题中出现了一个新记号：同余。辰b(mod «)的含义是““和b关于模《同余”，即“ mod « = b mod n。 不难得出，^=b(mod «)的充要条件是：“-6是《的整数倍。</p>

<p>提示10-3 : aEb(mod n)的含义是“a和b除以n的余数相同〃，其充要条件是“a-b是n的整 数倍”。</p>

<p>这样，原来的方程就可以理解成：似功是《的正整数倍。设这个“倍数”为y，则似-b=吵， 移项得fla-«y=b，这恰好就是10.1.3节介绍的不定方程(“，《，b是已知量，和y是未知数)！ 接下来的步骤不再介绍。唯一需要说明的是，如果^是方程的解，满feEy( mo d «)的其他整 数y也是方程的解。因此，当谈到同余方程的一个解时，其实指的是一个同余等价类。</p>

<p>尽管算法已无须继续讨论，有一个特殊情况需要引起读者重视。b=1时，似三1(mod«)的 解称为“关于模《的逆( inverse) ，它类似于实数运算中“倒数”的概念。什么时候“的逆存在 呢？根据上面的讨论，方程ox-«y=1要有解。这样，1必须是gcd(a，《)的倍数，因此“和《必须互 素(即gcd(^，《)=1 )。在满足这个条件的前提下，ox=1(mod «)只有唯一解。注意，同余方程 的解是指一个等价类。</p>

<p>提示10-4 :方程axEl(mod n)的解称为a关于模n的逆。当gcd(a,n)=1时，该方程有唯 一解；否则，该方程无解。</p>

<p>10.1.5 应用举例</p>

<p>例题 10-1 巨大的斐波那契数！( Colossal Fibonacci Numbers!, UVa11582 )</p>

<p>输入两个非负整数仏办和正整数《 ( 0&lt;a，b&lt;264，1&lt;«&lt;1000 )，你的任务是计算/(ab)除 以《的余数。其中/(0)=/(1)=1，且对于所有非负整数/，f(i+2)=f(i+1)+f(i)。</p>

<p>【分析】</p>

<p>所有计算都是对《取模的，不妨设F(i)=f：i) mod «。不难发现，当二元组(F(i), F(i+1))出现 重复时，整个序列就开始重复。例如，《=3，序列F(i)的前10项为1，1，2,0,2,2，1，0，1，1，第9、10 项和前两项完全一样。根据递推公式，第11项会等于第3项，第12项等于第4项……</p>

<p>多久会出现重复呢？因为余数最多《种，所以最多《2项就会出现重复。设周期为M，则 只需计算出汽0)〜汽《2)，然后算出汽ab)等于其中的哪一项即可。</p>

<p>例题 10-2 不爽的裁判(Disgruntled Judge, NWERC 2008, UVa12169 )</p>

<p>有个裁判出的题太难，总是没人做，所以他很不爽。有一次他终于忍不住了，心 想： “反正我的题没人做，我干嘛要费那么多心思出题？不如就输入一个随机数，输出一个</p>

<p>随机数吧。 ”</p>

<p>于是他找了3个整数^、a和b，然后按照递推公式x^axw+b) mod 10001计算出了一个长 度为27的数列，其中7是测试数据的组数。然后，他把7和卩x3，…，x2F-i写到输入文件中，x2, x4，…，x27写到了输出文件中。</p>

<p>你的任务就是解决这个疯狂的题目：输入7,    x3，…，x27-1，输出x2, x4，…，x2T。输入保</p>

<p>证7&lt;100，且输入的所有x值为0〜10000的整数。如果有多种可能的输出，任意输出一个即 可。</p>

<p>如果知道了a ,就可以计算出_x2 ,进而根据■Xg^ax^+b) mod 10001算出b。有了a和b ,</p>

<p>就可以在0(7)时间内计算出整个序列了。如果在计算过程中发现和输入矛盾，则这个a是非 法的。由于a是0〜10000的整数(因为递推公式对10001取模)，即使枚举所有的a ,时间效</p>

<p>率也足够高。</p>

<p>例题 10-3 选择与除法(Choose and Divide, UVa10375 )</p>

<p>已知C(m，n)    = m!/(n!(m-n)!),输入整数几    r,    (p&gt;q , r&gt;s , p，q，r，s^10000 ),计</p>

<p>算C(p，q)/C(r，s)。输出保证不超过108 ,保留5位小数。</p>

<p>【分析】</p>

<p>本题正是唯一分解定理的用武之地。组合数C(m，n)的性质将在10.2.1节中介绍，本题只 需要用到它的定义。</p>

<p>首先，求出10000以内的所有素数primes ,然后用数组e表示当前结果的唯一分解式中各 个素数的指数。例如，e={1，0，2，0，0，0，&hellip;}表示21*52=50。主程序如下：</p>

<p>while(cin &gt;&gt; p &gt;&gt; q &gt;&gt; r &gt;&gt; s) { memset(e, 0, sizeof(e)); add_factorial(p, 1); add_factorial(q, -1); add_factorial(p-q, -1); add_factorial(r, -1); add_factorial(s, 1); add_factorial(r-s, 1); double ans = 1;</p>

<p>for(int i = 0; i &lt; primes.size(); i++) ans *= pow(primes[i], e[i]);</p>

<p>printf(&ldquo;%.5lf\n&rdquo;, ans);</p>

<p>}</p>

<p>其中add_factorial(n，d)表示把结果乘以(n!)d ,它的实现如下：</p>

<p>//乘以或除以n. d=0表示乘，d=-1表示除</p>

<p>void add_integer(int n, int d) { for(int i = 0; i &lt; primes.size(); i++) {</p>

<p>while(n % primes[i] == 0) { n /= primes[i]; e[i] += d;</p>

<p>}</p>

<p>if(n == 1) break; // 提前终止循环，节约时间</p>

<p>}</p>

<p>}</p>

<p>void add_factorial(int n, int d) { for(int i = 1; i &lt;= n; i++)</p>

<p>add_integer(i, d);</p>

<p>}</p>

<p>例题10-4最小公倍数的最小和(Minimum Sum LCM, UVa10791 )</p>

<p>输入整数《 ( 1&lt;n&lt;231 )，求至少两个正整数，使得它们的最小公倍数为n，且这些整数 的和最小。输出最小的和。</p>

<p>【分析】</p>

<p>本题再次用到了唯一分解定理。设唯一分解式&rdquo;二“/1^/2..，不难发现每个“广作为一个 单独的整数时最优。</p>

<p>如果就这样匆匆编写程序，可能会掉入陷阱。本题有好几个特殊情况要处理：n=1时答 案为1+1=2 ; n只有一种因子时需要加个1，还要注意n=231-1时不要溢出。</p>

<p>例题 10-5 GCD等于 XOR ( GCD XOR, ACM/ICPC Dhaka 2013, UVa12716 )</p>

<p>输入整数打(1&lt;n&lt;30000000 )，有多少对整数(“，b)满足：1&lt;b&lt;a&lt;n，且gcd(a，b)=“ XOR b。例如n=7时，有4对：(3,2)，(5,4)，(6,4)，(7,6)。</p>

<p>本题看上去很难找到简洁的数学公式，因为gcd和xor看上去似乎毫不相干。不过xor的好 处是：a xor b = c，则a xor c = b，所以可以枚举a和c，然后算出6=0! xor c，最后验证一下是 否有gcd（a，b）=c。时间复杂度如何？因为c是a的约数，所以和素数筛法类似，时间复杂度 为《/1+«/2+&hellip;+«/«=0（«log^）。再加上gcd的时间复杂度为0（log«），所以总的时间复杂度 为 O（n（logn）2）。</p>

<p>我们还可以做得更好。上述程序写出来之后，可以打印一些满足gcd（a，b）=a xor b=c的三 元组（a，b，c），然后很容易发现一个现象 ： c=a-b。</p>

<p>证明如下：不难发现a-b^a xor b，且a-b^c。假设存在c使得a-b&gt;c，则c&lt;a-b^a xor b， 与c=a xor b矛盾。</p>

<p>有了这个结论，还是沿用上述算法，枚举a和c，计算b=a-c，则gcd（a，b）=gcd（a，a-c）=c， 因此只需验证是否有c = a xor b，时间复杂度降为了0（«log«）。</p>

<h6 id="10-2-计数与概率基础">10.2 计数与概率基础</h6>

<p>排列与组合是最基本的计数技巧。本节介绍一些基本的相关知识和方法，供读者参考 加法原理。做一件事情有n个办法，第/个办法有p/种方案，则一共^i+p^u+PM种方</p>

<p>案。</p>

<p>乘法原理。做一件事情有n个步骤，第/个步骤有p^方案，则一共有p1p2&hellip;pn种方案。</p>

<p>乘法原理是加法原理的特殊情况（按照第一步骤进行分类），二者都可用于递推。注意</p>

<p>应用加法原理的关键是分类：各类别之间必须没有重复、没有遗漏。如果有重复，可以使用</p>

<p>容斥原理。</p>

<p>容斥原理。假设班里有10个学生喜欢数学， 15个学生喜欢语文， 21个学生喜欢编程，</p>

<p>一共有多少个学生呢？是10+15+21=46个吗？不是的，因为有些学生可能同时喜欢数学和语</p>

<p>文，或者语文和编程，甚至还可能有三者都喜欢的。为了叙述方便，将喜欢语文、数学、编</p>

<p>程的学生集合分别用或5, C表示，则学生总数等于|^U5UC|。刚才已经说了，如果把这3个集 合的元素个数凶、网、|C|直接加起来，会有一些元素重复统计了，因此需要扣掉4门5|、</p>

<p>|mC|、|Cn^|，但这样一来，又有一小部分多扣了，需要加回来：i^amCi。这样，就得到了 一个公式：</p>

<p>|AU5UC|=|A|+|5|+|C|-|An5|-|5nC|-|CnA|+|An5nC|</p>

<p>一般地，对于任意多个集合，都可以列出这样一个等式，其中左边是所有集合的并的元</p>

<p>素个数，右边是这些集合的“各种搭配”。每个“搭配”都是若干个集合的交集，且每一项前面</p>

<p>的正负号取决于集合的个数——奇数个集合为正，偶数个集合为负。</p>

<p>有重复元素的全排列。有&amp;个元素，其中第/个元素有^个，求全排列个数。</p>

<p>【分析】</p>

<p>令所有nz之和为n，再设答案为X。首先做全排列，然后把所有元素编号，其中第s种元素</p>

<p>编号为1 ~ns （例如，有3个a，两个b，先排列成aabba，然后可以编号为ap^^a］）。这样</p>

<p>做以后，由于编号后所有元素均不相同，方案总数为n的全排列数n!。根据乘法原理，得到 了一个方程 :n1!n2!n3!&hellip;nkX!=n!， 移项即可。</p>

<p>可重复选择的组合。有n个不同元素，每个元素可以选多次，一共选&amp;个元素，有多少 种方法？例如，n=3，A=2时有6种:(1,1)，(1,2)，(1,3)，(2,2)，(2,3)，(3,3)。</p>

<p>【分析】</p>

<p>设第/个元素选&rsquo;个，问题转化为求方程^+x2+&hellip;+_xn4的非负整数解的个数。令yz=xz+1，</p>

<p>则答案Sy1+y2+&hellip;+yn=^+n的正整数解的个数。想象有奸1个数字“1”排成一排，则问题等价</p>

<p>于：把这些“1”分成n个部分，有多少种方法？这相当于在奸n-1个“候选分隔线”中选n-1个， 即 C(k+n-1，n-1 )=C(n+k- 1，k)。</p>

<p>10.2.1 杨辉三角与二项式定理</p>

<p>组合数(.在组合数学中占有重要地位。与组合数相关的最重要的两个内容是杨辉三角和</p>

<p>n</p>

<p>二项式定理。如图10-1所示就是一个杨辉三角</p>

<p>13 3 1 14 6 4 1 1 5 10 W 5 1 1 6 15 20 15 6 1</p>

<p>图10-1 杨辉三角</p>

<p>另一方面，把(a+b)n展开，将得到一个关于的多项式：</p>

<p>(a + /))[’= 1</p>

<p>(a + b)x =a + b</p>

<p>(a + b )2 =a2 + 2ab + h2</p>

<p>(a + bY =a:&rsquo; + 3a~b + 3a b:&rsquo; +b:&rsquo;</p>

<p>(a + hf =a + 4a b + 6a2b&rdquo; + 4ab^ + //</p>

<p>系数正好和杨辉三角一致。一般地，有二项式定理：</p>

<p>Jt=O</p>

<p>这不难理解：^+6)&ldquo;是《个括号连乘，每个括号里任选一项乘起来都会对最后的结果有一</p>

<p>个贡献。如果选了&amp;个a，就一定会选《-&amp;个b，最后的项自然就是aw-^b^。而从《个“里选女个 (同时也相当于《个6里选个)有{:种方法，这也是组合数的定义。</p>

<p>给定《，如何求出(a+b)&ldquo;中所有项的系数呢？ 一个方法是用递推，根据杨辉三角中不难发 现的规律，可以写出如下程序：</p>

<p>memset(C, 0, sizeof&copy;);</p>

<p>for(int i = 0; i &lt;= n; i++) {</p>

<p>C[i][0] = 1;</p>

<p>for(int j = 1; j &lt;= i; j++) C[i][j] = C[i-1][j-1] + C[i-1][j];</p>

<p>}</p>

<p>但遗憾的是，这个算法的时间复杂度是0(&ldquo;2)——尽管只用了杨辉三角的第&rdquo;行的&rdquo;+1个 元素，却把全部&rdquo;行的0(&ldquo;2)个元素都计算了 一遍。</p>

<p><img src="97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-195.jpg" alt="img" /></p>

<p>另一个方法是利用等式，    ，从O开始从左到右递推，例如：</p>

<p>C[0] = 1;</p>

<p>for(int i = 1;</p>

<p>n; i++) C[i] = C[i-1]*(n-i+1)/i;</p>

<p>注意，应该先乘后除，因为C[i-1]/i可能不是整数。但这样一来增加了溢出的可能 性 ——即使最后结果在int或long long范围之内，乘法也可能溢出。如果担心这样的情况出现， 可以先约分，不过一般来说是不必要的。</p>

<p>尽管等式,_ &ldquo;    -的“实际意义”不是很明显，却很容易用组合数公式&lt; -</p>

<p>&rdquo;    a &ldquo;    &rdquo;    A!(/7-A-)!</p>

<p>证明，读者不妨一试。</p>

<p>例题 10-6 无关的元素(Irrelevant Elements, ACM/ICPC NEERC 2004, UVa1635 )</p>

<p>对于给定的n个数ah a2，…，an，依次求出相邻两数之和，将得到一个新数列。重复上述</p>

<p>操作，最后结果将变成一个数。问这个数除以m的余数与哪些数无关？例如n=3，m=2时，第 一次求和得到a^a2，a2+a3，再求和得到ai+2a2+a3，它除以2的余数和“2无关。</p>

<p>1&lt;n&lt;105，2&lt;m&lt;109。</p>

<p>【分析】</p>

<p>显然最后的求和式是aha2，…，an的线性组合。设“2的系数为/(/)，则和式除以m的余数 与口,无关，当且仅当/(/)是i的倍数。不妨看一个简单的例子：</p>

<p><img src="97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-196.jpg" alt="img" /></p>

<p>&lt;7j + 2&lt;72 + a3 cix + 3&lt;72 + 3“3 + “4 + 4队 + 6&lt;73 + 4c/4 + a5</p>

<p>看到最后的结果，你想到了什么？没错， “1 4 6 4 1”正是杨辉三角的第5行！不难证明， 在一般情况下，最后az的系数是这样，问题就变成了C r _中有哪些是m的 倍数。</p>

<p>还记得二项式展开的方法吗？理论上，利用此方法可以递推出所有e -，但它们太大了， 必须用高精度才能存得下。但此问题中所关心的只是“哪些是m的倍数”，受到数论部分中的 启发，只需要依次计算m的唯一分解式中各个素因子在(_中的指数即可完成判断。这些指数 仍然可以用，    递推，并且不会涉及高精度。有的读者可能会尝试直接递推每个</p>

<p>系数除以m的余数，但遗憾的是，递推式中有除法，而模m意义下的逆并不一定存在。</p>

<p>10.2.2 数论中的计数问题</p>

<p>约数的个数。给出正整数n的唯一分解式/, &amp; /, &hellip;＜，求n的正约数的个数。</p>

<p>【分析】</p>

<p>不难看出，n的任意正约数也只能包含&rsquo;A，巧，等素因子，而不能有新的素因子出现。对 于n的某个素因子A，它在所求约数中的指数可以是0，1, 2,…，a^az+1种情况，而且不同的素 因子之间相互独立。根据乘法原理，n的正约数个数为：</p>

<p>k</p>

<p>XI + 1) = (^1 + 1)(^2 + I)…(叫 + 1)</p>

<p>/=]</p>

<p>小于《且与《互素的整数个数。给出正整数n的唯一分解式-    ，求1, 2, 3,</p>

<p>…，n中与n互素的数的个数。</p>

<p>【分析】</p>

<p>用容斥原理。首先从总数n中分别减去是A， p2，…，pk的倍数的个数(对于素数p来</p>

<p>说，“与p互素”和“不是p的倍数”等价)，即    ，然后加上“同时是两个素因子</p>

<p>P&rsquo; P2 Pk</p>

<p>的倍数”的个数    ，再减去“同时是3个素因子的倍数”——写成一个“学术</p>

<p>P&rsquo;Pl P&rsquo;P3 Pk-xPk</p>

<p>味比较浓”的公式就是：</p>

<p>P⑻</p>

<p>Pi</p>

<p>StP2 &gt;&rsquo;</p>

<p>■，pU</p>

<p>这里引入的新记号列&rdquo;）就是题目中所求的结果，称为欧拉函数。强烈建议初学者花一些 时间理解这个公式。对于（A，巧，…，&amp;｝的任意子集^，“不与其中任何一个互素”的元素个数 是^。不过这一项的前面是加号还是减号呢？这取决于中的元素个数——奇数个就是“减</p>

<p>P^s</p>

<p>号”，偶数个就是“加号”。</p>

<p>公式已得出，可计算起来很不方便。如果直接根据公式，需要计算多达2&amp;项的代数和， 甚至可能比“暴力枚举（依次判断1〜&rdquo;中每个数是否与&rdquo;互素）”还要慢。</p>

<p>下一步并不显然。上述公式可以变形成如下的形式：</p>

<p>（p、n、二 w（l&ndash;（I&ndash;）*，，（1&ndash;）</p>

<p>Pi Pk</p>

<p>从而只需要0（幻的计算时间，在刚才的基础上大大提高了效率。为什么这个式子和上一 个等价呢？直接考虑新公式的“展开方式”即可。展开式的每一项是从每个括号各选一个（选 1或者-丄），全部乘起来以后再乘以&rdquo;得到。这不正是最初的推导过程吗？</p>

<p>Pi</p>

<p>如果没有给出唯一分解式，需要用试除法依次判断^内的所有素数是否是&rdquo;的因子。这 样，则需要先生成▲内的素数表。但其实并不用这么麻烦：只需要每次找到一个素因子之后 把它“除干净”，即可保证找到的因子都是素数（想一想，为什么）。</p>

<p>int euler_phi(int n) { int m = (int)sqrt(n+0.5); int ans = n;</p>

<p>for(int i = 2; i &lt;= m; i++) if(n % i == 0) { ans = ans / i * (i-1); while(n % i == 0) n /= i;</p>

<p>}</p>

<p>if(n &gt; 1) ans = ans / n * (n-1); return ans;</p>

<p>}</p>

<p>1〜《中所有数的欧拉phi函数值。并不需要依次计算。可以用与筛法求素数非常类似的 方法，在O（nloglogn）时间内计算完毕，例如（原理请读者体会）：</p>

<table>
<thead>
<tr>
<th>void phi_</th>
<th>table(int</th>
<th>n,</th>
<th>int* phi) {</th>
</tr>
</thead>

<tbody>
<tr>
<td>for(int</td>
<td>i = 2; i</td>
<td>&lt;=</td>
<td>n; i++) phi[i] = 0;</td>
</tr>

<tr>
<td>phi[1]</td>
<td>= 1;</td>
<td></td>
<td></td>
</tr>

<tr>
<td>for(int</td>
<td>i = 2; i</td>
<td>&lt;=</td>
<td>n; i++) if(!phi[i])</td>
</tr>
</tbody>
</table>

<p>for(int j = i; j &lt;= n; j += i) {</p>

<p>if(!phi[j]) phi[j] = j; phi[j] = phi[j] / i * (i-1);</p>

<p>例题 10-7 交表(Send a Table, UVa10820 )</p>

<p>有一道比赛题目，输入两个整数x、y （ 1&lt;x，y&lt;n ），输出某个函数/（x，y）。有位选手想交 表（即事先计算出所有的Xx，y），写在源代码里），但是表太大了，源代码超过了比赛的限 制，需要精简。</p>

<p>好在那道题目有一个性质，使得很容易根据/（x，y）算出Xx*k，    y*k）（其中k是任意正整</p>

<p>数），这样有一些/（x，y）就不需要存在表里了。</p>

<p>输入n （ n&lt;50000 ），你的任务是统计最简的表里有多少个元素。例如，n=2时有3个： （1，1）， （1，2）， （2，1）。</p>

<p>【分析】</p>

<p>本题的本质是：输入n，有多少个二元组（x，y）满足：1&lt;x，y&lt;n，且x和y互素。不难发现除 了（1,1）之外，其他二元组（x，y）中的x和y都不相等。设满足x&lt;y的二元组有Xn）个，那么答案就 是 2f（n）+1。</p>

<p>对照欧拉函数的定义，可以得至!j/(n)=phi(2)+phi(3)+&hellip;+phi(n)，时间复杂度</p>

<p>为 O(nloglogn)。</p>

<p>10.2.3 编码与解码</p>

<p>两个a、一个和一个c组成的所有串可以按照字典序编号为： aabc(1)、 aacb(2)、 abac(3)、 . 、 cbaa(12)</p>

<p>任给一个字符串，能否方便地求出它的编号呢？例如，输入aca^，则应输出5。</p>

<p>下面直接求解一般情况的问题(并不限定字母的种类和个数)。设输入串为^，记硪5)</p>

<p>为S的各个排列中，字典序比5小的串的个数，则可以用递推法求解硪5)，如图10-2所示。</p>

<p>其中边上的字母表示“下一个字母”，/(&gt;)表示多重集^的全排列个数。例如，根据第一个 字母，可以把字典序小于ca^a的字符串分为3种：以a开头的，以开头的，以c开头的，分别 对应成ca^a)的3棵子树。以a开头的所有串的字典序都小于ca^a，所以剩下的字符可以任意排 列，个数为Xc^a);同理，以开头的所有串的字典序也都小于ca^a，个数为Xcaa);以c开头 的串字典序不一定小于ca^a，关键要看后3个字符，因此这部分的个数为硪a^a)，还需要继续 往下分。</p>

<p>至于/函数的求解，大部分组合数学书籍中均有介绍：设字符一共有k类，个数分别为nh n2，…，nk，则这个多重集的全排列个数为</p>

<p>不难算出，，,=11&rsquo;;二&ndash;二:，其他/值分别为/(c办a)=6，/(b)=1，故d(caba)=/(cba)+ /(caa)+/(b)=3+6+1=10。既然“比它小”的个数是10，序号自然就是11 了。</p>

<p>“给物体一个编号”称为编码，同理也有“解码”，即根据序号构造出这个物体。这个过程</p>

<p>和刚才的很接近：依次确定各个位置上的字母即可。例如，要求出序号为8(因此有7个比它</p>

<p>小)的字符串，推理过程如图10-3所示。</p>

<p><img src="97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-198.jpg" alt="img" /></p>

<p>d(ba)</p>

<p><img src="97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-199.jpg" alt="img" /></p>

<p>f(b) d(a)</p>

<p>图10-3 字符串解码的递推过程</p>

<p>图10-2 字符串编码的递推过程</p>

<p>例题 10-8 密码(Password, ACM/ICPC Daejon 2010, UVa1262 )</p>

<p>给两个6行5列的字母矩阵，找出满足如下条件的“密码”：密码中的每个字母在两个矩阵 的对应列中均出现。例如，左数第2个字母必须在两个矩阵中的左数第2列中均出现。例如， 图10-4中，COMPU和DPMAG都满足条件。</p>

<p><img src="97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-201.jpg" alt="img" /></p>

<p><img src="97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-202.jpg" alt="img" /></p>

<p>字典序最小的5个满足条件的密码分别是：ABGAG、ABGAS、ABGAU、ABGPG和 ABGPS。给定k( 1&lt;k&lt;7777 )，你的任务是找出字典序第k小的密码。如果不存在，输出</p>

<p>NO。</p>

<p>【分析】</p>

<p>本题是一个经典的解码问题。首先把不可能出现在答案中的字母排除。例如在上面的例 子中，第1个字母只能是｛A，C，D，W｝，第2个字母只能是｛B，O，P｝，第3个字母只能是 ｛G，M，O，X｝，第4个字母只能是｛A，P｝，第5个字母只能是｛G，S，U｝。</p>

<p>不管第1个字母是多少，后4个字母都有3*4*2*3=72种可能，因此当k&lt;72时，第1个字母 是A，当72&lt;k&lt;144时第1个字母是C，如此等等。再用同样的方法确定第2，3，4，5个字母即 可。</p>

<p>由于k&lt;7777，本题还有一个取巧的方法：直接按照字典序从小到大的顺序递归一个一个 的枚举。虽然代码比递推法要长，但是由于思维难度小，往往能在更短的时间内写完、写 对。</p>

<p>10.2.4 离散概率初步</p>

<p>关于概率有一套很深的理论，不过很多和概率相关的问题并不需要特别的知识，熟悉排</p>

<p>列组合就够了。</p>

<p>第1个例子是：连续抛3次硬币，恰好有两次正面的概率是多少？用H和T来表示正面和 背面(取自英文单词head和tail )，则一共有8种可能的情况：HHH、HHT、HTH、HTT、</p>

<p>THH、THT、TTH、TTT。根据我们对硬币的认识，这8种情况出现的可能性相同，概率各为 1/8。用概率论的专业术语说，这里的｛HHH、HHT、HTH、HTT、THH、THT、TTH、TTT｝ 称为样本空间(Sample Space )。所求的是“恰好有两次正面”这个事件(Event)的概率。借 助于集合的记号，这个事件可以表示为｛HHT，HTH，THH｝，其概率为3/8。</p>

<p>提示10-5 :如果样本空间由有限个等概率的简单事件组成，事件E的概率可以用组合计</p>

<p>数的方法得到：/    。</p>

<p>第2个例子是：如果一间屋子里有23个人，那么“至少有两个人的生日相同”的概率超过</p>

<p>50%。为了简单起见，假定已知每个人的生日都不是2月29日。</p>

<p>尽管看上去复杂了许多，其实这个例子和抛硬币是类似的。每个人的生日是365天中等 概率随机选择的，因此样本空间大小冏=36523。接下来需要计算“至少有两个人生日相同”的 情况有多少种。这个数目不太好直接统计，所以统计“任何两个人的生日都不相同”的数目， 然后用总数减去它即可。公式不难得到：</p>

<p><img src="97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-203.jpg" alt="img" /></p>

<p>不管是/，还是36523都无法储存在mt或者lo</p>

<p>ng long中，但概率是实数，并且此处并不需</p>

<p>要太高的精度，所以可以直接计算，例如：</p>

<p>double P(int n, int m) {</p>

<p>double ans = 1.0; for(int i = 0; i &lt; m; return ans;</p>

<p>}</p>

<p>double birthday(int n, double ans = P(n, m); for(int i = 0; i &lt; m; return 1 - ans;</p>

<p>i++) ans *= (n-i);</p>

<p>int m) {</p>

<p>i++) ans /= n;</p>

<p>函数birthday(365,23)的返回值为0.5073，即50.73°%。别高兴得太早，我们来算一算 birthday(365,365)。直观上，365个人中几乎肯定会有两个人的生日相同，因此 birthday(365,365)应该返回一个很接近1的值。可结果呢？很不幸，返回值为-1.#INF0000 连double都溢出了。</p>

<p>解决方案是边乘边除，而不是连着乘m次，然后再连着除m次。例如：</p>

<p>double birthday(int n, int m) { double ans = 1.0;</p>

<p>for(int i = 0; i &lt; m; i++) ans *= (double)(n-i) / n;</p>

<p>本例说明：正如数论和组合计数中要注意mt和long long溢出一样，在概率计算中要注意 double溢出。顺便说一句，这个“改进版”程序其实有个直接的概率意义：</p>

<p>n n n    n</p>

<p>其中，乓表示“第/个人的生日不和前面的人重复”这个事件。上面的公式用到了这样一个</p>

<p>结论：如果有n个相互独立的事件，则它们同时发生的概率是每个事件单独发生的概率的乘</p>

<p>积，像计数中的乘法原理一样。看上去很直观吧？但严格的定义需要用到“条件概率”的知</p>

<p>识。</p>

<p>条件概率。在概率计算中，条件概率扮演了重要的作用。公式如下：</p>

<p>P(A|B) = P(AB) | P(B)</p>

<p>这里，P(4B)是指，在事件5发生的前提下，事件乂发生的概率，而P(45)是指两个事 彳件4和5同时发生的概率。前面所说的两个事件M独立就是指P(45)=PG4)PCB)。</p>

<p>条件概率中还有一个重要的公式，即贝叶斯公式： P(A|5)=P(5|A) * P(A)/P(5)</p>

<p>全概率公式。计算概率的一种常用方法是：样本空间5分成若干个不相交的部分51， 52， …，Bn，则尸(4)=P(摩 1)*尸(51) + P(4|52)*P(52)+…+P(4|5n)*P(5n)。</p>

<p>公式看上去复杂，但其实思路很简单。例如，参加比赛，得一等奖、二等奖、三等奖和 优胜奖的概率分别为0.1、 0.2、 0.3和0.4，这4种情况下，你会被妈妈表扬的概率分别为1.0、 0.8、 0.5、 0.1，则你被妈妈表扬的总概率为0.1*1.0+0.2*0.8+0.3*0.5+0.4*0.1=0.45。使用全概 率公式的关键是“划分样本空间”，只有把所有可能情况不重复、不遗漏地进行分类，并算出 每个分类下事件发生的概率，才能得出该事件发生的总概率。</p>

<p>例题 10-9 决斗(Headshot, ACM/ICPC NEERC 2009, UVa1636 )</p>

<p>首先在手枪里随机装一些子弹，然后抠了一枪，发现没有子弹。你希望下一枪也没有子 弹，是应该直接再抠一枪(输出SHOOT )呢，还是随机转一下再抠(输出ROTATE )？如果</p>

<p>两种策略下没有子弹的概率相等，输出EQUAL。</p>

<p>手枪里的子弹可以看成一个环形序列，开枪一次以后对准下一个位置。例如，子弹序列 为0011时，第一次开枪前一定在位置1或2（因为第一枪没有子弹），因此开枪之后位于位置 2或3。如果此时开枪，有一半的概率没有子弹。序列长度为2〜100。</p>

<p>【分析】</p>

<p>直接抠一枪没子弹的概率是一个条件概率，等于子串00的个数除以00和01总数（也就是</p>

<p>0的个数）。转一下再抠没子弹的概率等于0的比率。</p>

<p>设子串00的个数为^，0的个数为^，则两个概率分别是和^n。问题就是比较⑽和办2。 前者大就是SHOOT，后者大就是ROTATE。</p>

<p>例题 10-10 奶牛和轿车(Cows and Cars, UVa10491 )</p>

<p>有这么一个电视节目：你的面前有3个门，其中两扇门里是奶牛，另外一扇门里则藏着</p>

<p>奖品——一辆豪华小轿车。在你选择一扇门之后，门并不会立即打开。这时，主持人会给你</p>

<p>个提示，具体方法是打开其中一扇有奶牛的门（不会打开你已经选择的那个门，即使里面是</p>

<p>牛）。接下来你有两种可能的决策：保持先前的选择，或者换成另外一扇未开的门。当然，</p>

<p>你最终选择打开的那扇门后面的东西就归你了。</p>

<p>在这个例子里面，你能得到轿车的概率是2/3（难以置信吧！），方法是总是改变自己 的选择。 2/3这个数是这样得到的：如果选择了两个牛之一，你肯定能换到车前面的门，因 为主持人已经让你看了另外一个牛；而如果你开始选择的就是车，就会换成剩下的牛并且输 掉奖品。由于你的最初选择是任意的，因此选错的概率是2/3。也正是这2/3的情况让你能换 到那辆车（另外1/3的情况你会从车切换到牛）。</p>

<p>现在把问题推广一下，假设有头牛，M两车（门的总数为^+^ ），在最终选择前主持人 会替你打开c个有牛的门（1&lt;^&lt;10000，1&lt;^&lt;10000，0&lt;c&lt;^），输出“总是换门”的策略下，赢 得车的概率。</p>

<p>【分析】</p>

<p>使用全概率公式。打开c个牛门后，还剩^-c头牛，未开的门总数是好卜c，其中有好卜c-1个门可以换（称为“可选门”），换到门的概率就是“可选门”的总数除以“可选门中车门的个</p>

<p>数”。</p>

<p>情况1: 一开始选了牛(概率^ / (好幻)，则可选门中车门有个。这种情况的总概率</p>

<p>为 a/(a+b) * b/(a+b-c-1)。</p>

<p>情况2 :—开始选了车(概率为W (a+b))，则可选门中车门只有b-1个，概率为b/(a+b) * (b-1)/(a+b-c-1)。</p>

<p>加起来得(ab+b(b-1)) / ((a+b)(a+b-c-1))。</p>

<p>例题 10-11 条件概率(Probability|Given, UVa11181 )</p>

<p>有《个人准备去超市逛，其中第/个人买东西的概率是Pz。逛完以后你得知有r个人买了东</p>

<p>西。根据这一信息，请计算每个人实际买了东西的概率。输入《 ( 1分$20 )和〃(0&lt;r&lt;n )， 输出每个人实际买了东西的概率。</p>

<p>【分析】</p>

<p>“r个人买了东西”这个事件叫冗，“第/个人买东西”这个事件为馬，则要求的是条件概 率P(EE)。根据条件概率公式，P(EE) = P(EE) / P(E)。</p>

<p>P(E)依然可以用全概率公式。例如，n=4，r=2，有6种可能：1100, 1010, 1001, 0110, 0101, 0011，其中1100的概率为Pi<em>P2</em>(1-P3)*(1-P4)，其他类似，设置4幻表示第女个人是否买 东西(1表示买，0表示不买)，则可以用递归的方法枚举恰好有r个4幻=1的情况。</p>

<p>如何计算P(EE)呢？方法一样，只是枚举的时候要保证第4i]=1。不难发现，其实可以</p>

<p>用一次枚举就计算出所有的值。用tot表示上述概率之和，sum[i]表示4i]=1的概率之和，则答 案为 P(Ei)/P(E)=sum[i]/tot。</p>

<p>例题 10-12 纸牌游戏(Double Patience, NEERC 2005, UVa1637 )</p>

<p>36张牌分成9堆，每堆4张牌。每次可以拿走某两堆顶部的牌，但需要点数相同。如果有 多种拿法则等概率的随机拿。例如，9堆顶部的牌分别为KS, KH, KD, 9H, 8S, 8D, 7C, 7D, 6H，则有5种拿法(KS,KH), (KS,KD), (KH,KD), (8S,8D), (7C,7D)，每种拿法的概率均为 1/5。 如果最后拿完所有牌则游戏成功。按顺序给出每堆牌的4张牌，求成功概率。</p>

<p>分析】</p>

<p>用9元组表示当前状态，即每堆牌剩的张数，状态总数为59=1953125。设d[/]表示状 态/对应的成功概率，则根据全概率公式，d[/]为后继状态的成功概率的平均值，按照动态规 划的写法计算即可。</p>

<h6 id="10-3-其他数学专题">10.3 其他数学专题</h6>

<p>10.3.1 递推</p>

<p>汉诺塔问题。假设有A、B、C 3个轴，有n个直径各不相同、从小到大依次编号为1, 2, 3，&hellip;，n的圆盘按照上小下大的顺序叠放在A轴上。现要求将这n个圆盘移至B轴上并仍按同样 顺序叠放，但圆盘移动时必须遵循下列规则：</p>

<p>□每次只能移动一个圆盘，它必须位于某个轴的顶部。</p>

<p>□圆盘可以插在A、B、C中的任一轴上。</p>

<p>□任何时刻都不能将一个较大的圆盘压在较小的圆盘之上。</p>

<p>【分析】</p>

<p>这个问题看上去很容易，但当n稍大一点时，手工移动就开始变得困难起来。下面直接 给出递归解法：首先，把前n-1个圆盘放到C轴；接下来把n号圆盘放到B轴；最后，再把前n-1个盘子放到B轴，如图10-5所示。</p>

<p>图10-5 根据递归解法建立汉诺塔的递推关系</p>

<p>图10-4中还给出了n个圆盘所需步数Xn)的递推式：f(n)=2/(n-1)+1。如果把f(n)的值从小 到大列出来，即1,3,7,15,31,63,127,255&hellip;，你会发现其实有一个简单的表达式：f&gt;)=2n-1。</p>

<p>用数学归纳法不难证明：f(1)=1满足等式。假设n=k满足等式，即f(k)=2k-1，则n=k+1</p>

<p>时，fk+1)=2f；k)+1=2(2k-1)+1=2k+1-2+1=2k+1-1。因此n=k+1 也满足等式。由数学归纳法可 知，n取任意正整数均成立。</p>

<p>如果还不熟悉数学归纳法，其实从上面的证明过程已经能看出来其基本原理——其实它 正是一种递归证明。只要边界处理好(f(1)=1满足)，递归时缩小规模(用k来证明k+1 )， 然后在“相信递归”(假设n=k成立)的前提下证明即可。</p>

<p>提示10-6：数学归纳法是一种利用递归的思想证明的方法。如果要讨论的对象具有某 种递归性质(如正整数)，可以考虑用数学归纳法。</p>

<p>Fibonacci数列。先来考虑一个简单的问题：楼梯有n个台阶，上楼可以一步上一阶，也 可以一步上两阶。一共有多少种上楼的方法？</p>

<p>这是一道计数问题。在没有思路时，不妨试着找规律。n=5时，一共有8种方法：</p>

<p>5=1+1+1+1+1</p>

<p>5=2+1+1+1</p>

<p>5=1+2+1+1</p>

<p>5=1+1+2+1</p>

<p>5=1+1+1+2</p>

<p>5=2+2+1</p>

<p>5=2+1+2</p>

<p>5=1+2+2</p>

<p>其中有5种方法第1步走了1阶(灰色)， 3种方法第1步走了2阶。没有其他可能了。假 设An)为n个台阶的走法总数，把n个台阶的走法分成两类。</p>

<p>第1类：第1步走1阶。剩下还有n-1阶要走，有?(n-1)种方法。</p>

<p>第2类：第1步走2阶。剩下还有n-2阶要走，有Xn-2)种方法。</p>

<p>这样，就得到了递推式：/(n)=/(n-1)+/(n-2)。不要忘记边界情况：f(1)=1，f(2)=2。当 然，也可以认为边界是f(0)=/(1)=1。把f(n)的前几项列出：1, 1,2, 3, 5, 8，&hellip;。</p>

<p>再例如，把雌雄各一的一对新兔子放入养殖场中。每只雌兔从第2个月开始每月产雌雄</p>

<p>各一的一对新兔子。试问第n个月后养殖场中共有多少对兔子？</p>

<p>还是先找找规律。</p>

<p>第1个月：一对新兔子h。用小写字母表示新兔子。</p>

<p>第2个月：还是一对新兔子，不过已经长大，具备生育能力了，用大写字母表示。</p>

<p>第3个月：尺1生了一对新兔子r2，—共两对。</p>

<p>第4个月：尺1又生一对r3，—共3对。另外，^长大了，变成R2。</p>

<p>第5个月：R^R2各生一对，记为『4和^，共5对。此外，r3长成R3。</p>

<p>第6个月：Rp R,R3各生一对，记为r6~r8，共8对，同时r4到r5长大。</p>

<p>把这些数排列起来：1, 1, 2, 3, 5, 8,&hellip;，和刚才的一模一样！事实上，可以直接推导出递 推关系/(n)=/(n-1)+/(n-2):第n个月的兔子由两部分组成，一部分是上个月就有的老兔子，一 部分是上个月出生的新兔子。前一部分等于八n-1)，后一部分等于八n-2)(第n-1个月时具有生 育能力的兔子数就等于第n-2个月的兔子总数)。根据加法原理，/(n)=/(n-1)+/(n-2)。</p>

<p>提示10-7 :满足FfF^l，Fn=Fn-1+Fn-2的数列称为Fibonacci数列，它的前若干项是1, 1, 2, 3, 5, 8, 13, 21, 34, 55,…。</p>

<p>再例如，有2行n列的长方形方格，要求用n个1*2的骨牌铺满。有多少种铺法？</p>

<p>考虑最左边一列的铺法。如果用一个骨牌直接覆盖，则剩下的2<em>(n-1)方格有/(n-1)种铺 法；如果是用两个横向骨牌覆盖，则剩下的2</em>(n-2)方格有&gt;-2)种方法，如图10-6所示。不 难发现：第一列没有其他铺法，因此/&gt;)=&gt;-1)+&gt;-2)。边界/(0)=1,/(1)=1，恰好是Fibonacci 数列。</p>

<p>这就是多数课本上讲解这道题目的方法，无须多说，因为重点并不在此。笔者曾想到过 另一个解法，与各位读者分享：设第i列是纵向骨牌，则左边i-1列和右边n-i列各有/(/-1)</p>

<p>和/(n-i)种铺法。根据乘法原理，一共有/(i-1)/(n-i)种铺法。然后把i=1,2,3，&hellip;，n的情形全部加 起来，根据加法原理，有：</p>

<p>/(n)=/(0)/(n-1) + /(1)/(n-2)+.+/(n-1)/(0)</p>

<p>这个递推式对不对呢？聪明的读者也许已经看出，这个解法存在两个问题：</p>

<p>(1 )有遗漏。只考虑了第1,2,3，&hellip;，n列是纵向骨牌的情形，但实际上可能所有的骨牌都 是横向的。当且仅当n为偶数时，恰好有一种这样的方案。</p>

<p>(2)有重复。根据“第/列有骨牌”对所有方案进行了分类，但其实这些方案是有重叠 的。例如，第1列和第2列完全可以同时有骨牌。这些方案在递推式中被重复计算了。</p>

<p>既然如此，这个思路是不是走入死胡同了呢？不是的！只要把刚才的推理变得严密起 来，同样可以得到一个正确的递推式：根据从左到右第一条纵向骨牌的列编号分类。如果不 存在，当且仅当n为偶数时有一种方案；当第一条纵向骨牌的列编号为/时，意味着左边/-1列 必须全部是横向骨牌——当/为奇数时恰好有一个方案。而右边n-/列则可以用任意铺法，</p>

<p>共An々)种。换句话说：</p>

<p>n为偶数时，»=&gt;-1)+&gt;-3)+&gt;-5)…+f(1)+1 (最后加上的就是“没有纵向骨牌”的情 形)。</p>

<p>n为奇数时，f(n)=f(n-1)+/(n-3)+/(n-5)&hellip; +f(2)+f(0)。</p>

<p>边界是f(0)=f(1)=1。我们已经知道，问题的答案应该是Fibonacci数列，自然会对这个复 杂的递推式产生怀疑：它真的是正确的吗？</p>

<p>带着这个疑问，笔者写了一个程序。结果出乎意料：居然和Fibonacci数列一样！事实 上，它确实是Fibonacci数列。Fibonacci数列拥有很多有趣的性质，有兴趣的读者可以在网上 搜索更多相关资料。不管怎样，这个“旧题新解”至少说明了两点：</p>

<p>( 1)一个数列可能有多个看上去完全不同的递推式。</p>

<p>( 2)即使是漏洞百出的解法也有可能通过“打补丁”的方式修改正确。</p>

<p>Catalan数。给一个凸n边形，用n-3条不相交的对角线把它分成n-2个三角形，求不同的 方法数目。例如，n=5时，有5种剖分方法，如图10-7所示。</p>

<p>分析】</p>

<p>设答案为fn)。按照某种顺序给凸多边形的各个顶点编号为^，72，…，匕。既然分成的是 三角形，边在最终的剖分中一定恰好属于某个三角形，所以可以根据k进行分 类。不难看出，三角形的左边是一个k边形，右边是一个n-k+1边形(如图10-8 ( a )所 示)。根据乘法原理，包含三角形的方案数为f(k)/(n-k+1);根据加法原理有：</p>

<p>f(n)=f(2)f(n-1) + f(3)f(n-2) +…+ f(n-1)f(2)</p>

<p>边界是f(2)=/(3)=1。不难算出从f(3)开始的前几项/值依次为：1、2、5、14、42、132、 429、 1430、 4862、 16796。</p>

<p>提示10-8 ：在建立递推式时，经常会用到乘法原理，其核心是分步计数。如果可以把 计数分成独立的两个步骤，则总数量等于两步计数之乘积。</p>

<p>另一种思路是考虑匕连出的对角线。对角线把凸n边形分成两部分，一部分是k边 形，另一部分是n-k+2边形(如图10-8 ( b )所示)。根据乘法原理，包含对角线的凸多 边形有/(kf(n-k+2)个。根据对称性，考虑从F2、F3、…、匕出发的对角线也会有同样的结 果，因此一共有nf(3)/(n-1)+/(4)/(n-2)+&hellip;+&gt;-1)/(3))个部分。</p>

<p>A边形</p>

<p>n~k+1边形</p>

<p><img src="97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-208.jpg" alt="img" /></p>

<p>但这并不是正确答案，因为同—个剖分被重复计算了多次！不过这次不必去消除重复 了，因为这些重复很有规律：每个方案恰好被计算了2n-6次——有n-3条对角线，而考虑每 条对角线的每个端点时均计算了一次。这样，得到了/(n)的第2个递推式：</p>

<p>/(n) = (/(3)(n-1)+/(4)/(n-2)+…+/(n-1)/(3)&gt;n/(2n-6)</p>

<p>它和第一个递推式有几分相似，但又不同。把n+1代入第1个递推式后得到：</p>

<p>/(n+1)=/(2)/(n) + /(3)/(n-1) + /(4)/(n-2) +…+ /(n-1)/(3) + /(n)/(2)</p>

<p>灰色部分是相同的！根据第2个递推式，它等于/(n)*(2n-6)/n，把它和/(2)=1—起代入上 式得：</p>

<p>,(&ldquo;+ 1卜/⑻ + /(&rdquo;) • (2&rdquo; -6) / &ldquo; + j(n) =    6,⑻</p>

<p>n</p>

<p>这个递推式和前两个相比就简单多了。这个数列称为Catalan数，也是常见的计数数列。</p>

<p>例题 10-13 危险的组合(Critical Mass, UVa580 )</p>

<p>有一些装有铀(用U表示)和铅(用L表示)的盒子，数量均足够多。要求把n ( n&lt;30) 个盒子放成一行，但至少有3个U放在一起，有多少种放法？例如，n=4, 5, 30时答案分别为3, 8和974791728。</p>

<p>【分析】</p>

<p>设答案为/(n)。既然有3个U放在一起，可以根据这3个U的位置分类——对，根据前面的 经验，要根据“最左边的3个U”的位置分类。假定是i、i+1和i+2这3个盒子，则前i-1个盒子不 能有3个U放在一起的情况。设n个盒子“没有3个U放在一起”的方案数为g(n)=2n-/(n)，则前i-1</p>

<p>个盒子的方案有g(i-1)种。后面的n-i-2个盒子可以随便选择，有2n-i-2种。根据乘法原理和加</p>

<p>法原理，、.，-乙，乂 。</p>

<p>1=1</p>

<p>遗憾的是，这个推理是有瑕疵的。即使前i-1个盒子内部不出现3个U，仍然可能和i、i+1 和i+2组成3个U。正确的方法是强制让第i-1个盒子(如果存在)放L，则前i-2个盒子内部不</p>

<p>能出现连续的3个U。因此；    「，边界</p>

<p>/-2</p>

<p>是f(0)=f(1)=f(2)=0。g(0)=1，g(1)=2，g(2)=4。注意上式中的2n-3对应于/=1 的情况。</p>

<p>例题 10-14 比赛名次(Race, UVa12034 )</p>

<p>A、B两人赛马，最终名次有3种可能：并列第一；A第一B第二；B第一A第二。输 入n ( 1&lt;n&lt;1000 )，求n人赛马时最终名次的可能性的个数除以10056的余数。</p>

<p>【分析】</p>

<p>设答案为f(n)。假设第一名有/个人，有C(n，/)种可能性，接下来有f&gt;/)种可能性，因此 答案为 ZC(n，/f(n-/)。</p>

<p>例题 10-15 杆子的排列(Pole Arrangement, ACM/ICPC Daejeon 2012, UVa1638 )</p>

<p>有高为1, 2, 3,…，n的杆子各一根排成一行。从左边能看到/根，从右边能看到r根，求有 多少种可能。例如，图10-9中的两种情况都满足Z=1，r=2 ( 1&lt;/，r&lt;n&lt;20 )。</p>

<p>图10-9 杆子的排列</p>

<p>【分析】</p>

<p>设亦，M)表示让高度为卜/根杆子排成一行，从左边能看到/根，从右边能看到&amp;根的方 案数。为了方便起见，假定&amp;2。如何进行递推呢？首先尝试按照从小到大的顺序按照各个 杆子。假设已经安排完高度为1〜/-1的杆子，那么高度为/的杆子可能会挡住很多其他杆子， 看上去很难写出递推式。</p>

<p>那么换一个思路：按照从大到小的顺序安排各个杆子。假设已经安排完高度为2〜/的杆 子，那么高度为1的杆子不管放哪里都不会挡住任何一根杆子。有如下3种情况。</p>

<p>情况1 ：插到最左边，则从左边能看到它，从右边看不见（因为^2 ）。</p>

<p>情况2：如果插到最右边，则从右边能看到它，从左边看不见。</p>

<p>情况3 （有/-2个插入位置）：插到中间，则不管从左边还是右边都看不见它。</p>

<p>在第一种情况下，高度为2〜/的那些杆子必须满足：从左边能看到/-1根，从右边能看 到k根，因为只有这样，加上高度为1的杆子之后才是“从左边能看到/根，从右边能看 到k根”。虽然状态成/J，k）表示的是“让高度为卜/的杆子……”，而现在需要把高度为2〜/+1 的杆子排成一行，但是不难发现：其实杆子的具体高度不会影响到结果，只要有/根高度各 不相同的杆子，从左从右看分别能看到/根和k根，方案数就是硪/，/，k）。换句话说，情况1对应 的方案数是硪/-1J-1，k）。类似地，情况2对应的方案数是硪/-1J，k-1），而情况3对应的方案数 是成/-1J，k）*（/-2）。这样，就得到了如下递推式：</p>

<p>d（i，j，k） = d（i-1，j-1，k） + d（i-1，j，k-1） + d（i-1，j，k）*（i-2）</p>

<p>10.3.2 数学期望</p>

<p>数学期望。简单地说，随机变量X的数学期望£¥就是所有可能值按照概率加权的和。例 如，一个随机变量有1/2的概率等于1， 1/3的概率等于2， 1/6的概率等于3，则这个随机变量 的数学期望为1*<sup>1</sup>&frasl;<sub>2</sub>+2*<sup>1</sup>&frasl;<sub>3</sub>+3*<sup>1</sup>&frasl;<sub>6</sub>=5/3。在非正式场合中，可以说这个随机变量“在平均情况 下”等于5/3。在解决和数学期望相关的题目时，可以先考虑直接使用数学期望的定义求解： 计算出所有可能取值，以及对应的概率，最后求加权和，如果遇到困难，则可以考虑使用下 面两个工具：</p>

<p>期望的线性性质。有限个随机变量之和的数学期望等于每个随机变量的数学期望之 和。例如，对于两个随机变量x和y，所x+r）=£A+ey。</p>

<p>全期望公式。类似全概率公式，把所有情况不重复、不遗漏地分成若干类，每类计算</p>

<p>数学期望，然后把这些数学期望按照每类的概率加权求和。</p>

<p>例题 10-16 过河(Crossing Rivers, ACM/ICPC Wuhan 2009, UVa12230 )</p>

<p>你住在村庄A，每天需要过很多条河到另一个村庄B上班。B在A的右边，所有的河都在 中间。幸运的是，每条河上都有匀速移动的自动船，因此每当到达一条河的左岸时，只需等 船过来，载着你过河，然后在右岸下船。你很瘦，因此上船之后船速不变。</p>

<p>日复一日，年复一年，你问自己：从A到B，平均情况下需要多长时间？假设在出门时</p>

<p>所有船的位置都是均匀随机分布。如果位置不是在河的端点处，则朝向也是均匀随机。在陆</p>

<p>地上行走的速度为1。</p>

<p>输入A和B之间河的个数n、长度D ( 0&lt;n&lt;10，1&lt;D&lt;1000 )，以及每条河的左端点坐标离 A的距离^，长度Z和移动速度v ( 0&lt;p&lt;D，0&lt;L&lt;D，1&lt;v&lt;100 )，输出A到B时间的数学期望。 输入保证每条河都在A和B之间，并且相互不会重叠。</p>

<p>【分析】</p>

<p>用数学期望的线性。过每条河的时间为L/v到3L/v的均勻分布，因此期望过河时间为 2L/v。把所有2L/v加起来，再加上D-sum(L)即可。</p>

<p>例题 10-17 糖果(Candy, ACM/ICPC Chengdu 2012, UVa1639 )</p>

<p>有两个盒子各有打(n&lt;2*105 )个糖，每天随机选一个(概率分别为p，1-p )，然后吃一 颗糖。直到有一天，打开盒子一看，没糖了！输入n, p，求此时另一个盒子里糖的个数的数 学期望。</p>

<p>【分析】</p>

<p>根据期望的定义，不妨设最后打开第1个盒子，此时第2个盒子有/颗，则这之前打开 过n+(n-/)次盒子，其中有n次取的是盒子1，其余n-/次取的盒子2，概率为C(2n-/，    n)pn+1</p>

<p>(1-p)n-/。注意p的指数是n+1，因为除了前面打开过n次盒子1之外，最后又打开了一次。</p>

<p>这个概率表达式在数学上是正确的，但是用计算机计算时需要小心：n可能高达20万，</p>

<p>因此C(2n-/，n)可能非常大，而，*1和(1-p)n-/却非常接近0。如果分别计算这3项再乘起来，会 损失很多精度。一种处理方式是利用对数，设v1(/) = ln(C(2n-/，n)) + (n+1)ln(p) + (n-/)ln(1-p)，则“最后打开第1个盒子”对应的数学期望为ev1(/)。</p>

<p>同理，当最后打开的是第2个盒子，对数为v2(/) = ln(C(2n-/， n)) + (n+1)ln(1-p) + (n-i)ln(p)，概率为ev2(/)。根据数学期望的定义，最终答案为sum{/(ev1(/)+ev2(/))}。</p>

<p>例题 10-18 优惠券(Coupons, UVa10288 )</p>

<p>大街上到处在卖彩票，一元钱一张。购买撕开它上面的锡箔，你会看到一个漂亮的图 案。图案有n种，如果你收集到所有n ( n&lt;33 )种彩票，就可以得大奖。请问，在平均情况 下，需要买多少张彩票才能得到大奖呢？如n=5时答案为137/12。</p>

<p>【分析】</p>

<p>已有k个图案，令5=^，拿一个新的需要Z次的概率：st-1(1-s);因此平均需要的次数为(1-s) (1 + 2s + 3s2 + 4s3 + …)=(1-s)^，而s^ = s + 2s2 + 3s3 + &hellip; = ^-(1+s+s2+…)，移项得</p>

<p>(1-s)£=1+s+s2+&hellip;=1/(1-s) = n/(n-k)</p>

<p>换句话说，已有k个图案：平均拿n/(n-k)次就可多搜集一个，所以总次数为：</p>

<p>n(1/n+1/(n-1)+1/(n-2)+. +<sup>1</sup>&frasl;<sub>2</sub>+<sup>1</sup>&frasl;<sub>1</sub>)</p>

<p>10.3.3 连续概率</p>

<p>连续概率。简单地说，随机变量X的数学期望£¥就是所有可能值按照概率加权的和。例 如，一个随机变量有1/2的概率等于1， 1/3的概率等于2， 1/6的概率等于3，则比变量随机。</p>

<p>例题 10-19 概率(Probability, UVa11346 )</p>

<p>在[-¥]*[-¥]区域内随机取一个点P，求以(0，0)和P为对角线的长方形面积大于S的概率 (a，b&gt;0，5&gt;0 )。例如a=10，b=5，S=20，答案为23.35%。</p>

<p>【分析】</p>

<p>根据对称性，只需要考虑[0，a]<em>[0，b]区域取点即可。面积大于S，即吵&gt;S。吵=5是一条双 曲线，所求概率就是[0，a]</em>[0，b]中处于双曲线上面的部分。为了方便，还是求曲线下面的面 积，然后用总面积来减，如图10-10所示。</p>

<p>图10-10 双曲线所围面积</p>

<p>设双曲线和区域［0,列*［0力］左边的交点P是(5/h幻，因此积分就是：</p>

<p>查得1AS的原函数是ln⑶，因此积分部分就是ln⑷-ln(5^)= ln⑽/5)。设面积为m，则答案</p>

<p>为 (m - s - s *ln(m/s)) / m。</p>

<p>注意这样做有个前提，就是双曲线和所求区域相交。如果5〉冰，则概率应为0 ;而如 果太接近0，概率应直接返回1，否则计算ln(m/5)时可能会出错。</p>

<p>例题 10-20 你想当2n元富翁吗？( So you want to be a 2n-aire?, UVa10900 )</p>

<p>在一个电视娱乐节目中，你一开始有1元钱。主持人会问你n个问题，每次你听到问题后 有两个选择：—是放弃回答该问题，退出游戏，拿走奖金；二是回答问题。如果回答正确， 奖金加倍；如果回答错误，游戏结束，你一分钱也拿不到。如果正确地回答完所有n个问 题，你将拿走所有的2n元钱，成为2&rdquo;元富翁。</p>

<p>当然，回答问题是有风险的。每次听到问题后，你可以立刻估计出答对的概率。由于主 持人会随机问问题，你可以认为每个问题的答对概率在Z和1之间均勻分布。输入整数n和实 数t（ 1&lt;n&lt;30，0&lt;t&lt;1 ），你的任务是求出在最优策略下，拿走的奖金金额的期望值。这里的 最优策略是指让奖金的期望值尽量大。</p>

<p>【分析】</p>

<p>假设你刚开始游戏，如果直接放弃，奖金为1；如果回答，期望奖金是多少呢？不仅和 第1题的答对概率相关，而且和答后面的题的情况相关。即：</p>

<p>选择“回答第1题”后的期望奖金 = p * 答对1题后的最大期望奖金</p>

<p>注意，上式中“答对1题后的最大期望奖金”和这次的无关，这提示我们用递推的思想， 用叫i]表示“答对i题后的最大期望奖金”，再加上“不回答”时的情况，可以得到：若第1题答对 概率为^，期望奖金的最大值=max{20, p*d[1]}</p>

<p>这里故意写成20，强调这是“答对0题后放弃”所得到的最终奖金。</p>

<p>上述分析可以推广到一般情况，但是要注意一点：到目前为止，一直假定p是已知的，</p>

<p>而p实际上并不固定，而是在t〜1内均勻分布。根据连续概率的定义，d[i]在概念上等于</p>

<p>max{2z^ p*d[i+1]}在p=t~ 1上的积分。不要害怕“积分”二字，因为虽然在概念上这是一个积 分，但是落实到具体的解法上，仍然只需要基础知识。</p>

<p>因为有max函数的存在，需要分两种情况讨论，即p*d[i+1]&lt;2^p*d[i+1]^2俩种情况。</p>

<p>令p0=max{t, 2Vd[i+1]}（加了一个max是因为根据题目，p^t），则：</p>

<p>□ p&lt;p0时，p*d[i+1]&lt;2z，因此“不回答”比较好，期望奖金等于2Z。</p>

<p>p改0时，“回答”比较好，期望奖金等于d[i]乘以p的平均值（d[i]作为常数被“提出</p>

<p>来” 了)，即(1+^0)/2 * 叫z+1]。</p>

<p>在第一种情况中，，p的实际范围是似0)，因此概率为W=b0-t)/(1-t)。根据全期望公 式， d[i] = 2i * p1 + (1+p0)/2 * d[i+1] * (1-p1)。</p>

<p>边界是破n] =2n，逆向递推出破0]就是本题的答案。</p>

<p>例题 10-21 多边形(Polygon, UVa11971 )</p>

<p>有一根长度为n的木条，随机选k个位置把它们切成k+1段小木条。求这些小木条能组成 一个多边形的概率。</p>

<p>【分析】</p>

<p>不难发现本题的答案与n无关。在一条直线上切似乎难以处理，可以把直线接成一个 圆，多切一下，即在圆上随机选k+1个点，把圆周切成k+1段。根据对称性，两个问题的答案 相同。</p>

<p>新问题就要容易处理得多了： “组不成多边形”的概率就是其中一个小木条至少跨越了半 个圆周的概率。设这个最长的小木条从点/开始逆时针跨越了至少半个圆周，则其他所有点 都在这半个圆周之外，如图10-11所示的灰色部分。</p>

<p>图10-11 木条逆时针跨越所成形状</p>

<p>除了点i之外其他每个点位于灰色部分的概率均为1/2，因此总概率为1/2\点i的取法 有奸1种，因此“组不成多边形”的概率为（奸1）/2\能组成多边形的概率为1-（奸1）/2</p>

<h6 id="10-4-竞赛题目选讲">10.4 竞赛题目选讲</h6>

<p>例题 10-22 统计问题(The Counting Problem, ACM/ICPC Shanghai 2004, UVa1640 )</p>

<p>给出整数“、办，统计“和办(包含“和办)之间的整数中，数字0，1,2,3,4,5,6,7,8,9分别出现 了多少次。1&lt;^，^&lt;108。注意，有可能大于办。</p>

<p>【分析】</p>

<p>解决这类题目的第一步一般都是：令/x«)表示01-1中数字出现的次数，则所求的就 是fd(b+1)-fd(a)。例如，要统计0〜234中4的个数，可以分成几个区间，如表10-2所示。</p>

<p>表10-2 0~ 234所划区间</p>

<table>
<thead>
<tr>
<th>范围</th>
<th>模板集</th>
</tr>
</thead>

<tbody>
<tr>
<td>0〜9</td>
<td>*</td>
</tr>

<tr>
<td>10 〜99</td>
<td>**</td>
</tr>

<tr>
<td>100〜199</td>
<td>1**</td>
</tr>

<tr>
<td>200 〜229</td>
<td>20*， 21<em>， 22</em></td>
</tr>

<tr>
<td>230〜234</td>
<td>230， 231， 232， 233， 234</td>
</tr>
</tbody>
</table>

<p>表10-2中的“模板”指的是一些整数的集合，其中字符“*”表示“任意字符”。例如， 1<strong>表 示以1开头的任意3位数。因为后两个数字完全任意，所以“个位和十位”中每个数字出现的次 数是均等的。换句话说，在模板1</strong>所对应的100个整数的200个“个位和十位”数字中，0〜9 各有20个。而这些数的百位总是1，因此得到：模板1**对应的100个整数包含数字0，2〜9各 20个，数字1有120个。</p>

<p>这样，只需把0~«分成若干个区间，算出每个区间中各个模板所对应的整数包含每个数 字各多少次，就能解决原问题了，细节留给读者思考。</p>

<p>例题10-23 多少块土地( How Many Pieces of Land?, UVa10213)</p>

<p>有一块椭圆形的地。在边界上选《 ( 0&lt;n&lt;231 )个点并两两连接得到n(n-1)/2条线段。它们 最多能把地分成多少个部分？如图10-12所示，n=6时最多能分成31份。</p>

<p>图10-12 n=6时所划分的土地</p>

<p>【分析】</p>

<p>本题需要用到欧拉公式：在平面图中，V-E+F=2，其中V是顶点数，E是边数，F是面 数。因此，只需要计算V和E即可(注意还要减去外面的“无限面”)。</p>

<p>不管是顶点还是边，计算时都要枚举一条从固定点出发(所以最后要乘以n )的对角 线，它的左边有/个点，右边有n-2-/个点。左右点的连线在这条对角线上形成i(n-2-/)个交 点，得到/(n-2-/)+1条线段。每个交点被重复计算了4次，每条线段被重复计算了2次。</p>

<p>本题还有一个有趣之处：n=1〜n=6时答案分别为1、2、4、8、16、31。如果根据前5 项“找规律”得到“公式”2n-1，即就错了。</p>

<p>例题 10-24 ASCII面积(ASCII Area, NEERC 2011, UVa1641 )</p>

<p>在一个铲w ( 2&lt;力，w&lt;100 )的字符矩阵里用“”、“\”和“/”画出一个多边形，计算面积。 如图10-13所示，面积为8。</p>

<p>图 10-13 ASCII 面积</p>

<p>【分析】</p>

<p>这是一道和几何相关的题目，不过不需要高深的几何知识。每个格子要么全白，要么全</p>

<p>黑，要么半白半黑，只要能准确地判断出来即可。字符“\”和“/”都是半白半黑，问题在</p>

<p>于“.”到底是全白还是全黑。</p>

<p>解决方法是从上到下从左到右处理，沿途统计“/”和“\”。当这两个字符出现偶数次时说</p>

<p>明接下来的格子在多边形外；奇数次则说明接下来的格子在多边形内。</p>

<p>例题10-25 约瑟夫的数论问题( Joseph&rsquo;s Problem, NEERC 2005, UVa1363)</p>

<p>输入正整数n和女(1&lt;n，k&lt;109 )，计算k mod</p>

<p>?=i</p>

<p>【分析】</p>

<p>被除数固定，除数逐次加1，直观上余数也应该有规律。假设k/i的整数部分等于p，则k mod i = k-i*p。因为k/(i+1)和k/i差别不大，如果k/(i+1)的整数部分也等于p，则k mod (i+1) = k-(i+1)*p = k-i*p -p = k mod i -p。换句话说，如果对于某一个区间i, i+1, i+2,…,j，k除以它们 的商的整数部分都相同，则k除以它们的余数会是一个等差数列。</p>

<p>这样，可以在枚举i时把它所在的等差数列之和累加到答案中。这需要计算满足[k/j]=</p>

<p>[w]=/»的最大/。</p>

<p>□当^=0时这样的J不存在，所以等差序列一直延续到序列的最后。</p>

<p>□当/»〉0时/为满足的•改的最大/，即j&lt;k/p。除了首项之外的项数j-/&lt;(k-/*p)/p =抑。</p>

<p>例题 10-26 帮帮Tomisu ( Help Mr. Tomisu, UVa11440 )</p>

<p>给定正整数#和似，统计2和M之间有多少个整数满足：的所有素因子都大</p>

<p>于M( 2&lt;N&lt;107，1&lt;M&lt;N，N-M&lt;105 )。输出答案除以 100000007的余数。例</p>

<p>如，N=100，M=10时答案为 43274465。</p>

<p>【分析】</p>

<p>因为M&lt;N，所以N!是M!的整数倍。“所有素因子都大于M”等价于和M!互素。另外，根据 最大公约数的性质，对于k〉M!，k与M!互素当且仅当k    mod M!与M!互素。这样，只需要求</p>

<p>出“不超过M!且与M!互素的正整数个数”，再乘以N!/M!即可。这样，问题的关键就是求出 phi(M!)。因为有多组数据，考虑用递推的方法求出所有的phifac(n)=phi(n!)。由phi函数的公 式：</p>

<h6 id="炉⑷-7-1-丄-1-丄-i-丄">炉⑷=/7(1-丄)(1_丄)…(I -丄)</h6>

<p>Pl Pl    Pk</p>

<p>如果n不是素数，那么n!和(n-1)!的素因子集合完全相同，因此phifac(n)=phifac(n-1)<em>n ; 如果n是素数，那么还会多一项(1-1/n)，即(n-1)/n，约分得phifac(n)=phifac(n-1)</em>(n-1)。</p>

<p>核心代码如下(请读者注意其中的细节，如rn=1的情况)：</p>

<p>int main() { int n, m;</p>

<p>sieve(10000000); //筛法求素数</p>

<p>phifac [1] = phifac [2] = 1; //请读者思考，为什么phifac[1]等于1而不是0 for (int i = 3; i &lt;= 10000000; i + +)    //递推 phifac[i]=phi(i!)%MOD</p>

<p>phifac [i] = (long long) phifac [i-1]    * (vis [i]    ? i : i-1)    % MOD; //vis[i]为真^&gt; i 不</p>

<p>int ans = phifac[m];</p>

<p>for(int i = m+1; i &lt;= n; i++) ans = (long long)ans * i % MOD; printf(&ldquo;%d\n&rdquo;, (ans-1+MOD)%MOD); //注意这里要减1，因为题目从2开始统计</p>

<p>}</p>

<p>return 0;</p>

<p>}</p>

<p>例题 10-27 树林里的树(Trees in a Wood, UVa10214 )</p>

<p>在满足（^&lt;2000，b&lt;2000000 ）的网格中，除了原点之外的整点（即坐标 均为整数的点）各种着一棵树。树的半径可以忽略不计，但是可以相互遮挡。求从原点能看 到多少棵树。设这个值为尺，要求输出尺从，其中#为网格中树的总数。如图10-14所示，只 有黑色的树可见。</p>

<p>【分析】</p>

<p>显然4个坐标轴上各只能看见一棵树，所以可以只数第一象限（即x〉0，y〉0 ），答案乘 以4后加4。第一象限的所有人y都是正整数，能看到（x，y），当且仅当gcd（x，y）=1。</p>

<p>由于范围比较小，b范围比较大，一列一列统计比较快。第列能看到的树的个数等于 0&lt;y&lt;b的数中满足gcd（^，y）=1的y的个数。可以分区间计算。</p>

<p>□    1&lt;y&lt;x :有phi（v）个，这是欧拉函数的定义。</p>

<p>□    .x+1&lt;y&lt;2.x :也有phi（x）个，因为 gcdCx+/，_x）=gcdCx，/）。</p>

<p>□    2_x+1&lt;y&lt;3_x ：也有phi（x）个，因为 gcd（2_x+/，x）=gcdCx，/）。</p>

<p>□ kx+1&lt;y&lt;b :直接统计，需要□&amp;）时间。</p>

<p>换句话说，每次需要计算phi⑻和进行0⑻次直接判断，计算phi⑻需要0（&rsquo;2）时间，而 直接判断只需要0（1）时间。再加上枚举的所有种可能，总时间为C^2）。</p>

<p>例题10-28 (问题抽象)高速公路( Highway, ACM/ICPC CERC 2006, UVa1393)</p>

<p>有一个n行讲列（1&lt;n，rn&lt;300 ）的点阵，问：一共有多少条非水平非竖直的直线至少穿过 其中两个点？如图10-15所示，n=2，rn=4时答案为12，n=rn=3时答案为14。</p>

<p>图10-14 树林里的树</p>

<p>图10-15n行m列点阵</p>

<p>【分析】</p>

<p>不难发现两个方向是对称的，所以只统计“\”型的，然后乘以2。方法是枚举直线的包围 盒大小^*&amp;，然后计算出包围盒可以放的位置。首先，当gcd(^力)〉1时肯定重复了，如图10-16(a)所示，大包围盒^*办满足gcd(^)〉1，在它的对角线和的对角线是同一条直线</p>

<p>(其中 a&rsquo;=a/gcd(a,b)， b&rsquo;=b/gcd(a,b))。</p>

<p>其次，如果放置位置不够靠左，也不够靠上，则它和它“左上方”的包围盒也重复了，如 图10-16 ( b )所示。</p>

<p>(a)    (b)</p>

<p>图 10-16 gcd(a,b)&gt;1 时示意图</p>

<p>假定左上角坐标为(0,0)，则对于左上角在(^y)的包围盒，其“左上方”的包围盒的左上角 为(i^y-办)。这个“左上角”合法的条件是论0且y-^0。</p>

<p>包围盒本身不出界的条件是^+^<m-1 ,y+^<n-1，一共有(m-^)(n-6)个，而“左上方”有包围 盒的情况，即“<^<讲皆1且办<>^-办-1，有c = max(0, m-2a) * max(0, n-2幻种放法。相减得 到：^*办的包围盒有(rn-^)(n-办)-c种放法。</p>

<p>另外要注意应预处理保存所有gcd，而不是边枚举边算，否则会超时。</p>

<p>例题 10-29 魔法GCD （ Magical GCD, ACM/ICPC CERC 2013, UVa1642 ）</p>

<p>输入一个n ( n&lt;100000 )个元素的正整数序列    …    ，，求一个连续子序</p>

<p>列，使得该序列中所有元素的最大公约数与序列长度的乘积最大。例如，5个元素的序列30，</p>

<p>60，20，20，20的最优解为｛60，20，20，20｝，乘积为gcd(60，20，20，20)*4=80。</p>

<p>【分析】</p>

<p>本题看上去和第8章介绍的一些“传统算法题”很像，所以可试着沿用这样一个常见的框 架：从左到右枚举序列的右边界/，然后快速求出左边界/&lt;•，使得MGCD(/J)最大，其中</p>

<p>定义为_ h1    。</p>

<p>如何快速求出i呢？好像那些“传统方法”(单调队列等)都用不上，因为gcd函数并没有 很多“好用”的代数性质。怎么办？还是从数论的角度入手吧。考虑序列5, 8, 6, 2, 6, 8，当j=5 时需要比较i=1, 2, 3, 4, 5时的MGCD(ij)，如表10-3所示。</p>

<p>表 10-3 j=5时比较的 MGCD(i,j)</p>

<table>
<thead>
<tr>
<th>i</th>
<th>gcd表达式</th>
<th>gcd值</th>
<th>序列长度</th>
</tr>
</thead>

<tbody>
<tr>
<td>1</td>
<td>gcd(5，8，6，2，6)</td>
<td>1</td>
<td>5</td>
</tr>

<tr>
<td>2</td>
<td>gcd（8，6，2，6）</td>
<td>2</td>
<td>4</td>
</tr>

<tr>
<td>3</td>
<td>gcd（6，2，6）</td>
<td>2</td>
<td>3</td>
</tr>

<tr>
<td>4</td>
<td>gcd（2，6）</td>
<td>2</td>
<td>2</td>
</tr>

<tr>
<td>5</td>
<td>gcd（6）</td>
<td>6</td>
<td>1</td>
</tr>
</tbody>
</table>

<p>从下往上看，gcd表达式里每次多一个元素，有时gcd不变，有时会变小，而且每次变小 时一定是变成了它的某个约数(想一想，为什么)。换句话说，不同的gcd值最多只有 log2/种！当gcd值相同时，序列长度越大越好，所以可以把表10-3简化成表10-4中的形式。</p>

<p>表10-4 简化表10-3</p>

<table>
<thead>
<tr>
<th>gcd值</th>
<th>1</th>
<th>2</th>
<th>6</th>
</tr>
</thead>

<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

<p>因为表里只有log2/个元素，所以可以依次比较每一个i对应的MGCD(ij)，时间复杂度为</p>

<p>O(logj-)。下面考虑/从5变成6时，这个表会发生怎样的变化。首先，上述所有gcd值都要再 和“6=8取gcd，即表 10-4中第一行的 1, 2, 6分别变成gcd(1,8)=1，gcd(2,8)=2，gcd(6,8)=2。然后</p>

<p>要加入i=6的序列，gcd值为8。由于相同的gcd值只需要保留i的最小值，所以i=5被删除，最 终得到如表10-5所示结果。</p>

<p>表10-5 i=5被删除后的结果</p>

<table>
<thead>
<tr>
<th>gcd值</th>
<th>1</th>
<th>2</th>
<th>6</th>
</tr>
</thead>

<tbody>
<tr>
<td>i</td>
<td>1</td>
<td>2</td>
<td>8</td>
</tr>
</tbody>
</table>

<p>上述过程需要删除gcd相同的重复元素，但因为元素个数只有O(logj)个，即使用二重循 环比较，时间效率也是很高的，每次修改表10-5的时间复杂度为O((log/)2)，总时间复杂度 为O(n(logn)2)。但因为很难构造出每次表里都有接近log2/个元素的数据，实际运行时间和时 间复杂度为O(nlogn)的算法相当。</p>

<h6 id="10-5-训练参考">10.5 训练参考</h6>

<p>数学题目的特点是：思维难度往往远大于编程难度。尽管如此，也有一些程序实现细节</p>

<p>不容忽视，例如，整数溢出和精度误差。本章的例题很多，不过多数题目的难度不大，重点</p>

<p>在于帮助读者巩固相关的知识点。建议读者先学会所有不加星号的例题，然后逐步弄懂有星</p>

<p>号的例题。本章例题列表如表10-6所示。</p>

<p>表10-6 例题列表</p>

<table>
<thead>
<tr>
<th>类别</th>
<th>题号</th>
<th>题目名称（英文）</th>
<th>备注</th>
</tr>
</thead>

<tbody>
<tr>
<td>例题10-1</td>
<td>UVa11582</td>
<td>Colossal FibonacciNumbers!</td>
<td>模算术</td>
</tr>

<tr>
<td>例题10-2</td>
<td>UVa12169</td>
<td>Disgruntled Judge</td>
<td>模算术</td>
</tr>

<tr>
<td>例题10-3</td>
<td>UVa10375</td>
<td>Choose and Divide</td>
<td>唯一分解定理</td>
</tr>

<tr>
<td>例题10-4</td>
<td>UVa10791</td>
<td>Minimum Sum LCM</td>
<td>唯一分解定理</td>
</tr>

<tr>
<td>例题10-5</td>
<td>UVa12716</td>
<td>GCD XOR</td>
<td>数论</td>
</tr>

<tr>
<td>例题10-6</td>
<td>UVa1635</td>
<td>Irrelevant Elements</td>
<td>组合数</td>
</tr>

<tr>
<td>例题10-7</td>
<td>UVa10820</td>
<td>Send a Table</td>
<td>欧拉phi函数</td>
</tr>

<tr>
<td>例题10-8</td>
<td>UVa1262</td>
<td>Password</td>
<td>编码解码问题</td>
</tr>

<tr>
<td>例题10-9</td>
<td>UVa1636</td>
<td>Headshot</td>
<td>离散概率</td>
</tr>

<tr>
<td>例题10-10</td>
<td>UVa10491</td>
<td>Cows and Cars</td>
<td>离散概率</td>
</tr>

<tr>
<td>例题10-11</td>
<td>UVa11181</td>
<td>Probability|Given</td>
<td>离散条件概率</td>
</tr>

<tr>
<td>例题10-12</td>
<td>UVa1637</td>
<td>Double Patience</td>
<td>离散概率</td>
</tr>

<tr>
<td>例题10-13</td>
<td>UVa580</td>
<td>Critical Mass</td>
<td>递推</td>
</tr>

<tr>
<td>例题10-14</td>
<td>UVa12034</td>
<td>Race</td>
<td>递推</td>
</tr>

<tr>
<td>*例题10-15</td>
<td>UVa1638</td>
<td>Pole Arrangement</td>
<td>递推</td>
</tr>

<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

<table>
<thead>
<tr>
<th>例题10-16</th>
<th>UVa12230</th>
<th>Crossing Rivers</th>
<th>数学期望</th>
</tr>
</thead>

<tbody>
<tr>
<td>例题10-17</td>
<td>UVa1639</td>
<td>Candy</td>
<td>数学期望</td>
</tr>

<tr>
<td>例题10-18</td>
<td>UVa10288</td>
<td>Coupons</td>
<td>数学期望</td>
</tr>

<tr>
<td>*例题10-19</td>
<td>UVa11346</td>
<td>Probability</td>
<td>连续概率</td>
</tr>

<tr>
<td>*例题10-20</td>
<td>UVa10900</td>
<td>So you want to be a 2n-aire?</td>
<td>连续概率，数学期望</td>
</tr>

<tr>
<td>*例题10-21</td>
<td>UVa11971</td>
<td>Polygon</td>
<td>连续概率</td>
</tr>

<tr>
<td>例题10-22</td>
<td>UVa1640</td>
<td>The Counting Problem</td>
<td>数位统计</td>
</tr>

<tr>
<td>例题10-23</td>
<td>UVa10213</td>
<td>How Many Pieces of Land?</td>
<td>欧拉公式、计数</td>
</tr>

<tr>
<td>例题10-24</td>
<td>UVa1641</td>
<td>ASCII Area</td>
<td>多边形面积</td>
</tr>

<tr>
<td>例题10-25</td>
<td>UVa1363</td>
<td>Joseph&rsquo;s Problem</td>
<td>数论，数列求和</td>
</tr>

<tr>
<td>*例题10-26</td>
<td>UVa11440</td>
<td>Help Mr. Tomisu</td>
<td>欧拉phi函数</td>
</tr>

<tr>
<td>例题10-27</td>
<td>UVa10214</td>
<td>Trees in a Wood</td>
<td>欧拉phi函数</td>
</tr>

<tr>
<td>例题10-28</td>
<td>UVa1393</td>
<td>Highway</td>
<td>分类统计</td>
</tr>

<tr>
<td>例题10-29</td>
<td>UVa1642</td>
<td>Magical GCD</td>
<td>综合题</td>
</tr>
</tbody>
</table>

<p>本章的习题是本书中数量最多的，不过多数习题的难度不大，主要目的是巩固知识。因</p>

<p>为大多数题目的描述比较简单，建议读者阅读所有题目，并选择感兴趣的题目思考。</p>

<p>习题10-1 砌砖( Add Bricks in the Wall, UVa11040) 45块石头按照如图10-17所示的方式排列，每块石头上有一个整数。</p>

<p>255</p>

<p>10</p>

<p>o</p>

<p>!</p>

<p>3</p>

<p>5</p>

<p>2</p>

<p>rz</p>

<p>j:</p>

<p>I</p>

<p>1</p>

<p>1</p>

<p>1</p>

<p>图10-17 45块石头排列方式</p>

<p>除了最后一行外，每个石头上的整数等于支撑它的两个石头上的整数之和。目前只有奇</p>

<p>数行的左数奇数个位置上的数已知，你的任务是求出其余所有整数。输入保证有唯一解。</p>

<p>习题10-2 勤劳的蜜蜂( Bee Breeding, ACM/ICPC World Finals 1999, UVa808)</p>

<p>如图10-18所示，输入两个格子的编号a和^ （久衫10000 ），求最短距离。例如，19和30 的距离为5（一条最短路是19-7-6-5-15-30）。</p>

<p>习题10-3 角度和正方形( Angles and Squares, ACM/ICPC Beijing 2005, UVa1643)</p>

<p>如图10-19所示，第一象限里有一个角，把n （ n&lt;10）个给定边长的正方形摆在这个角里 （角度任意），使得阴影部分面积尽量大。</p>

<p>」—\」一—\」一\ 厂&rsquo;    /54\    /</p>

<p>/55 \    /    </p>

<p>/    _/5D_/3D_/32_/5^\    /</p>

<p>_/47\    /    /5&amp;</p>

<p>/.t\ /a5\    e\    /</p>

<p>&lsquo;■■■    .&lt;4\    / T-..    .-=G\ m.</p>

<p>/~\    /44\    /妇\    /7T\    _/</p>

<p>_/70\^/43 _^/2a \    /3?\    /62</p>

<p>/    \    /42\    /4D\    /S3\    /</p>

<p>\」一\」研」ZT\」讯」一\ /    \」_/S7\ 咕\」_J</p>

<p>\」\」\    /6S__/    \」</p>

<p>图 10-18 勤劳的蜜蜂问题示意图</p>

<p>图 10-19 角度和正方形问题示意图</p>

<p>习题10-4 素数间隔( Prime Gap, ACM/ICPC Japan 2007, UVa1644)</p>

<p>输入一个整数n，求它后一个素数和前一个素数的差值。输入是素数时输出0。n不超过 1299709 (第 100000个素数)。例如，n=27时输出29-23=6。</p>

<p>习题10-5 不同素数之和( Sum of Different Primes, ACM/ICPC Yokohama 2006, UVa1213)</p>

<p>选择尺个质数，使它们的和等于#。给出A和尺(K1120，K&lt;14 )，问有多少种满足条件 的方案？例如，n=24，A=2时有3种方案:5+19=7+17=11+13=24。注意，1不是素数，因 此n=A=1时答案为0。</p>

<p>习题10-6 连续素数之和( Sum of Consecutive Prime Numbe rs , ACM/ICPC Japan 2005, UVa1210)</p>

<p>输入整数打(2&lt;n&lt;10000 )，有多少种方案可以把n写成若干个连续素数之和？例如，41 可由3种方案： 2+3+5+7+11+13， 11+13+17和41写成。</p>

<p>习题10-7 几乎是素数( Almost Prime Numbe rs , UVa10539)</p>

<p>输入两个正整数£、U(L&lt;U&lt;1012)，统计区间［L，U］的整数中有多少个数满足：它本身 不是素数，但只有一个素因子。例如，4、27都满足条件。</p>

<p>习题 10-8 完全P次方数(Perfect Pth Powers, UVa10622 )</p>

<p>对于整数x ,如果存在整数使得x=^ ,则说x是一个完全次方数。输入整数《 ,求出最 大的整数^ ,使得《是完全次方数。《的绝对值不小于2 ,且《在32位带符号整数范围内。例</p>

<p>如， n=17， p=1；n=1073741824， p=30；n=25， p=2。</p>

<p>习题10-9 约数( Divisors, UVa294)</p>

<p>输入两个整数I、1&lt;L&lt;U&lt;109 , U-L&lt;10000 ),统计区间［L,U］的整数中哪一个的正约 数最多。如果有多个，输出最小值。</p>

<p>习题10-10 统计有根树( Count, Chengdu 2012, UVa1645)</p>

<p>输入《 ( ^&lt;1000 ),统计有多少个《结点的有根树，使得每个深度中所有结点的子结点数 相同。例如，《=4时有3棵，如图10-20所示；《=7时有10棵。输出数目除以109+7的余数。</p>

<p>图10-20 n=4时的有根树</p>

<p>习题10-11 圈图的匹配( Edge Case, ACM/ICPC NWERC 2012, UVa1646)</p>

<p>n ( 3&lt;n&lt;10000 )个结点组成一个圈，求匹配(即没有公共点的边集)的个数。例 如，n=4时有7个，如图 10-21 所示，n=100时有792070839848372253127个。</p>

<p>(a)    (b) M2 &copy; M3    (d) A/4    (e) A/5    (f) M6 (g) M-,</p>

<p>图10-21 n=4时匹配的个数</p>

<p>习题10-12 汉堡( Burger, UVa557)</p>

<p>有n个牛肉堡和n个鸡肉堡给2n个孩子吃。每个孩子在吃之前都要抛硬币，正面吃牛肉 煲，反面吃鸡肉煲。如果剩下的所有汉堡都一样，则不用抛硬币。求最后两个孩子吃到相同 汉堡的概率。</p>

<p>习题10-13 H(n)( H(n), UVa11526)</p>

<p>输入n (在32位带符号整数范围内)，计算下面C++函数的返回值：</p>

<p>long long H(int n){ long long res = 0;</p>

<p>for( int i = 1; i &lt;= n; i=i+1 ){ res = (res + n/i);</p>

<p>}</p>

<p>return res;</p>

<p>}</p>

<p>例如，n=5、10时答案分别为10和27。</p>

<p>习题10-14 标准 差( Standard Deviation, UVa10886)</p>

<p>下面是一个随机数发生器。输入seed的初始值，你的任务是求出它得到的前n个随机数 标准差，保留小数点后5位( 1&lt;n&lt;10000000， 0&lt;seed&lt;264)。</p>

<p>unsigned long long seed;</p>

<p>long double gen()</p>

<p>{</p>

<p>static const long double Z = ( long double )1.0 / (1LL&lt;<32); seed >&gt;= 16;</p>

<p>seed *= seed; return seed * Z;</p>

<p>}</p>

<p>习题10-15 零和一( Zeros and Ones, ACM/ICPC Dhaka 2004, UVa12063)</p>

<p>给出n、女(n&lt;64 , K100 ),有多少个打位(无前导0 )二进制数的1和0—样多，且值 为女的倍数？</p>

<p>习题10-16 计算机变换( Comput e r Transformations, ACM/ICPC SEERC 2005, UVa1647)</p>

<p>初始串为—个1，每—步会将每个0改成10，每个1改成01，因此1会依次变成01, 1001, 01101001,&hellip;输入n(n&lt;1000 )，统计n步之后得到的串中，“00”这样的连续两个0出现了多少 次。</p>

<p>习题 10-17 H-半素数(Semi-prime H-numbers, UVa11105 )</p>

<p>所有形如4n+1 ( n为非负整数)的数叫H数。定义1是唯一的单位H数，H素数是指本身不 是1 ,且不能写成两个不是1的H数的乘积。H-半素数是指能写成两个H素数的乘积的H数(这 两个数可以相同也可以不同)。例如，25是H-半素数，但125不是。</p>

<p>输入一个H数力(^&lt;1000001 ),输出1〜力之间有多少个H-半素数。</p>

<p>习题10-18 —个研究课题( A Research Problem, UVa10837)</p>

<p>输入正整数rn ( m&lt;108 ),求最小的正整数n ,使得q(n)=rn。输入保证n小于200000000。</p>

<p>习题10-19 蹦极( Bungee Jumping, UVa10868)</p>

<p>James Bond为了摆脱敌人的追击，逃到了一座桥前。桥上正好有一条蹦极绳，于是他打 算把它拴到腿上，纵身跳下桥，落地后切断绳子，继续逃生。已知绳子的正常长度 为l , Bond的体重为w ,桥的高度为5 ,你的任务是替James Bond判断能否用这种方法逃生。</p>

<p>当从桥上跳下后，绳子綳紧前Bond将做自由落体运动(重力按9.81w计)，而綳紧后绳 子会有向上的拉力，大小为PA1 ,其中Al为绳子当前长度和正常长度之差。当且仅当Bond可</p>

<p>以到达地面，且落地速度不超过10米/秒时，才认为他安全着落。</p>

<p>输入每组数据包含4个非负整数屯l, s, w（ s&lt;200 ）。对于每组数据，如果可以安全着 地，输出“James Bond survices.”，如果到不了地面，输出“Stuck in the air.”，如果到达地面速 度太快，输出“Killed by the impact.”</p>

<p>习题10-20 商业中心( Business Center, NEERC 2009, UVa1648)</p>

<p>商业中心是一幢无限高的大楼。在一楼有m座电梯，每座电梯只有两个键：上、下。对 于第/座电梯，每按一次“上”会往上走层楼，每按一次“下”会往下走或层楼。你的任务是从</p>

<p>一楼开始选一个电梯，恰好按n次按钮，到达一个尽量低（一楼除外）的楼层。中途不能换 乘电梯。1^n^1000000，1&lt;m&lt;2000，1&lt;w/?^z&lt;1000。</p>

<p>习题10-21 二项式系数( Binomial coefficients, ACM/ICPC NWERC 2011, UVa1649)</p>

<p>输入m （ 2&lt;m&lt;1015 ），求所有的（n，^）使得C（n,女）=m。输出按照n升序排列，当n相同时女按 升序排列。</p>

<p>习题10-22 飞机环球( Planes Around the World, UVa10640)</p>

<p>有一种飞机，加满油能环游地球圈。如果要使得一架飞机能够环游地球一圈，那么 必须要使用其他若干架同种飞机，在某处为它空中加油。</p>

<p>假设“=1，6 = 2，5架飞机可以环游。</p>

<p>首先3架飞机一起从A走到C，飞机3给另外两架加满油，然后开始返程。当飞机1和2到 达D的同时飞机3回到A。然后飞机2给飞机1加满油，回到A点。</p>

<p>接下来，飞机4和5逆时针出发，其中飞机4在F处等待，飞机5在E处等待，直到飞机1到 达E。然后飞机5给飞机1加油，使得二者都能恰好飞到F。然后飞机4给飞机1和飞机5加油， 三者都恰好飞回A，如图10-22所示。</p>

<p>图 10-22 飞机环球问题示意图</p>

<p>假设：</p>

<p>□只有飞机1环游地球。</p>

<p>□有A架飞机和飞机1同时出发，同向飞行，称为正向飞机。每艘正向飞机都在某个位置 处为其他飞机加油，然后折返。</p>

<p>□有B架飞机于不同时间反向出发，称为反向飞机。每架反向飞机会停在一个地方等待飞 机1（及其他同行飞机）。等到之后为其他飞机加油，然后折返。</p>

<p>□除了飞机1之外的其他飞机恰好为其他飞机加一次油，使得每个其他飞机得到相同多的 油量。</p>

<p>输入仏^ ,输出最少需要时用多少架飞机才能完成环游地球。例如^ = 1 , ^ = 2时需要5 架。无解输出-1。</p>

<p>习题 10-23 Hendrie序列(Hendrie Sequence, UVa10479 )</p>

<p>Hendrie序列是一个自描述序列，定义如下：</p>

<p>□ H（1）=0。</p>

<p>□如果把H中的每个整数x变成x个0后面跟着x+1 ,则得到的序列仍然是H （只是少了第一 个元素）。</p>

<p>因此，H序列的前几项为：0，1，0，2,1，0，0，3，0，2,1,1，0，0，0，4,1，0，0，3，0，……输入正整 数权（n&lt;263 ）,求H（n）。</p>

<p>习题10-24 幂之和( Sum of Powers, UVa766)</p>

<p>对于正整数^，可以定义&amp;次方和：</p>

<p>可以把它写成下面的形式。当似取最小可能的正整数时，所有系数％都是确定的。</p>

<p>输入女(0&lt;A&lt;20)，输出1人卜冬…例如，A=2，输出6, 2, 3, 1，0。</p>

<p>习题10-25 因子( Factors, ACM/ICPC World Finals 2013, UVa1575)</p>

<p>算术基本定理：每一个大于1的正整数都有唯一的方式写成若干个素数的乘积。不过如</p>

<p>果允许把这些素数重排，就有多种表示方式：</p>

<p>10 = 2 * 5 = 5 * 2, 20 = 2 * 2 * 5 = 2 * 5 * 2 = 5 * 2 * 2</p>

<p>令A幻为正整数&amp;的写法个数，如f(10)=2，f(20)=3。对于正整数n，可以证明一定有整 数女使得/(^)=n。你的任务是求出最小的^。n&lt;263。</p>

<p>习题10-26 方形花园( Square Garden, UVa12520)</p>

<p>在Z*£ ( £&lt;106 )网格里涂色n ( n&lt;L2 )个格子，要求涂色格子的轮廓线周长尽量大。例 如，图10-22中为L=3，n=8的两组解，图10-23 ( a )的周长为16，图10-23 (办)的周长为12。</p>

<p>(a)</p>

<p>图10-23 L=3</p>

<p>(b)</p>

<p>n=8的两组解</p>

<p>习题10-27 互联( Interconnect, ACM/ICPC NEERC 2006, UVa1390)</p>

<p>输入n个点rn条边的无向图G ( n&lt;30，rn^1000 )。每次随机加一条非自环的边(w，v)(加 完后可以出现重边)。添加每条边的概率是相等的，求使G连通的期望操作次数。</p>

<p>习题10-28 数字串( Number String, ACM/ICPC Changchun 2011, UVa1650)</p>

<p>每个排列都可以算出一个特征，即从第二个数开始每个数和前面一个数相比是增加(I)还 是减少(D)。例如，｛3,1,2,7,4,6,5｝的特征是DIIDID。输入一个长度为n-1 ( 2&lt;n&lt;1001 )的字符 串(包含字符/，    D和？)，统计1〜n有多少个排列的特征和它匹配(其中?表示I和D都符</p>

<p>合)。输出答案除以1000000007的余数。</p>

<p>习题10-29 名次表的变化( Fantasy Cricket, UVa11982)</p>

<p>如图10-24所示为一个足球比赛的名次表，给出了每个队伍相对上一轮的排名变化。例</p>

<p>如：</p>

<p><img src="97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-229.jpg" alt="img" /></p>

<p>这代表队伍A的名次提高了，B降低了，C提高了，D降低了。用U表示排名上升，D表示 降低，E表示不变，则上表可以用UDUD表示。经过计算可知，上一轮的名次表有两种可 能：BADC和BDAC (假定本轮和上一轮的名次都没有并列)。</p>

<p>输入这样一个UDE组成的序列(长度不超过1000 ),求上一轮名次有多少种可能。输出 答案除以109+7的余数。</p>

<p>习题10-30 守卫( Guard, ACM/ICPC Dhaka 2011, UVa12371)</p>

<p>在n*n棋盘上放2n个守卫，使得每行每列均恰好有两个守卫，且一个格子里最多只有一 个守卫。如图10-25所示是两种方法，其中图10-25 ( a )的守卫形成一个大圈，图10-25 ( b ) 中形成两个小圈。</p>

<p>(a)</p>

<p>图10-25</p>

<p>两种守卫方法</p>

<p>输入n、k ( 2&lt;n&lt;105 , 1&lt;k&lt;rnin(n，50)),输出恰好包含k个圈的方案总数。例 如，n=2 , k=1答案为1 ; n=3 , k=1 ,答案为6 ; n=4 , k=1 ,答案为72 ; n=4 , k=2 ,答案为 18 。</p>

<p>习题 10-31 守卫II ( Guards II, ACM/ICPC Dhaka 2012, UVa12590 )</p>

<p>在n行rn列的棋盘里放k个车，使得边界格子都被攻击到。输出方案总数除以109+7的余 数。n，m，k&lt;100。输入最多包含20000组数据。</p>

<p>习题10-32 汉诺塔( Hanoi Towers, ACM/ICPC NEERC 2007, UVa1414)</p>

<p>Hanoi塔问题有一种构造解法：把6种移动(ABAQB^BQC^CB )排序后选择第一个能 用的操作，前提是不能连续移动同一个盘子。给出n ( n&lt;30 )和6种移动的顺序，求解Hanoi 问题的步数。最终所有盘子可以都在B也可以都在C。例如，对于n=2，排序为AB, BA, CA, BC, CB, AC，—共需要5步。</p>

<p>习题10-33 二元运算( Binary Operation, ACM/ICPC NEERC 2010, UVa1651)</p>

<p>给定正整数a&lt;6，你的任务是计萬/®(a+l)®(“+2)® — ®(Z?-l) op 的值，其中的 计算方法是这样的：首先，如果和的位数不同，位数较少的一个前面补0 ;然后逐位执行 ©操作。例如，当©表示“加起来模10”时，    :.的计算方法如下：</p>

<p>操作符是左结合的，因此.    从左到右计算即可。</p>

<p>输入©的运算表(一个10*10矩阵，表示0©0, 0©1,…，9©9的结果，其中0©0保证为0 ) 和a, b ( 0&lt;a&lt;办&lt;1018 )的值，输出所求结果。</p>

<p>习题 10-34 记住 密码( Password Remembering, ACM/ICPC Dhaka 2009, UVa12212)</p>

<p>输入正整数A 5 ( A&lt;B&lt;264 )，求有多少个整数n满足：n在A和B之间(即A&lt;n&lt;B )，</p>

<p>且n翻转之后也在A和B之间。1203翻转以后为3021，1050翻转以后是501。</p>

<p>习题 10-35 Fibonacci单词(Fibonacci Word, ACM/ICPC World Finals 2012, UVa1282 )</p>

<p>0    if /7 = 0</p>

<p>F{n) — &lt; 1    if a? = 1</p>

<p>F(w -1) + F(/7 - 2) if</p>

<p>输入非空01串^nn ( 0&lt;n&lt;100 )，求在F(n)中出现几次。夕的长度不超过100000。</p>

<p>习题 10-36 Fibonacci进制(Fibonacci System, ACM/ICPC NEERC 2008, UVa1652 ) 每个正整数都可以写成\彳厂-彳i…-U|/&lsquo;i，其中an=1，^就是第Z•个Fibonacci数</p>

<p>，然后用.■.    作为#的Fibonacci进制表示。规定不能出现两个连续的1。例</p>

<p>如，卜 7的Fibonacci进制表示分别为：1, 10，100，101, 1000，1001, 1010。</p>

<p>把所有自然数的Fibonacci进制表示拼起来，会得到一个长长的串 110100101100010011010…。输入n n ( n&lt;1015 )，统计前n位有多少个 1。</p>

<p>习题10-37 倍数问题( Yet Another Multiple Problem, Chengdu 2012, UVa1653)</p>

<p>输入一个整数n ( 1&lt;n&lt;10000 )和rn个十进制数字，找n的最小倍数，其十进制表示中不 含这m个数字中的任何一个。</p>

<p>提示：需要建一张图，结点i代表除以n的余数等于i。巧妙地利用第6章学过的BFS树可 以简洁地解决这个问题。</p>

<p>习题10-38 正多边形( Regular Polygon, UVa10824)</p>

<p>给出圆周上的n(n&lt;2000 )个点，选出其中的若干个组成一个正多形，有多少种方法？ 输出每行包含两个整数和F，表示有F种选法得到正边形。各行应按从小到大排序。</p>

<p>习题10-39 圆周上的三角形( Circum Triangle, UVa11186)</p>

<p>在一个圆周上有打(n&lt;500 )个点。不难证明，其中任意3个点都不共线，因此都可以组 成一个三角形。求这些三角形的面积之和。</p>

<p>习题10-40    实验法计算概率( Probability Through Experiments, ACM/ICPC Hatyai</p>

<p>2012, UVa12535)</p>

<p>输入圆的半径和圆上n ( n&lt;20000 )个点的极角，任选3点能组成多少个锐角三角形？ 习题10-41 整数序列( A Sequence of Numbers, ACM/ICPC Chengdu 2007, UVa1406)</p>

<p>输入n个整数，执行2个操作(n&lt;105，2&lt;200000 )。有两种操作：</p>

<p>□    ADD d :把所有数加上一个定值d。</p>

<p>□    QUERY i :统计有多少个数的二进制表示法中第i位上是1，并输出。</p>

<p>习题10-42 网格中的三角形( Triangles in the Grid, UVa12508)</p>

<p>一个n行m列的网格有n+1条横线和m+1条竖线。任选3个点，可以组成很多三角形。其中 有多少个三角形的面积位于闭区间W］内？ 1^n，m^200 , 0^AHnm。</p>

<p>习题10-43 整数对( Pair of Integers, ACM/ICPC NEERC 2001, UVa1654)</p>

<p>考虑一个不含前导0的正整数把它去掉一个数字以后得到另外一个数y。输入+!的</p>

<p>值#（ 1&lt;^&lt;109）,输出所有可能的等式1+!=#。例如，#=34有两个解：31+3=34 ; 27+7=34。</p>

<p>习题10-44 选整数( K-Multiple Free Set, UVa11246)</p>

<p>给定正整数k ,从1〜n的整数中选出尽量多的整数，使得没有一个整数是另一个整数 的k倍。例如，n=10 , k=2 ,最多可以选6个：1,3,4,5,7,9。1&lt;n&lt;109 , 2&lt;k&lt;100。</p>

<p>习题10-45 带符号二进制( Power Signs, UVa11166)</p>

<p>每个整数都可以写成二进制。现将二进制变一下：每个数位上可以是0和1，还可以是-</p>

<p>1。例如， 13可以写成（1，0，0，-1，-1）=24-21-20。在这种进位制下，正整数的表示方法不唯一， 例如， 7可以写成（1，1，1）或者（1，0，0，-1）。你的任务是找一种非0数字最少的表示法。</p>

<p>输入每组数据第一行为用二进制表示的正整数n（n&lt;25000 ），保证不含前导0。对于每组 数据，输出非0数字最小的表示法（ 0表示0， +表示1， -表示-1）。如果有多解，输出字典序 最小的。</p>

<p>习题10-46 抽奖( Honorary Tickets, UVa11895)</p>

<p>在一次抽奖活动中，有n （ 1&lt;n&lt;105 ）个抽奖箱，其中第/个箱子里有（ Zz〉0 ）个信封，</p>

<p>其中li个里面有奖。所有人依次抽奖（即自主选择一个抽奖箱，然后随机抽一个信封），每 次抽完后的空信封放回去。假设每个人都知道上述数据，并且足够聪明，求第k个人抽到奖 的概率（用最简分数表示，保证分子和分母都在32位带符号整数范围内）。注意，每个人抽 到奖之后只会默默地将它拿出，其他人并不会知道，因此不会改变既定的策略。</p>

<p>习题10-47 随机数( Randomness, UVa11429)</p>

<p>你有一个随机数发生器（R#G ）,可以得到1〜及（2&lt;R&lt;1000 ）之间的随机整数（每个 整数的概率均为1/R ）。现在你希望用它在#（ 2&lt;#&lt;1000 ）个事件中随机选择一个，使得事 件•的概率Pz等于给定的有理数az/bz （ 1^az&lt;bf1000 ）。你的任务是设计一个RNG使用算法， 使得对RNG的调用次数的数学期望尽量小。可以多次使用这个RNG。</p>

<p>例如，当R=2，N=4，厂,厂：广尸，U时，则只需调用两次RNG，—共有4种可能的结 果，分别对应一个事件。</p>

<p>习题10-48 考试( Exam, ACM/ICPC Chengdu 2012, UVa1655)</p>

<p>设/⑻为满足ab|;v的（a,b）个数。输入n （ 1&lt;n&lt;10Z1 ），求f（ 1 ）+f（2）+…+f（n）。例如，/山1 （即（1，1），（1，2），（2，1），（1，3），（3，1），（1，6），（6，1），（2,3），（3,2）），因此n=6时输出25。</p>

<p>习题10-49 指数塔( Exponential Towers, ACM/ICPC NWERC 2013, UVa1656)</p>

<p>用“A”来表示指数运算，即aAb=ab，例如，256=2A2A3=4A2A2 （注意“A”是右结合的，即</p>

<p>2A2A3表示2^（2A3））。定义| \    - * -（卜这样的表达式为“高度为&amp;的指数</p>

<p>八八，’八• • •、</p>

<p>塔”，其中女&gt;1，且所有整数az〉1。输入一个高度为3的指数塔aAbAc （ 1&lt;a,b,c&lt;9585 ），统计有 多少个高度至少为3的指数塔的值等于aAbAc。注意，9585这个常数可以保证输出小于263。</p>

<p>习题10-50 排列( Permutation, UVa11303)</p>

<p>输入一个长度为m的序列，每个元素均为1〜n的正整数，并且不含相同元素。找出1 〜n的排列中有哪些排列包含输入子序列（不一定连续出现），求出字典序第刎、的。例如， 若输入子序列为1, 3, 2, n=4，则一共有4个排列：1,3,2,4 ; 1,3,4,2 ; 1,4,3,2 ; 4,1,3,2，它们的字 典序分别为第1， 2， 3， 4小。 1&lt;n&lt;250， 1&lt;m&lt;n。</p>

<p>习题10-51 游戏( Game, ACM/ICPC ACM/ICPC NEERC 2003, UVa1657)</p>

<p>有这样一^个游戏：裁判先公布一^个正整数打（2&lt;n&lt;200 ），然后在1〜n中选两个不同的整 数和y （ x&lt;y ），把x+y告诉S先生，把x*y告诉P先生，然后依次循环S先生和P先生是否知道 这两个数是几（总是先问S先生）。例如：</p>

<p>裁判：n=10 （然后悄悄告诉S : ^+y=9, ;v*y=18 ）。</p>

<p>S先生：不知道^和y是多少。</p>

<p>P先生:不知道^和y是多少。</p>

<p>S先生:不知道^和y是多少。</p>

<p>P先生：不知道^和y是多少。</p>

<p>S先生：知道了。 x=3，y=6。</p>

<p>两人一共说了m次“不知道”后，下一个人算出了答案。已知S和P都非常聪明且精于心 算，你的任务是根据《和讲(0&lt;m&lt;100)计算出所有可能的(x，y)。</p>

<p>例如，n=10，m=4时有3个解:(2,5), (3,6), (3,10)。</p>

    </div>

    
    

    
    

    <footer class="post-footer">
      

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/04-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8/11-%E5%9B%BE%E8%AE%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%AE%97%E6%B3%95/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">11 图论模型与算法</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/04-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8/07-%E6%9A%B4%E5%8A%9B%E6%B1%82%E8%A7%A3%E6%B3%95/">
            <span class="next-text nav-default">07 暴力求解法</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="iteratelyd@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="http://github.com/iterateself" class="iconfont icon-github" title="github"></a>
      <a href="https://www.zhihu.com/people/thebegin/activities" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="https://www.douban.com/people/68028070/" class="iconfont icon-douban" title="douban"></a>
  <a href="http://iterate.site/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> site pv: <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
    <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> site uv: <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2018
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">iterateself</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>


<script type="text/javascript" src="/dist/even.min.js?v=3.2.0"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>








</body>
</html>
