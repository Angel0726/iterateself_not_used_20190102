<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>简明算法系列：顺序查找和二分法 - 迭代自己</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="iterateself" />
  <meta name="description" content="简明算法系列：顺序查找和二分法 查找(searching)是计算机算法的重要组成部分。它的内容本身理解起来不难，但真要动手写起来，可能会有这样" />

  <meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.47.1" />


<link rel="canonical" href="http://iterate.site/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/04-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%80%E6%98%8E%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%E5%92%8C%E4%BA%8C%E5%88%86%E6%B3%95/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">




<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<link href="/dist/even.min.css?v=3.2.0" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">




<meta property="og:title" content="简明算法系列：顺序查找和二分法" />
<meta property="og:description" content="简明算法系列：顺序查找和二分法 查找(searching)是计算机算法的重要组成部分。它的内容本身理解起来不难，但真要动手写起来，可能会有这样" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://iterate.site/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/04-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%80%E6%98%8E%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%E5%92%8C%E4%BA%8C%E5%88%86%E6%B3%95/" /><meta property="article:published_time" content="2018-04-24T21:25:52&#43;00:00"/>
<meta property="article:modified_time" content="2018-04-24T21:25:52&#43;00:00"/>
<meta itemprop="name" content="简明算法系列：顺序查找和二分法">
<meta itemprop="description" content="简明算法系列：顺序查找和二分法 查找(searching)是计算机算法的重要组成部分。它的内容本身理解起来不难，但真要动手写起来，可能会有这样">


<meta itemprop="datePublished" content="2018-04-24T21:25:52&#43;00:00" />
<meta itemprop="dateModified" content="2018-04-24T21:25:52&#43;00:00" />
<meta itemprop="wordCount" content="5834">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="简明算法系列：顺序查找和二分法"/>
<meta name="twitter:description" content="简明算法系列：顺序查找和二分法 查找(searching)是计算机算法的重要组成部分。它的内容本身理解起来不难，但真要动手写起来，可能会有这样"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">迭代自己</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">最新</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a><a href="/catalog/">
        <li class="mobile-menu-item">完整目录</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">迭代自己</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">最新</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/catalog/">完整目录</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">简明算法系列：顺序查找和二分法</h1>

      <div class="post-meta">
        <span class="post-time"> 2018-04-24 </span>
        
        <span class="more-meta"> 5834 words </span>
        <span class="more-meta"> 12 mins read </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> times read </span>
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  
  <div class="post-toc-content">
    <nav id="TableOfContents">
<ul>
<li><a href="#简明算法系列-顺序查找和二分法">简明算法系列：顺序查找和二分法</a></li>
</ul>
</nav>
  </div>
</div>

    
    

    
    <div class="post-content">
      

<h1 id="简明算法系列-顺序查找和二分法">简明算法系列：顺序查找和二分法</h1>

<p>查找(searching)是计算机算法的重要组成部分。它的内容本身理解起来不难，但真要动手写起来，可能会有这样那样的细节问题。而且感觉除非经常和算法打交道，否则过段时间就很容易忘记具体细节，所以这里尝试着通过例子把要点总结起来。既希望是一个实践性比较强的教程，也是自己的一个备忘录。</p>

<p>这篇笔记会用Python，原因有几个。一来当然是自己习惯Python，二来Python天生好懂，三来这里有个在线的Python解释器：<a href="http://repl.it/languages/Python/">http://repl.it/languages/Python/</a> 可以零安装零配置零折腾地开始写Python，方便到令人发指。而由于Python本身就有点像伪代码，所以习惯用C或者其它语言的朋友应该也不会感到隔阂。</p>

<p>Python由于太过方便，本身自带了很多查找和排序的功能，所以这个例程会适时地禁用某些东西（比如，总不能直接调用sort()来写一个快速排序吧）。这些会在各个例子里注明，也因此会使得一些代码看起来不那么Pythonic或者解法是sub-optimal。</p>

<p>按照我的其它笔记的模式，从几个例子开始讲起，从最简单的开始说。谨慎建议对于下面的例子，无论看起来多简单，或者用Python，或者用上你熟悉的语言，动手自己写一下，相信会有不一样的发现。</p>

<p>这一节是关于顺序查找和二分法。下一节则是哈希表。</p>

<h4>1. 顺序查找</h4>

<p><strong>例1</strong> 给定一个整数s和一个整数数组a，判断s是否在a中。（注：不能用Python自带的<code>if s in a</code>）</p>

<p>既然没有注明a有什么特性，我们就只能假定它是一个很随机的数组。要判断s是否在a中，我们能做的，也就是逐个访问a中的元素并和s比较。一旦找到，返回<code>True</code>，a遍历完了还没找到，则返回<code>False</code>。这个过程实现起来非常简单：</p>

<pre><code class="language-python">def seq_search(s, a):
    for i in range(len(a)):
        if s == a[i]:
            return True
    return False
</code></pre>

<p>给几个测试例子</p>

<pre><code class="language-python">a = [13,42,3,4,7,5,6]
s = 7
print seq_search(s,a)

a2 = [10,25,3,4,780,5,6]
s = 70
print seq_search(s,a2)
</code></pre>

<p>如无意外的话，会输出：</p>

<pre><code class="language-python">True
False
</code></pre>

<p>如果要算它的时间复杂度也简单，各种情况下，复杂度是这样的：</p>

<table>
<thead>
<tr>
<th align="center">情况</th>
<th align="center">最好</th>
<th align="center">最坏</th>
<th align="center">平均</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">找到了</td>
<td align="center">1</td>
<td align="center">n</td>
<td align="center">n/2</td>
</tr>

<tr>
<td align="center">没找到</td>
<td align="center">n</td>
<td align="center">n</td>
<td align="center">n</td>
</tr>
</tbody>
</table>

<p>用<code>Big-O</code>来表示，就是复杂度是<code>O(n)</code>。对于没找到的情况，数组总是要遍历一次的。而对于元素在数组中的情况，则要分运气好坏，或许第一个就中了，或许最后一个才是，平均而言，则是<code>n/2</code>。</p>

<p><strong>例2</strong> 注册网站账号时，用户名常常要符合某些要求，比如不能含有英文的<code>;!~</code>这三个字符。写一个函数，读入用户输出的用户名，返回“用户名合法”或者“用户名不合法”。</p>

<p>一个直观的解法是这样：</p>

<pre><code class="language-python">def username_check():
    username = input('输入一个用户名')
    
    for s in ';!~':
        if seq_search(s,username):
           return '用户名不合法'
    return '用户名合法'

</code></pre>

<p>当然也可以这样：</p>

<pre><code class="language-python">def username_check2():
    username = input('输入一个用户名')
    
    for i in range(len(username)):
        if seq_search(username[i],';!~'):
            return '用户名不合法'
    return '用户名合法'
</code></pre>

<p>这里都是多次调用我们之前写好的<code>seq_search(s,a)</code>。</p>

<p><h4>2. 二分查找和分治法</h4>
上述的顺序查找看起来简单，技术含量不高，但对于一般的数组，确实也只能这样查找了。但假如数组本身是排序好的，则在查找的时候会省事一些。想象一下，如果你要在一堆人中找出体重和你一样的人，一般情况下也没有特殊的办法，只能逐个去比，并期望于早一点找出那个人。但假如告诉你，面前的这一堆人已经按体重由轻到重排列好了，那显然我们不会再一个个去比，而是先瞄一眼，看看有哪个人可能体重和你无限接近，然后和他比较。如果你比他重，说明你要找的人在这个人的右边，如果你比他轻，则说明你要找的人在这个人的左边。于是我们就把范围缩小了，下一次的搜索，我们只需要其中一边去找。而对于这半边，我们又可以故伎重演，找一个人，然后再将这半边队列分成两半。</p>

<p>这其实就是二分查找。只不过对于数字，我们通常无法先主观地找出一个“看起来差不多的”，因此我们会习惯性地从队列中间将队列等分劈成两半。</p>

<p>来看一个具体的例子吧。</p>

<pre><code class="language-python">a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10，11, 12]
s = 3
</code></pre>

<p>同样地，我们想知道3是否在数组里。因为我们知道数组已排序好，所以我们可以直接先看数组的中间值。在这里是6。由于<code>3&lt;6</code>，我们于是知道了3只可能在数组的左半边。接下来我们只需要在子数组</p>

<pre><code>a_sub = [0, 1, 2, 3, 4, 5]
</code></pre>

<p>里找就可以了。对于<code>a_sub</code>，我们也是取中间的那个值，在这里是2（5/2取整，a[2]=2）。于是我们取右半边：</p>

<pre><code>a_sub_sub = [3,4,5]
</code></pre>

<p>再取中间值4。然后再取左半边：</p>

<pre><code>a_sub_sub_sub = [3]
</code></pre>

<p>这时的中间值刚好就是3了。通过不断缩小范围，我们成功地定位到3这个值。</p>

<p>请原谅略不雅观的命名。</p>

<p>二分查找其实就是这样：数组不断裂变成原来的一半，（最坏情况下）最终到只剩一个元素。而运气好的时候，某一次的中间值刚好就等于你要找的那个值。</p>

<p>下面我们写出以上过程的代码。</p>

<p><strong>例3</strong> 写一个函数实现二分查找来判断整数s是否在升序排列的整数数组a当中。</p>

<pre><code class="language-python">def binary_search(s,array):
    found = False
    
    # left 和 right定义子数组的边界，一开始搜索的是整个数组
    left = 0
    right = len(array)-1
        
    while left &lt;= right:
        mid = (left+right) //2
        if array[mid] == s:
            return True
        if s &lt; array[mid]:
            # 到左边去找
            right = mid-1
        else:
            # 到右边去找
            left = mid + 1
            
    return False
</code></pre>

<p>left和right两个变量，定义我们搜索的子数组的边界。一开始我们查找的是整个数组。以后逐次按照上面的步骤，搜索左半边或者右半边。
只要是左边边界比右边边界小或者相等，就说明数组还至少有一个元素，那我们就持续执行这个裂变的循环。如果找到了，就停止搜索，如果在<code>while</code>循环里一直找不到，那么最后就返回<code>False</code>。</p>

<p>如果你回顾上述过程，会发现每一次进入一个子数组，我们做的事情是一样的：取中间值，然后比较，取左边/右边。于是这个过程也可以用递归来实现。</p>

<p>如果对递归没有概念的话，可以先看看下面的例子。有接触过递归的朋友就可以果断跳过啦。</p>

<p><strong>例4</strong> 写一个函数对1-100之间的整数求和。</p>

<p>非递归的解法</p>

<pre><code class="language-python">def cal_sum(num):
    sum = 0
    for i in range(1,num+1):
        sum += i
    return sum
</code></pre>

<p>上面的求和方法非常直观，从1到100做一个循环。而用递归的思想来解决是这样的：对1-100求和，其实等于是100加上前99个的和(sum99)，而前99个的和，又等于99+sum98，如此反复。把这个过程表示出来其实就是：</p>

<pre><code>sum(i) = i + sum(i-1)
</code></pre>

<p>因此1-100求和的递归解法可以是：</p>

<pre><code class="language-python">def cal_sum(i):
    if i == 1:
        return 1
    return i + cal_sum(i-1)
</code></pre>

<p>是不是看起来更简洁？我们一开始想知道<code>cal_sum(100)</code>，通过递归，我们转而去求解<code>cal_sum(99)</code>，<code>cal_sum(99)</code>又会去调用<code>cal_sum(98)</code>。那么到哪里是个头呢？</p>

<p>一个递归函数，必须有一个终止的条件，不然的话就等于是一级一级爬向无底深渊。在上述这个函数里，我们的终止条件就是假如<code>i==1</code>，则不再继续递归，而是返回1。</p>

<p>明白了递归的基础知识，我们就可以将二分查找用递归来实现了。如下所示（慎重建议自己先写一遍）：</p>

<pre><code class="language-python">def binary_search_rec(s,array):
    
    if len(array) == 0:
        # 数组已被掏空
        return False
            
    mid = (len(array)-1) //2
    
    if array[mid] == s:
        # 找到啦
        return True
    elif s &lt; array[mid]:
        # 要找的人在左边
        return binary_search_rec(s, array[:mid])
    else:
        # 要找的人在右边
        return binary_search_rec(s, array[mid+1:])
</code></pre>

<p>使用递归，要注意终止递归的条件是什么，在这里，如果数组已经是空了，则表示没找到，不再递归，返回<code>False</code>，如果找到，也是直接返回，不再折腾子数组了。要注意递归函数被调用时，前面要加<code>return</code>。这是因为这里的递归就好像一层一层进入一个深渊去寻找宝藏，而一旦找到，不能简单地满足于在深渊里喊一声“我找到了”，而是要逐层传递回来，直到地面上的人（第一级函数）也收到了信息。</p>

<p>二分查找显然要比顺序查找省时间，每一次分裂，搜索的长度都变为之前的二分之一。假设一个数组原来的长度为<code>n</code>，则一次之后，变为<code>n/2</code>，再裂变后变为<code>n/4</code>,<code>n/8</code>&hellip;不难看出其时间复杂度是<code>O(log(n))</code>。</p>

<p><strong>例5</strong> 一个本来按升序排序好的数组被切成两部分，这两部分调换位置变成一个新数组。用二分查找找出数组中的最小元素。假设数组不含重复元素。</p>

<p>比如，一个数组本来是<code>a=[1,2,3,4,5,6,7,8,9]</code>。现在沿着4和5之间切一刀，调换位置，变成一个新数组<code>a=[5,6,7,8,9,1,2,3,4]</code>。</p>

<p>这是<a href="https://oj.leetcode.com">LeetCode</a>的153题，难度标记为中等。</p>

<p>考虑一个没被拦腰截断的升序数组，除了最大的那一个，其余所有元素，当向右望的时候，都会发现右边的元素比它大。这是正常的情况。因此，假如当你向右望而发现有元素比你小的时候，可想而知你右边的那一块是被动过手脚的。也就是那个“切断点”就藏在右边。反过来想，如果右半边没有一个先降后升的过程，那你不可能找到比你小的元素。而先降后升的那个转折点，就是我们要找的。因此，你可以把搜索范围缩小到右半边。而如果右半边的元素比你大，而将搜索范围转到左半边。这其实和我们上面的例4很接近。</p>

<pre><code class="language-python">def slice_point(num,left,right):
    if left==right:
        # 只剩一个元素
        return num[right]
        
    mid = (right+left)//2
    
    if num[mid]&gt;num[right]:
        return slice_point(num,mid+1,right)
    else:
        return slice_point(num,left,mid)
</code></pre>

<p>注意我们这里将left和right也作为参数传递，这样是为了更直观，其实也完全可以不用。就像上面的那个例子一样，直接对Python的list进行slice操作(e.g. num[mid:])。代码和例3非常像，但你发现几乎相同的一段代码，却可以用来回答不同的问题。</p>

<p><strong>练习</strong> 试着用循环（而不是递归）来实现上述查找。</p>

<p>这个就不给答案了。</p>

<p><strong>例6</strong> 用二分查找实现开平方根函数<code>square(x,p)</code>。<code>x</code>是被开方根的数，假定输入都为非负整数，<code>p</code>是误差上限，输出一个浮点数结果。</p>

<p>这是<a href="https://oj.leetcode.com">LeetCode</a>的69题，略有改动。原题是输出一个整数，这里直接输出浮点数，难度其实是降低了。原题难度标记为中等。</p>

<p>如何用二分查找思考这个问题？</p>

<p>我们要查找的，其实是某数的近似平方根。那么供我们查找的数组在哪里呢？搜索范围是什么？</p>

<p>显然，一个整数的平方根，不会小于0，也不会大于他本身。于是我们的搜索范围，其实就可以定位<code>[0, x]</code>。在这个范围里我们应用二分搜索，取中间值<code>mid=0.5x</code>，如果<code>mid*mid &gt; x</code>，说明我们改走左半边。反之，走右半边。代码如下：</p>

<pre><code class="language-python">
def square(x,p):
    return square_helper(x,0.0,float(x),p)


def square_helper(x,left,right,p):

    if abs(left-right) &lt; p*2:
        # 左边右边距离已经很小了
        #print (left+right)/2.0
        return (left+right)/2.0
    
    # 折半
    mid = float((left+right)/2.0) 
    
    
    if mid*mid - x &gt; 0:
        return square_helper(x,left,mid,p)
    else:
        return square_helper(x,mid,right,p)
        
</code></pre>

<p>你可以通过随意控制<code>p</code>来输出不同精度的值。到这里你可以看到，无论是用循环还是递归，二分查找的套路都是极其类似的：</p>

<ul>
<li>一个终止条件，前面那些数组的例子，终止条件就是：找到或者没找到（一个确定的答案）。开平方根，条件就是，满足精度要求。注意，程序的编写还应考虑各种情况。在各种情况下都应有退出机制。</li>
<li>取中间值，然后根据中间值的情况，确定往左还是往右。</li>
</ul>

<p>就这么简单。至于是用循环还是递归，对于一个算法题来说，大部分时候是一个个人喜好的问题。我自己偏好递归，各位请随意。</p>

<p>按照这个套路，我们再来看一个例子。</p>

<p><strong>例7</strong> 给定一个升序排序的数组，以及一个目标值。如果目标值在数组里，返回对应元素的下标，如果不在，返回该插入的位置。</p>

<p>这是<a href="https://oj.leetcode.com">LeetCode</a>的35题。难度标记为中等（LeetCode的难度值随便看看就好，我个人觉得不太反映真实难度）。</p>

<p>这个题和二分查找的原型（例3）非常像：如果找到了，那么都一样返回。只不过，当最后找不到的时候，我们不是返回<code>False</code>，而是讨论应该把数插在哪里。但是这一点其实也不难，我们做二分查找的过程，其实就是一步步逼近那个最像的值。所以最后即使找不到目标值，该插入的位置，也就是在最后那个剩下的元素的左边或者右边了。</p>

<p>以下是循环的解法。</p>

<pre><code class="language-python">def searchInsert(A,target):
    left = 0
    right = len(A)-1
    
    while left != right:
        mid = (left+right)//2
        if target == A[mid]:
            return mid
        elif target &lt; A[mid]:
            right = mid
        else:
            left = mid+1
            
    if target&gt;A[left]:
        return left+1
    return left
</code></pre>

<p>接着是递归的解法。</p>

<pre><code class="language-python">def searchHelper(A,target,left,right):
    if right==left:
        if A[left] &lt; target:
            return left+1
        return left
        
    mid = (left+right)//2
    # print mid
    if target == A[mid]:
        return mid
    elif target &lt; A[mid]:
        return searchHelper(A,target,left,mid)
    else:
        return searchHelper(A,target,mid+1,right) 
</code></pre>

<p>相信你都已经找到解题的模板了。</p>

<p>熟悉了以上的套路后，我们最后来看一题稍稍有点不同的。</p>

<p><strong>例8</strong> 给定浮点数x和整数n，计算<code>power(x,n)</code>，即x的n次方。</p>

<p>这是<a href="https://oj.leetcode.com">LeetCode</a>的50题。难度标记为中等。</p>

<p>很显然，我们这里禁用Python的<code>x**n</code>以及其它可能的库函数。</p>

<p>很显然的一个简单粗暴的方法是，跑n-1次循环，每次都把乘积相乘。这样我们一共需要做n-1次浮点数相乘。有没有更简单的办法？</p>

<p>这一题可能有点不太好想。即使你明知要用二分法，但如何二分呢？我们之前的例子，基本都有一个目标值，而我们清楚地知道这个目标值的上界和下界。而这一题里，目标值是有，但我们无从知道它的上下界，而且也无从检验一个值离目标值有多远。所以可能要换一种思路。</p>

<p>上面提到的暴力解法，总共要做n-1次乘法。所以如果我们要取得突破，可能的途径是减少乘法的次数。比如说，<code>2^64</code>，总共要63次乘法。有没有办法少做一些？</p>

<p>当然是有的，幂运算本身可以和低次幂进行换算。比如，<code>2^64=(2*2)^32=4^32</code>,接着来<code>4^32=(4*4)^16=16^16</code>。做完第一次换算之后，我们多做了一个乘法，但是！幂从64变成32，少了一半！，第二次之后，我们又用一次乘法，换来总乘法运算次数的减半。顺着这个思路下去，我们可以不断用一次乘法的代价，将总乘法次数减半。直到……直到不能再减，也就是n变成0或者是1。</p>

<p>目前为止，只有一个问题：假如n本身不能减半呢？假如是<code>2^63</code>呢？很简单，看成<code>2^62*2=4^31*2=16^15*4*2</code>。如果n是计数，就把一个x拆出来，这样n-1就是偶数了。</p>

<p>所以剩下的问题就不太难了：</p>

<pre><code class="language-python">def power(x,n):
    if n == 0:
        return 1
    elif n == 1:
        return x
    elif n &lt; 0:
        # 这里把负数的n先变成正数，处理起来简单一些
        return pow(1.0/x,-n)
    elif n%2 == 0:
        # n是偶数
        return power(x*x,n/2)
    else:
        # n是奇数
        return power(x*x,(n-1)/2)*x
</code></pre>

<p>你可以看到，虽然这一题要考虑的问题多一些，但其实整个套路还是二分查找的那个样式。具体理解起来不复杂，就不啰嗦了~</p>

<p><h4>下回预告</h4>
<ul>
<li>哈希表</li>
<li>排序一锅端</li>
</ul></p>

<p><h4>勘误和交流</h4>
匆忙写下的一个笔记，出错简直是一定的。如果您发现了任何错误或者有关于本文的任何建议，麻烦发邮件给我（stevenslxie at gmail.com）或者在GitHub上直接交流，不胜感激。</p>

<p><h4>转载声明</h4>
如果你喜欢这篇文章，可以随意转载。但请
<ul>
<li>标明原作者StevenSLXie;</li>
<li>标明原链接(<a href="https://github.com/StevenSLXie/Tutorials-for-Web-Developers/blob/master/%E7%AE%80%E6%98%8E%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%EF%BC%9A%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%E5%92%8C%E4%BA%8C%E5%88%86%E6%B3%95.md">https://github.com/StevenSLXie/Tutorials-for-Web-Developers/blob/master/%E7%AE%80%E6%98%8E%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%EF%BC%9A%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%E5%92%8C%E4%BA%8C%E5%88%86%E6%B3%95.md</a>);</li>
<li>在可能的情况下请保持文本显示的美观。比如，请不要直接一键复制到博客之类，因为代码的显示效果可能非常糟糕;</li>
<li>请将这个转载声明包含进来；</li>
</ul></p>

<p><h4>还有一件事</h4>
如果你阅读完这篇文章，觉得很有收获。可以：
<ul>
<li>在GitHub上的这个repo打星，因为我之后还会陆续更新。这样可能方便一点，对我更是一种鼓励；</li>
<li>如果你是V2EX过来的，可以在那里表示感谢；</li></p>

<p>Happy Coding!
</ul></p>

    </div>

    
    

    
    

    <footer class="post-footer">
      

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/04-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%80%E6%98%8E%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%E5%93%88%E5%B8%8C%E6%9F%A5%E6%89%BE/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">简明算法系列：哈希查找</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/02-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/01-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%90%86%E8%AE%BA/03-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/epochbatchtraining-step-%E7%9A%84%E5%8C%BA%E5%88%AB/">
            <span class="next-text nav-default"></span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="iteratelyd@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="http://github.com/iterateself" class="iconfont icon-github" title="github"></a>
      <a href="https://www.zhihu.com/people/thebegin/activities" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="https://www.douban.com/people/68028070/" class="iconfont icon-douban" title="douban"></a>
  <a href="http://iterate.site/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> site pv: <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
    <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> site uv: <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2018
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">iterateself</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>


<script type="text/javascript" src="/dist/even.min.js?v=3.2.0"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>








</body>
</html>
