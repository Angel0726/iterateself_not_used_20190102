<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>算法 字符串的排列 - 迭代自己</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="iterateself" />
  <meta name="description" content="相关资料 1. CodingInterviews 需要补充的 看来，STL 中的东西，尤其是各种容器和对容器的操作一定要掌握，比如方法二中的swap、sort和这里的 next_per" />

  <meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.47.1" />


<link rel="canonical" href="http://iterate.site/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/04-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer%E9%87%8C%E9%9D%A2%E7%9A%84/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">




<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<link href="/dist/even.min.css?v=3.2.0" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">




<meta property="og:title" content="算法 字符串的排列" />
<meta property="og:description" content="相关资料 1. CodingInterviews 需要补充的 看来，STL 中的东西，尤其是各种容器和对容器的操作一定要掌握，比如方法二中的swap、sort和这里的 next_per" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://iterate.site/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/04-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer%E9%87%8C%E9%9D%A2%E7%9A%84/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/" /><meta property="article:published_time" content="2018-07-27T17:21:57&#43;00:00"/>
<meta property="article:modified_time" content="2018-07-27T17:21:57&#43;00:00"/>
<meta itemprop="name" content="算法 字符串的排列">
<meta itemprop="description" content="相关资料 1. CodingInterviews 需要补充的 看来，STL 中的东西，尤其是各种容器和对容器的操作一定要掌握，比如方法二中的swap、sort和这里的 next_per">


<meta itemprop="datePublished" content="2018-07-27T17:21:57&#43;00:00" />
<meta itemprop="dateModified" content="2018-07-27T17:21:57&#43;00:00" />
<meta itemprop="wordCount" content="1954">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="算法 字符串的排列"/>
<meta name="twitter:description" content="相关资料 1. CodingInterviews 需要补充的 看来，STL 中的东西，尤其是各种容器和对容器的操作一定要掌握，比如方法二中的swap、sort和这里的 next_per"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">迭代自己</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">最新</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a><a href="/catalog/">
        <li class="mobile-menu-item">完整目录</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">迭代自己</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">最新</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/catalog/">完整目录</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">算法 字符串的排列</h1>

      <div class="post-meta">
        <span class="post-time"> 2018-07-27 </span>
        
        <span class="more-meta"> 1954 words </span>
        <span class="more-meta"> 4 mins read </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> times read </span>
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  
  <div class="post-toc-content">
    <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#相关资料">相关资料</a></li>
<li><a href="#需要补充的">需要补充的</a></li>
</ul></li>
<li><a href="#introduction">INTRODUCTION</a></li>
<li><a href="#题目">题目</a>
<ul>
<li><a href="#题目描述"><strong>题目描述</strong></a></li>
<li><a href="#样例输入"><strong>样例输入</strong></a></li>
<li><a href="#样例输出"><strong>样例输出</strong></a></li>
</ul></li>
<li><a href="#题目解答">题目解答</a>
<ul>
<li><a href="#普通的全排列-递归">普通的全排列 递归</a></li>
<li><a href="#基于交换的全排列-递归">基于交换的全排列（递归）</a></li>
<li><a href="#stl-中-直接使用-next-permutation-求一个容器的全排列">STL 中，直接使用 next_permutation 求一个容器的全排列</a></li>
</ul></li>
<li><a href="#comment">COMMENT</a></li>
</ul>
</nav>
  </div>
</div>

    
    

    
    <div class="post-content">
      

<h2 id="相关资料">相关资料</h2>

<p>1.</p>

<p><a href="https://github.com/gatieme/CodingInterviews">CodingInterviews</a></p>

<h2 id="需要补充的">需要补充的</h2>

<ul>
<li><strong>看来，STL 中的东西，尤其是各种容器和对容器的操作一定要掌握，比如方法二中的swap、sort和这里的 next_permutation。等。嗯，是必须要掌握的，因为很多的东西在别的类库里也有，知道了STL里的之后，别的类库也能大概知道会有什么功能。</strong></li>
</ul>

<hr />

<h1 id="introduction">INTRODUCTION</h1>

<ul>
<li>aaa</li>
</ul>

<h1 id="题目">题目</h1>

<h2 id="题目描述"><strong>题目描述</strong></h2>

<p>输入一个字符串,按字典序打印出该字符串中字符的所有排列，打印结果的时候请按字母顺序输出。</p>

<p><strong>注意</strong>：字符串长度不超过9，可能有字符重复，字符只包括大小写字母。</p>

<h2 id="样例输入"><strong>样例输入</strong></h2>

<p>abc</p>

<h2 id="样例输出"><strong>样例输出</strong></h2>

<p>abc acb bac bca cab cba</p>

<h1 id="题目解答">题目解答</h1>

<h2 id="普通的全排列-递归">普通的全排列 递归</h2>

<p>最先想到的就是全排列，依次从字符串中取出一个字符作为最终排列的第一个字符，然后对剩余字符组成的字符串递归生成全排列，最终结果为取出的字符和剩余子串全排列的组合。</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
using namespace std;


class Solution {
protected:
    vector&lt;string&gt; m_res;

public:
    vector&lt;string&gt; Permutation(string s) {
        m_res.clear();
        if (s.empty() == true) {
            return m_res;
        }
        PermutationRecursion(&quot;&quot;, s);
        return m_res;
    }
    void PermutationRecursion(string prefix, string str) {
        if (str.length() == 0) {
            //说明都已经处理完了，那么prefix就是全部了
            m_res.push_back(prefix);
        }
        else {
            //递归处理
            for (int i = 0; i &lt; str.length(); i++) {
                PermutationRecursion(prefix + str[i],
                    str.substr(0, i) + str.substr(i + 1, str.length()));
            }
        }
    }

};

int main() {
    Solution solu;
    vector&lt;string&gt; res;
    res=    solu.Permutation(&quot;abc&quot;);
    for each (string s in res) {
        cout &lt;&lt; s &lt;&lt; endl;
    }
    return 0;
}
</code></pre>

<p>输出：</p>

<pre><code>abc
acb
bac
bca
cab
cba
</code></pre>

<p>这个方法还是很易于理解的。</p>

<p>但是我们很快就想到了一个问题：有字符重复的时候要怎么处理？比如 s=&ldquo;ABA&rdquo;，会生成两个 “AAB”。</p>

<h2 id="基于交换的全排列-递归">基于交换的全排列（递归）</h2>

<p>OK，我们可以看看这种方法：</p>

<p>由于全排列就是从第一个数字起，每个数分别与它后面的数字交换。</p>

<p>因此，我们可以先尝试加个这样的判断：如果一个数与后面的数字相同那么这两个数就不交换 了。</p>

<p>例如：abb：</p>

<ul>
<li><p>对于 abb，尝试交换 12：得到 bab；尝试交换 13： 得到 bba；尝试交换 23：都是b，就不用交换了。</p></li>

<li><p>对于 bab，尝试交换 23：得到 bba。</p></li>

<li><p>对于 bba，尝试交换 23：得到 bab。</p></li>
</ul>

<p>可见，由于这里的 bab 的 23 交换和 bba 结果相同了，因此这个方法不可行。</p>

<p>OK，那么我们换种思维：</p>

<ul>
<li><p>对于 abb，尝试交换 12 ：得到 bab；尝试交换13 ：由于 3 和之前交换过的 2 相等，因此不交换；尝试交换23：由于2 与 3 本身相等因此不交换。</p></li>

<li><p>对于 bab，尝试交换 23：得到 bba。</p></li>
</ul>

<p>此时全排列竟然已经生成完毕！<strong>有点仓促吧？确认下为什么能确保？</strong></p>

<p>OK，看起来这种方式应该是可行的，那么怎么应用到程序中呢？</p>

<ol>
<li><p>首先，我们把第一个字符和它后面非重复出现的字符一一交换。如果这个被要求交换的字符在之前已经有过或者与第一个字符相同，那么就不进行交换。比如：abcba ，当第一个a与后面的每一个进行交换的时候，第二个b就不会被交换到，第二个a也不会被交换到。</p></li>

<li><p>交换之后，把第一个字符固定，然后按照步骤1一样，同样的处理后面的字符串。</p></li>

<li><p>以此类推</p></li>
</ol>

<p><strong>这个图不是很好，没有写出带重复字符的情况：</strong></p>

<p><img src="http://pacdb2bfr.bkt.clouddn.com/blog/image/180727/AmjiJ1IClc.png?imageslim" alt="mark" /></p>

<p>程序如下：</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
using namespace std;




class Solution {
protected:
    vector&lt;string&gt; m_res;
public:
    vector&lt;string&gt; Permutation(string str) {
        m_res.clear();
        if (str.empty() == true) {
            return m_res;
        }
        PermutationRecursion(str, 0);
        sort(m_res.begin(), m_res.end());//竟然直接sort就行？要掌握下
        return m_res;
    }

    //递归实现
    // 由于是直接传参，不是传指针，因此传递进去之后，里面的str就与这里的str没有关系了。
    void PermutationRecursion(string str, int begin) {
        if (str[begin] == '\0') {
            //如果已经是结尾了，就说明全部的字符已经正确的处理了。
            cout &lt;&lt; str &lt;&lt; endl&lt;&lt;endl;
            m_res.push_back(str);
        }
        else {
            //遍历后面的这些字符
            for (int i = begin; str[i] != '\0'; i++) {
                //如果从begin 到i 这中间没有根 i 重复的字符
                //因为如果有与 i 重复的，那么这个 i 这个字符之前肯定是已经被交换到前面去遍历过了。
                if (!HasDuplicate(str, begin, i)) {
                    swap(str[i], str[begin]);       //把i交换到前面去 然后作为一个新的 str 进行递归
                    cout &lt;&lt; &quot;swap &quot; &lt;&lt; str[i] &lt;&lt; &quot;(&quot; &lt;&lt; i &lt;&lt; &quot;)&quot;
                        &lt;&lt; &quot; and &quot; &lt;&lt; str[begin] &lt;&lt; &quot;(&quot; &lt;&lt; begin &lt;&lt; &quot;)&quot; &lt;&lt; endl;
                    PermutationRecursion(str, begin + 1);       //继续递归后面的字符
                    swap(str[i], str[begin]);       //再交换回来 因为下个循环我还要用到 str
                }
            }
        }
    }
private:
    //find duplicate of str[i] in str[k,i)
    bool HasDuplicate(string&amp; str, int k, int i) const {
        for (int p = k; p &lt; i; p++) {
            if (str[p] == str[i])
                return true;
        }
        return false;
    }
};

int main() {
    Solution solu;
    vector&lt;string&gt; res;
    res = solu.Permutation(&quot;abca&quot;);
    for each (string s in res) {
        cout &lt;&lt; s &lt;&lt; endl;
    }
    return 0;
}
</code></pre>

<p>输出：</p>

<pre><code>swap a(0) and a(0)
swap b(1) and b(1)
swap c(2) and c(2)
swap a(3) and a(3)
abca

swap c(3) and a(2)
swap c(3) and c(3)
abac

swap b(2) and c(1)
swap b(2) and b(2)
swap a(3) and a(3)
acba

swap b(3) and a(2)
swap b(3) and b(3)
acab

swap b(3) and a(1)
swap c(2) and c(2)
swap b(3) and b(3)
aacb

swap c(3) and b(2)
swap c(3) and c(3)
aabc

swap a(1) and b(0)
swap a(1) and a(1)
swap c(2) and c(2)
swap a(3) and a(3)
baca

swap c(3) and a(2)
swap c(3) and c(3)
baac

swap a(2) and c(1)
swap a(2) and a(2)
swap a(3) and a(3)
bcaa

swap a(2) and c(0)
swap b(1) and b(1)
swap a(2) and a(2)
swap a(3) and a(3)
cbaa

swap b(2) and a(1)
swap b(2) and b(2)
swap a(3) and a(3)
caba

swap b(3) and a(2)
swap b(3) and b(3)
caab

aabc
aacb
abac
abca
acab
acba
baac
baca
bcaa
caab
caba
cbaa
</code></pre>

<p>嗯，OK，这个方法真的很不错。</p>

<h2 id="stl-中-直接使用-next-permutation-求一个容器的全排列">STL 中，直接使用 next_permutation 求一个容器的全排列</h2>

<p>事实上，在STL中，可以直接使用next_permutation方便的求一个容器的全排列。</p>

<p>代码如下：</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
using namespace std;



class Solution {
public:
    vector&lt;string&gt; Permutation(string str) {
        vector&lt;string&gt; res;
        if (str.empty() == true) {
            return res;
        }
        sort(str.begin(), str.end());
        do {
            res.push_back(str);
        } while (next_permutation(str.begin(), str.end()));//看来stl一定要掌握，尤其是关于各种容器的应用
        return res;
    }
};

int main() {
    Solution solu;
    vector&lt;string&gt; res;
    res = solu.Permutation(&quot;abca&quot;);
    for each (string s in res) {
        cout &lt;&lt; s &lt;&lt; endl;
    }
    return 0;
}
</code></pre>

<p>输出：</p>

<pre><code>aabc
aacb
abac
abca
acab
acba
baac
baca
bcaa
caab
caba
cbaa
</code></pre>

<p><strong>看来，STL 中的东西，尤其是各种容器和对容器的操作一定要掌握，比如方法二中的swap、sort和这里的 next_permutation。等。</strong></p>

<hr />

<h1 id="comment">COMMENT</h1>

    </div>

    
    

    
    

    <footer class="post-footer">
      

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/04-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer%E9%87%8C%E9%9D%A2%E7%9A%84/%E7%AE%97%E6%B3%95-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">算法 树的子结构</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/post/91-%E9%9D%9E%E6%A0%B8%E5%BF%83/wordpress/wordpress-%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE%E6%8F%92%E4%BB%B6-mikhak-syntax-highlighter/">
            <span class="next-text nav-default">wordpress 代码高亮插件 mikhak syntax highlighter</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="iteratelyd@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="http://github.com/iterateself" class="iconfont icon-github" title="github"></a>
      <a href="https://www.zhihu.com/people/thebegin/activities" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="https://www.douban.com/people/68028070/" class="iconfont icon-douban" title="douban"></a>
  <a href="http://iterate.site/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> site pv: <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
    <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> site uv: <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2018
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">iterateself</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>


<script type="text/javascript" src="/dist/even.min.js?v=3.2.0"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>








</body>
</html>
