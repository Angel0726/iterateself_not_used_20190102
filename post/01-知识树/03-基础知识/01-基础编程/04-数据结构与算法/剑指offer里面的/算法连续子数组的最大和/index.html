<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>算法：连续子数组的最大和 - 迭代自己</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="iterateself" />
  <meta name="description" content="author: evo comments: true date: 2018-05-22 13:31:18&#43;00:00 layout: post link: http://106.15.37.116/2018/05/22/%e7%ae%97%e6%b3%95%ef%bc%9a%e8%bf%9e%e7%bb%ad%e5%ad%90%e6%95%b0%e7%bb%84%e7%9a%84%e6%9c%80%e5%a4%a7%e5%92%8c/ slug: &amp;lsquo;%e7%ae%97%e6%b3%95%ef%bc%9a%e8%bf%9e%e7%bb%ad%e5%ad%90%e6%95%b0%e7%bb%84%e7%9a%84%e6%9c%80%e5%a4%a7%e5%92%8c&amp;rsquo; title: 算法：连续子数组的最大和 wordpress_id: 6294 categories: - 基础程序设计 tags: - ordinary algorithm [mathjax] 注：非原创，只是按照自己的思路做了整合，修改。推荐直接看 ORIGINAL" />

  <meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.47.1" />


<link rel="canonical" href="http://iterate.site/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/04-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer%E9%87%8C%E9%9D%A2%E7%9A%84/%E7%AE%97%E6%B3%95%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">




<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<link href="/dist/even.min.css?v=3.2.0" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">




<meta property="og:title" content="算法：连续子数组的最大和" />
<meta property="og:description" content="author: evo comments: true date: 2018-05-22 13:31:18&#43;00:00 layout: post link: http://106.15.37.116/2018/05/22/%e7%ae%97%e6%b3%95%ef%bc%9a%e8%bf%9e%e7%bb%ad%e5%ad%90%e6%95%b0%e7%bb%84%e7%9a%84%e6%9c%80%e5%a4%a7%e5%92%8c/ slug: &lsquo;%e7%ae%97%e6%b3%95%ef%bc%9a%e8%bf%9e%e7%bb%ad%e5%ad%90%e6%95%b0%e7%bb%84%e7%9a%84%e6%9c%80%e5%a4%a7%e5%92%8c&rsquo; title: 算法：连续子数组的最大和 wordpress_id: 6294 categories: - 基础程序设计 tags: - ordinary algorithm [mathjax] 注：非原创，只是按照自己的思路做了整合，修改。推荐直接看 ORIGINAL" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://iterate.site/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/04-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer%E9%87%8C%E9%9D%A2%E7%9A%84/%E7%AE%97%E6%B3%95%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/" /><meta property="article:published_time" content="2018-06-11T08:14:55&#43;00:00"/>
<meta property="article:modified_time" content="2018-06-11T08:14:55&#43;00:00"/>
<meta itemprop="name" content="算法：连续子数组的最大和">
<meta itemprop="description" content="author: evo comments: true date: 2018-05-22 13:31:18&#43;00:00 layout: post link: http://106.15.37.116/2018/05/22/%e7%ae%97%e6%b3%95%ef%bc%9a%e8%bf%9e%e7%bb%ad%e5%ad%90%e6%95%b0%e7%bb%84%e7%9a%84%e6%9c%80%e5%a4%a7%e5%92%8c/ slug: &lsquo;%e7%ae%97%e6%b3%95%ef%bc%9a%e8%bf%9e%e7%bb%ad%e5%ad%90%e6%95%b0%e7%bb%84%e7%9a%84%e6%9c%80%e5%a4%a7%e5%92%8c&rsquo; title: 算法：连续子数组的最大和 wordpress_id: 6294 categories: - 基础程序设计 tags: - ordinary algorithm [mathjax] 注：非原创，只是按照自己的思路做了整合，修改。推荐直接看 ORIGINAL">


<meta itemprop="datePublished" content="2018-06-11T08:14:55&#43;00:00" />
<meta itemprop="dateModified" content="2018-06-11T08:14:55&#43;00:00" />
<meta itemprop="wordCount" content="2684">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="算法：连续子数组的最大和"/>
<meta name="twitter:description" content="author: evo comments: true date: 2018-05-22 13:31:18&#43;00:00 layout: post link: http://106.15.37.116/2018/05/22/%e7%ae%97%e6%b3%95%ef%bc%9a%e8%bf%9e%e7%bb%ad%e5%ad%90%e6%95%b0%e7%bb%84%e7%9a%84%e6%9c%80%e5%a4%a7%e5%92%8c/ slug: &lsquo;%e7%ae%97%e6%b3%95%ef%bc%9a%e8%bf%9e%e7%bb%ad%e5%ad%90%e6%95%b0%e7%bb%84%e7%9a%84%e6%9c%80%e5%a4%a7%e5%92%8c&rsquo; title: 算法：连续子数组的最大和 wordpress_id: 6294 categories: - 基础程序设计 tags: - ordinary algorithm [mathjax] 注：非原创，只是按照自己的思路做了整合，修改。推荐直接看 ORIGINAL"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">迭代自己</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">最新</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a><a href="/catalog/">
        <li class="mobile-menu-item">完整目录</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">迭代自己</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">最新</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/catalog/">完整目录</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">算法：连续子数组的最大和</h1>

      <div class="post-meta">
        <span class="post-time"> 2018-06-11 </span>
        
        <span class="more-meta"> 2684 words </span>
        <span class="more-meta"> 6 mins read </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> times read </span>
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  
  <div class="post-toc-content">
    <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#ordinary-algorithm">- ordinary algorithm</a></li>
<li><a href="#相关资料">相关资料</a></li>
<li><a href="#需要补充的">需要补充的</a></li>
</ul></li>
<li><a href="#introduction">INTRODUCTION</a></li>
<li><a href="#题目">题目</a>
<ul>
<li><a href="#题目描述">题目描述</a>
<ul>
<li><a href="#样例">样例</a></li>
</ul></li>
</ul></li>
<li><a href="#题目解答">题目解答</a>
<ul>
<li><a href="#暴力方法">暴力方法</a></li>
<li><a href="#动态规划">动态规划</a></li>
<li><a href="#贪心思想">贪心思想</a></li>
</ul></li>
<li><a href="#comment">COMMENT</a></li>
</ul>
</nav>
  </div>
</div>

    
    

    
    <div class="post-content">
      

<hr />

<p>author: evo
comments: true
date: 2018-05-22 13:31:18+00:00
layout: post
link: <a href="http://106.15.37.116/2018/05/22/%e7%ae%97%e6%b3%95%ef%bc%9a%e8%bf%9e%e7%bb%ad%e5%ad%90%e6%95%b0%e7%bb%84%e7%9a%84%e6%9c%80%e5%a4%a7%e5%92%8c/">http://106.15.37.116/2018/05/22/%e7%ae%97%e6%b3%95%ef%bc%9a%e8%bf%9e%e7%bb%ad%e5%ad%90%e6%95%b0%e7%bb%84%e7%9a%84%e6%9c%80%e5%a4%a7%e5%92%8c/</a>
slug: &lsquo;%e7%ae%97%e6%b3%95%ef%bc%9a%e8%bf%9e%e7%bb%ad%e5%ad%90%e6%95%b0%e7%bb%84%e7%9a%84%e6%9c%80%e5%a4%a7%e5%92%8c&rsquo;
title: 算法：连续子数组的最大和
wordpress_id: 6294
categories:
- 基础程序设计
tags:</p>

<h2 id="ordinary-algorithm">- ordinary algorithm</h2>

<!-- more -->

<p>[mathjax]</p>

<p><strong>注：非原创，只是按照自己的思路做了整合，修改。推荐直接看 ORIGINAL 中所列的原文。</strong></p>

<h2 id="相关资料">相关资料</h2>

<ol>
<li></li>
</ol>

<p><a href="https://github.com/gatieme/CodingInterviews">CodingInterviews</a></p>

<h2 id="需要补充的">需要补充的</h2>

<ul>
<li>aaa</li>
</ul>

<hr />

<h1 id="introduction">INTRODUCTION</h1>

<ul>
<li>aaa</li>
</ul>

<h1 id="题目">题目</h1>

<h2 id="题目描述">题目描述</h2>

<p>在古老的一维模式识别中，常常需要计算连续子向量的最大和，当向量全为正数的时候，问题很好解决。但是，如果向量中包含负数，是否应该包含某个负数，并期望旁边的正数会弥补它呢？</p>

<h3 id="样例">样例</h3>

<p>例如：{6,-3,-2,7,-15,1,2,2}</p>

<p>连续子向量的最大和为8 (从第0个开始,到第3个为止)。</p>

<h1 id="题目解答">题目解答</h1>

<h2 id="暴力方法">暴力方法</h2>

<p>立即想到的最直接的方法就是找出所有的子数组，然后求出所有的和，遍历之后找到最大的哪个子数组。</p>

<p>如果把每个子数组都遍历出来，然后每个都求和，那么复杂度是 (O(N^3)) 。</p>

<p>而实际上，在遍历过程中，我们一般是这么计算的：下标 i 与 j 之间的区间和为 Sum[i,j] = Sum[i,j-1]+arr[j] ，也就是说，因此子数组的求和不是每次都重新遍历，因此算法复杂度是 (O(N^2)) 。</p>

<p>代码如下：</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;


class Solution {
public:
    int FindGreatestSumOfSubArray(vector&lt;int&gt; array) {
        if (array.size() == 0) {
            return 0;
        }
        int sum, maxSum = INT_MIN;
        //遍历每一个可能存在的子数组
        for (unsigned int i = 0; i &lt; array.size(); i++) {
            sum = 0;
            for (unsigned int j = i; j &lt; array.size(); j++) {
                sum += array[j];
                if (sum &gt; maxSum) {
                    maxSum = sum;
                }
            }
        }
        return maxSum;
    }
};

int main() {
    Solution solu;

    int arr1[] = { 6, -3, -2, 7, -15, 1, 2, 2 };
    vector&lt;int&gt; vec1(arr1, arr1 + sizeof(arr1) / sizeof(arr1[0]));
    cout &lt;&lt; &quot;maxSum = &quot; &lt;&lt; solu.FindGreatestSumOfSubArray(vec1) &lt;&lt; endl;

    int arr2[] = { -2, -8, -1, -5, -9 };
    vector&lt;int&gt; vec2(arr2, arr2 + sizeof(arr2) / sizeof(arr2[0]));
    cout &lt;&lt; &quot;maxSum = &quot; &lt;&lt; solu.FindGreatestSumOfSubArray(vec2) &lt;&lt; endl;

    return 0;
}
</code></pre>

<p>输出：</p>

<pre><code>maxSum = 8
maxSum = -1
</code></pre>

<p>那么有没有更方便的方法呢？</p>

<h2 id="动态规划">动态规划</h2>

<p><strong>理解了，但是感觉上还是有点没转过弯来，为什么说是动态规划？动态规划的思想是什么样的？</strong></p>

<p>首先，我们知道：</p>

<ul>
<li>一个以 i 为结尾的子数组，只可能是 i 本身，或者是一个以 i-1为结尾的子数组加上 i 这个数。</li>
</ul>

<p>注意，我先不管这个子数组到底是以什么开始的，我只知道它的结尾是满足上面这个规律的。</p>

<p>那么，当我们求一个以 i 为结尾的子数组的和的时候，那么我就要比较：</p>

<p>[f(i)= \left{\begin{matrix} data(i)\ f(i-1)_1+data(i)\ f(i-1)_2+data(i)\ f(i-1)<em>3+data(i)\ f(i-1)</em>{\cdots }+data(i)\ \end{matrix}\right.]</p>

<p>OK，我们从第一个开始看：</p>

<p>[f(0)= \left{\begin{matrix} data(0)\ \end{matrix}\right.]</p>

<p>[f(1)= \left{\begin{matrix} data(1)\ f(0)+data(1)\ \end{matrix}\right.]</p>

<p>[f(2)= \left{\begin{matrix} data(2)\ f(1)+data(2)\ \end{matrix}\right.]</p>

<p>可见，实际上，对于 i 为结尾的子数组来说，我的 i-1 为结尾的子数组不管有多少个，但是 (f(i-1)) 是可以认为只有一个的，因为毕竟 (f(i-1)) 都是要真正求出来的。</p>

<p>OKOK，这样，我们之前的式子就变成：</p>

<p>[f(i)= \left{\begin{matrix} data(i)\ f(i-1)+data(i)\ \end{matrix}\right.]</p>

<p>OK，这个时候，这里面的 (data(i)) 和  (f(i-1)+data(i))  都是固定的，我们就要看看，哪个可以使 f(i) 相对大？</p>

<p>实际上，对于上面这个式子，有一点我们是可以肯定的，就是：如果 (f(i-1)) 是小于0 的，那么我们肯定选 (data(i)) ，如果 (f(i-1)) 是大于0的，那么我们肯定选 (f(i-1)+data(i)) 。</p>

<p>也就是说，我们选什么结果与 data(i) 是没有关系的，只与 (f(i-1)) 有关系。</p>

<p>OK，我们这样就把这个求出来的比较大 的 (f(i)) 存放起来。</p>

<p>然后，我们比较一下每个 i 对应的 (f(i))  就找出最大值了。</p>

<p>代码如下：</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;



class Solution {
private:
    int dp[1000];
public:
    int FindGreatestSumOfSubArray(vector&lt;int&gt; array) {
        if (array.size() == 0) {
            return 0;
        }

        int temp = 0;
        int maxSum = INT_MIN;
        dp[0] = array[0];
        //没有很理解
        for (unsigned int i = 1; i &lt; array.size(); i++) {
            if (dp[i - 1] &lt;= 0) {
                dp[i] = array[i];//如果  dp[i - 1] 小于0，那么这个最大值就是第 i 个值
            }
            else {
                dp[i] = dp[i - 1] + array[i];//否则，这个最大值就是 dp[i - 1]  加上第 i 个值
            }
            //判断这个时候的值是不是比最大值还大
            if (dp[i] &gt; maxSum) {
                maxSum = dp[i];
            }
        }
        //输出最大值对应的范围
        return maxSum;
    }
};

int main() {
    Solution solu;

    int arr1[] = { 6, -3, -2, 7, -15, 1, 2, 2 };
    vector&lt;int&gt; vec1(arr1, arr1 + sizeof(arr1) / sizeof(arr1[0]));
    cout &lt;&lt; &quot;maxSum = &quot; &lt;&lt; solu.FindGreatestSumOfSubArray(vec1) &lt;&lt; endl;

    int arr2[] = { -2, -8, -1, -5, -9 };
    vector&lt;int&gt; vec2(arr2, arr2 + sizeof(arr2) / sizeof(arr2[0]));
    cout &lt;&lt; &quot;maxSum = &quot; &lt;&lt; solu.FindGreatestSumOfSubArray(vec2) &lt;&lt; endl;

    return 0;
}
</code></pre>

<p>输出：</p>

<pre><code>maxSum = 8
maxSum = -1
</code></pre>

<p>那么还有更利害的方法吗？</p>

<h2 id="贪心思想">贪心思想</h2>

<p><strong>没有很理解。要仔细理解下。</strong></p>

<p>如果希望达到 O(n) 时间复杂度，我们就应该能够想到我们只能对整个数组进行一次扫描，在扫描过程中求出最大连续子序列和以及子序列的起点和终点位置。</p>

<p>假如输入数组为{1,-2,3,10,-4,7,2,-5}，我们尝试从头到尾累加其中的正数，</p>

<p>初始化和为0，第一步加上1，此时和为1，第二步加上-2，此时和为-1，第三步加上3，此时我们发现-1+3=2，最大和 2 反而比 3 一个单独的整数小，这是因为3加上了一个负数。</p>

<p>发现这个规律以后我们就重新作出累加条件：</p>

<ul>
<li><p>如果当前和为负数，那么就放弃前面的累加和，从数组中的下一个数再开始计数。</p></li>

<li><p>否则我们就继续累计，并且保存当前的累计和。</p></li>
</ul>

<p>这个方法其实就是动态规划算法的改进。</p>

<p>代码如下：</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

class Solution {
public:
    int FindGreatestSumOfSubArray(vector&lt;int&gt; array) {
        if (array.size() == 0) {
            return 0;
        }

        int sum = 0, maxSum = INT_MIN;

        for (int i = 0; i &lt; array.size(); i++) {
            sum += array[i];
            cout &lt;&lt; sum &lt;&lt; endl;
            // 如果当前和小于0, 就舍弃它, 重新开始累加
            if (sum &lt; 0) {
                sum = 0;//对于全负数就不正确了
            }
            else if (sum &gt; maxSum) {
                // 否则的话累计当前和
                maxSum = sum;
            }
        }
        return maxSum;
    }
};

int main() {
    Solution solu;

    int arr1[] = { 6, -3, -2, 7, -15, 1, 2, 2 };
    vector&lt;int&gt; vec1(arr1, arr1 + sizeof(arr1) / sizeof(arr1[0]));
    cout &lt;&lt; &quot;maxSum = &quot; &lt;&lt; solu.FindGreatestSumOfSubArray(vec1) &lt;&lt; endl;

    int arr2[] = { -2, -8, -1, -5, -9 };
    vector&lt;int&gt; vec2(arr2, arr2 + sizeof(arr2) / sizeof(arr2[0]));
    cout &lt;&lt; &quot;maxSum = &quot; &lt;&lt; solu.FindGreatestSumOfSubArray(vec2) &lt;&lt; endl;

    return 0;
}&lt;span id=&quot;mce_marker&quot; data-mce-type=&quot;bookmark&quot; data-mce-fragment=&quot;1&quot;&gt;​&lt;/span&gt;
</code></pre>

<p>输出：</p>

<pre><code>6
3
1
8
-7
1
3
5
maxSum = 8
-2
-8
-1
-5
-9
maxSum = -2147483648
</code></pre>

<p>可以看到上面还是有个问题：</p>

<p>如果整个数组的数据全是负数，那么我们的 maxSum 无法进行累计，最后仍为0。这个问题怎么解决呢？</p>

<p>整个数组全是负数，那么最大值也是负数，而这个最大值正好是数组连续子数组的最大和，因此我们维护一个最大值 maxNum 即可：</p>

<ul>
<li><p>如果 maxNum&lt;0，我们就直接返回 maxNum</p></li>

<li><p>如果 maxNum&gt;0，那么我们就返回累计的 maxSum</p></li>
</ul>

<p>如下：</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;


class Solution {
public:
    int FindGreatestSumOfSubArray(vector&lt;int&gt; array) {
        if (array.size() == 0) {
            return 0;
        }
        int maxNum = INT_MIN;//用来保存数据中的最大值
        int maxSum = INT_MIN;//用来保存最大的和
        int sum = 0;

        for (int i = 0; i &lt; array.size(); i++) {
            sum += array[i];
            cout &lt;&lt; sum &lt;&lt; endl;
            // 如果当前和小于0, 就舍弃这个, 重新开始累加
            if (sum &lt; 0) {
                sum = 0;
            }
            else if (sum &gt; maxSum) {
                //否则的话累计当前和
                maxSum = sum;
            }

            //将数组中的最大值保存下来，这种情况是为了排除整个数组全为负数的特殊情况
            if (array[i] &gt; maxNum) {
                maxNum = array[i];
            }
        }
        //如果数组最大值大于0, 那么我们就直接返回累计的最大和
        //如果数组最大值为负数, 说明整个数组都是负数, 那么就返回数组最大值
        return (maxNum &gt; 0) ? maxSum : maxNum;
    }
};

int main() {
    Solution solu;

    int arr1[] = { 2, -1, 3,-4, -1, 1, 2, 2 };
    vector&lt;int&gt; vec1(arr1, arr1 + sizeof(arr1) / sizeof(arr1[0]));
    cout &lt;&lt; &quot;maxSum = &quot; &lt;&lt; solu.FindGreatestSumOfSubArray(vec1) &lt;&lt; endl;

    int arr2[] = { -2, -8, -1, -5, -9 };
    vector&lt;int&gt; vec2(arr2, arr2 + sizeof(arr2) / sizeof(arr2[0]));
    cout &lt;&lt; &quot;maxSum = &quot; &lt;&lt; solu.FindGreatestSumOfSubArray(vec2) &lt;&lt; endl;

    return 0;
}
</code></pre>

<p>输出：</p>

<pre><code>2
1
4
0
-1
1
3
5
maxSum = 5
-2
-8
-1
-5
-9
maxSum = -1
</code></pre>

<p>但是其实有更好的办法，每次弄完后我们无需将那个 sum 置为 0，而是需要从新的位置（下一个位置）开始，因此此时其实 sum=array[i + 1]。</p>

<p>代码如下：</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;


class Solution {
public:
    int FindGreatestSumOfSubArray(vector&lt;int&gt; array) {
        if (array.size() == 0) {
            return 0;
        }
        int maxSum = INT_MIN;
        int sum = 0;
        for (unsigned int i = 0; i &lt; array.size(); i++) {
            if (sum &lt;= 0) {
                sum = array[i];
            }
            else {
                sum += array[i];
            }
            cout &lt;&lt; &quot;num = &quot; &lt;&lt; array[i] &lt;&lt; &quot;, sum = &quot; &lt;&lt; sum &lt;&lt; endl;
            if (sum &gt; maxSum) {
                maxSum = sum;
            }
        }
        return maxSum;
    }
};

int main() {
    Solution solu;

    int arr1[] = { 2, -1, 3,-4, -1, 1, 2, 2 };
    vector&lt;int&gt; vec1(arr1, arr1 + sizeof(arr1) / sizeof(arr1[0]));
    cout &lt;&lt; &quot;maxSum = &quot; &lt;&lt; solu.FindGreatestSumOfSubArray(vec1) &lt;&lt; endl;

    int arr2[] = { -2, -8, -1, -5, -9 };
    vector&lt;int&gt; vec2(arr2, arr2 + sizeof(arr2) / sizeof(arr2[0]));
    cout &lt;&lt; &quot;maxSum = &quot; &lt;&lt; solu.FindGreatestSumOfSubArray(vec2) &lt;&lt; endl;

    return 0;
}
</code></pre>

<p>输出：</p>

<pre><code>num = 2, sum = 2
num = -1, sum = 1
num = 3, sum = 4
num = -4, sum = 0
num = -1, sum = -1
num = 1, sum = 1
num = 2, sum = 3
num = 2, sum = 5
maxSum = 5
num = -2, sum = -2
num = -8, sum = -8
num = -1, sum = -1
num = -5, sum = -5
num = -9, sum = -9
maxSum = -1
</code></pre>

<hr />

<h1 id="comment">COMMENT</h1>

    </div>

    
    

    
    

    <footer class="post-footer">
      

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/04-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer%E9%87%8C%E9%9D%A2%E7%9A%84/%E7%AE%97%E6%B3%95%E4%BB%8E1%E5%88%B0n%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">算法：从1到n整数中1出现的次数</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01-c&#43;&#43;/c&#43;&#43;-%E5%B8%B8%E8%A7%81%E9%A2%84%E5%AE%9A%E4%B9%89%E5%AE%8F%E7%9A%84%E4%BD%BF%E7%94%A8/">
            <span class="next-text nav-default">C&#43;&#43; 常见预定义宏的使用</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="iteratelyd@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="http://github.com/iterateself" class="iconfont icon-github" title="github"></a>
      <a href="https://www.zhihu.com/people/thebegin/activities" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="https://www.douban.com/people/68028070/" class="iconfont icon-douban" title="douban"></a>
  <a href="http://iterate.site/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> site pv: <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
    <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> site uv: <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2018
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">iterateself</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>


<script type="text/javascript" src="/dist/even.min.js?v=3.2.0"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>








</body>
</html>
