<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>02 循环结构程序设计 - 迭代自己</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="iterateself" />
  <meta name="description" content="2.1 for循环 2.2 while循坏和 do-while 循环 2.3 循环的代价 2.4 算法竞赛中的输入输出框架 2.5 注解与习题 第2章 循环结构程序设计 学习目标 叵掌握for循环的使用方" />

  <meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.47.1" />


<link rel="canonical" href="http://iterate.site/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/04-%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8/02-%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">




<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<link href="/dist/even.min.css?v=3.2.0" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">




<meta property="og:title" content="02 循环结构程序设计" />
<meta property="og:description" content="2.1 for循环 2.2 while循坏和 do-while 循环 2.3 循环的代价 2.4 算法竞赛中的输入输出框架 2.5 注解与习题 第2章 循环结构程序设计 学习目标 叵掌握for循环的使用方" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://iterate.site/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/04-%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8/02-%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" /><meta property="article:published_time" content="2018-06-27T08:26:02&#43;00:00"/>
<meta property="article:modified_time" content="2018-06-27T08:26:02&#43;00:00"/>
<meta itemprop="name" content="02 循环结构程序设计">
<meta itemprop="description" content="2.1 for循环 2.2 while循坏和 do-while 循环 2.3 循环的代价 2.4 算法竞赛中的输入输出框架 2.5 注解与习题 第2章 循环结构程序设计 学习目标 叵掌握for循环的使用方">


<meta itemprop="datePublished" content="2018-06-27T08:26:02&#43;00:00" />
<meta itemprop="dateModified" content="2018-06-27T08:26:02&#43;00:00" />
<meta itemprop="wordCount" content="13669">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="02 循环结构程序设计"/>
<meta name="twitter:description" content="2.1 for循环 2.2 while循坏和 do-while 循环 2.3 循环的代价 2.4 算法竞赛中的输入输出框架 2.5 注解与习题 第2章 循环结构程序设计 学习目标 叵掌握for循环的使用方"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">迭代自己</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">主页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a><a href="/catalog/">
        <li class="mobile-menu-item">完整目录</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">迭代自己</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">主页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/catalog/">完整目录</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">02 循环结构程序设计</h1>

      <div class="post-meta">
        <span class="post-time"> 2018-06-27 </span>
        
        <span class="more-meta"> 13669 words </span>
        <span class="more-meta"> 28 mins read </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> times read </span>
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  
  <div class="post-toc-content">
    
  </div>
</div>

    
    

    
    <div class="post-content">
      <nav>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li><a href="#2-1-for循环">2.1 for循环</a></li>
<li><a href="#2-2-while循坏和-do-while-循环">2.2 while循坏和 do-while 循环</a></li>
<li><a href="#2-3-循环的代价">2.3 循环的代价</a></li>
<li><a href="#2-4-算法竞赛中的输入输出框架">2.4 算法竞赛中的输入输出框架</a></li>
<li><a href="#2-5-注解与习题">2.5 注解与习题</a></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</nav>

<p>第2章 循环结构程序设计</p>

<p>学习目标</p>

<p>叵掌握for循环的使用方法 E掌握while和do-while循环的使用方法 叵学会使用计数器和累加器 E学会用输出中间结果的方法调试 叵学会用计时函数测试程序效率 E学会用重定向的方式读写文件 E学会用fopen的方式读写文件 叵了解算法竞赛对文件读写方式和命名的严格性 叵记住变量在赋值之前的值是不确定的 叵学会使用条件编译指示构建本地运行环境 叵学会用编译选项-Wall获得更多的警告信息</p>

<p>第1章的程序虽然完善，但并没有发挥出计算机的优势。顺序结构程序自上到下只执行</p>

<p>一遍，而分支结构中甚至有些语句可能一遍都执行不了。换句话说，为了让计算机执行大量</p>

<p>操作，必须编写大量的语句。能不能只编写少量语句，就让计算机做大量的工作呢？这就是</p>

<p>本章的主题。基本思路很简单：一条语句执行多次就可以了。但如何让这样的程序真正发挥</p>

<p>作用，可不是一件容易的事。</p>

<h6 id="2-1-for循环">2.1 for循环</h6>

<p>考虑这样一个问题：打印1， 2， 3， .    ， 10，每个占一行。本着“解决问题第一”的思</p>

<p>想，很容易写出程序：10条printf语句就可以了。或者也可以写一条，每个数后面加一 个“\n”换行符。但如果把10改成100呢？ 1000呢？甚至这个重复次数是可变的：“输入正整 数n ,打印1 , 2 , 3 ,…，n ,每个占一行。”又怎么办呢？这时可以使用for循环。</p>

<p>程序2-1输出1 , 2 , 3，…，n的值</p>

<p>1 #include<stdio.h></p>

<p>2 int main()</p>

<p>3 {</p>

<p>4 int n;</p>

<p>5 scanf(&ldquo;%d&rdquo;, &amp;n);</p>

<p>6 for(int i = 1; i &lt;= n; i++)</p>

<p>7 printf(&ldquo;%d\n&rdquo;, i);</p>

<p>8 return 0;</p>

<p>9 }</p>

<p>暂时不用考虑细节，只要知道它是“让i依次等于1 , 2 , 3 ,…，n,每次都执行 printf( &ldquo;％d\n&rdquo;， i)； ”即可。这个“依次”非常重要：程序运行结果一定是1， 2， 3， .    ， n，</p>

<p>而不是别的顺序。</p>

<p>提示2-1 : for循环的格式为：for (初始化；条件；调整)循环体；</p>

<p>在刚才的例子中，初始化语句是“int i = 1”。这是一条声明+赋值的语句，含义是声明一 个新的变量i ,然后赋值为1。循环条件是“匕n”，当循环条件满足时始终进行循环。调整方法 是i++,其含义和i = i+ 1相同——表示给i增加1。循环体是语句“printf ( &ldquo;%d\n&rdquo; , i ); ”， 这就是计算机反复执行的内容。注意循环变量的妙用：尽管每次执行的语句相同，但是由于 i的值不断变化，该语句的输出结果也是不断变化的。</p>

<p>提示2-2 :尽管for循环反复执行相同的语句，但这些语句每次的执行效果往往不同。</p>

<p>为了更深入地理解for循环，下面给出了程序2-1的执行过程。</p>

<p>当前行：5。scanf请求键盘输入，假设输入4。此时变量n=4 ,继续。</p>

<p>当前行：6。这是第一次执行到该语句，执行初始化语句int i = 1。条件匕n满足，继续。</p>

<p>当前行：7。由于i = 1 ,在屏幕输出1并换行。循环体结束，跳转回第6行。</p>

<p>当前行：6。先执行调整语句i++,此时i = 2 , n = 4 ,条件匕n满足，继续。</p>

<p>当前行：7。由于i = 2 ,在屏幕输出2并换行。循环体结束，跳转回第6行。</p>

<p>当前行：6。先执行调整语句i++,此时i = 3 , n = 4 ,条件匕n满足，继续。</p>

<p>当前行：7。由于i = 3 ,在屏幕输出3并换行。循环体结束，跳转回第6行。</p>

<p>当前行：6。先执行调整语句i++,此时i = 4 , n = 4 ,条件匕n满足，继续。</p>

<p>当前行：7。由于i = 4 ,在屏幕输出4并换行。循环体结束，跳转回第6行。</p>

<p>当前行：6。先执行调整语句i++,此时i = 5 , n = 4 ,条件匕n不满足，跳出循环体。</p>

<p>当前行： 8。程序结束。</p>

<p>这个执行过程对于理解for循环非常重要：语句是一条一条执行的。强烈建议教师在课堂 上演示单步调试的方法，并打开i和n的watch功能，以帮助学生掌握如何用实验验证上面所介 绍的执行过程。观察执行过程时应留意两个方面：“当前行”的跳转(在IDE中往往高亮显 示)，以及变量的变化。这二者也是编码、测试和调试的重点。根据实际情况，教师可以用 IDE (如Code :: Blocks )或者文本界面的gdb进行演示。gdb的简明参考见附录A。</p>

<p>提示2-3：编写程序时，要特别留意“当前行”的跳转和变量的改变。</p>

<p>上面的代码里还有一个重要的细节：变量i定义在循环语句中，因此i在循环体内不可 见，例如，在第8行之前再插入一条“printf ( &ldquo;%d\n&rdquo; , i ); ”会报错<a href="#bookmark36">山</a>。有经验的程序员总是 尽量缩小变量定义的范围，当写了足够多的程序之后，这样做的优点会慢慢表现出来。</p>

<p>提示2-4 :建议尽量缩短变量的定义范围。例如，在for循环的初始化部分定义循环变 量。</p>

<p>有了for循环，可以解决一些简单的问题。</p>

<p>例题2-1 aabb</p>

<p>输出所有形如aabb的4位完全平方数(即前两位数字相等，后两位数字也相等)。</p>

<p>【分析】</p>

<p>分支和循环结合在一起时功能强大：下面枚举所有可能的aabb，然后判断它们是否为完 全平方数。注意，a的范围是1〜9，但b可以是0。主程序如下：</p>

<p>for(int a = 1; a &lt;= 9; a++)</p>

<p>for(int b = 0; b &lt;= 9; b++)</p>

<p>if (aabb是完全平方数)printf ( &ldquo;%d\n&rdquo; , aabb);</p>

<p>请注意，这里用到了循环的嵌套：for循环的循环体自身又是一个循环。如果难以理解嵌 套循环，可以用前面介绍的方法——在IDE或gdb中单步执行，观察“当前行”和循环变量a和b 的变化过程。</p>

<p>上面的程序并不完整——“aabb是完全平方数”是中文描述，而不是合法的C语言表达 式，而aabb在C语言中也是另外一个变量，而不是把两个数字a和两个数字b拼在一起(C语言 中的变量名可以由多个字母组成)。但这个“程序”很容易理解，甚至能让读者的思路更加清 晰。</p>

<p>这里把这样“不是真正程序”的“代码”称为伪代码(pseudocode )。虽然有一些正规的伪 代码定义，但在实际应用中，并不需要太拘泥于伪代码的格式。主要目标是描述算法梗概，</p>

<p>避开细节，启发思路。</p>

<p>提示2-5 ：不拘一格地使用伪代码来思考和描述算法是一种值得推荐的做法。</p>

<p>写出伪代码之后，我们需要考虑如何把它变成真正的代码。上面的伪代码有两个“非 法”的地方：完全平方数判定，以及aabb这个变量。后者相对比较容易：用另外一个变量。= a*1100 + b*11存储即可。</p>

<p>提示2-6：把伪代码改写成代码时，一般先选择较为容易的任务来完成。</p>

<p>接下来的问题就要困难一些了：如何判断n是否为完全平方数？第1章中用过“开平方”函 数，可以先求出其平方根，然后看它是否为整数，即用一个int型变量m存储sqrt( n)四舍五</p>

<p>入后的整数，然后判断m2是否等于n。函数floor ( x )返回不超过x的最大整数。完整程序如 下：</p>

<p>程序2-2 7744问题( 1)</p>

<p>#include<stdio.h> #include<math.h> int main()</p>

<p>{</p>

<p>for(int a = 1 for(int b = {</p>

<p>int n = a</p>

<p>a &lt;= 9; a++)</p>

<p>0; b &lt;= 9; b++)</p>

<p>1100 + b*11; //这里才开始使用n ,因此在这里定义</p>

<p>int m = floor(sqrt(n) + 0.5); if(m*m == n) printf(&ldquo;%d\n&rdquo;, n);</p>

<p>}</p>

<p>return 0;</p>

<p>读者可能会问：可不可以这样写？ if ( sqrt (n)= = floor ( sqrt ( n ) ) ) printf ( &ldquo;%d\n&rdquo; , n )，即直接判断sqrt ( n )是否为整数。理论上当然没 问题，但这样写不保险，因为浮点数的运算(和函数)有可能存在误差。</p>

<p>假设在经过大量计算后，由于误差的影响，整数1变成了0.9999999999 , floor的结果会 是0而不是1。为了减小误差的影响，一般改成四舍五入，即floor (x+0.5)<a href="#bookmark39">逆</a>。如果难以理 解，可以想象成在数轴上把一个单位区间往左移动0.5个单位的距离。floor (x)等于1的区间 为［1 ,2), 而floor(x+0.5)等于1的区间为［0.5 ,1.5)。</p>

<p>提示2-7 ：浮点运算可能存在误差。在进行浮点数比较时，应考虑到浮点误差。</p>

<p>另一个思路是枚举平方根x ,从而避免开平方操作。</p>

<p>程序2-3 7744问题( 2)</p>

<p>#include<stdio.h> int main()</p>

<p>{</p>

<p>if(hi/10 == hi%10 &amp;&amp; lo/10 == lo%10) printf(&ldquo;%d\n&rdquo;, n);</p>

<p>for(int x = 1;    ; x++)</p>

<p>{</p>

<p>int n = x * x;</p>

<table>
<thead>
<tr>
<th>if(n</th>
<th>&lt;</th>
<th>1000)</th>
<th>continue;</th>
</tr>
</thead>

<tbody>
<tr>
<td>if(n</td>
<td>&gt;</td>
<td>9999)</td>
<td>break;</td>
</tr>

<tr>
<td>int</td>
<td>hi</td>
<td>= n /</td>
<td>100;</td>
</tr>

<tr>
<td>int</td>
<td>lo</td>
<td>= n %</td>
<td>100;</td>
</tr>
</tbody>
</table>

<p>}</p>

<p>return 0;</p>

<p>}</p>

<p>此程序中的新知识是continue和break语句。continue是指跳回for循环的开始，执行调整语 句并判断循环条件（即“直接进行下一次循环”），而break是指直接跳出循环<a href="#bookmark41">@</a>。</p>

<p>这里的continue语句的作用是排除不足四位数的《，直接检查后面的数。当然，也可以直 接从x = 32开始枚举，但是continue可以帮助我们偷懒：不必求出循环的起始点。有了break， 连循环终点也不必指定——当《超过9999后会自动退出循环。注意，这里是“退出循环”而不 是“继续循环”（想一想，为什么），可以把break奂成continue加以验证。</p>

<p>另外，注意到这里的for语句是“残缺”的：没有指定循环条件。事实上，3部分都是可以 省略的。没错，for（;;）就是一个死循环，如果不采取措施（如break），就永远不会结 束。</p>

<h6 id="2-2-while循坏和-do-while-循环">2.2 while循坏和 do-while 循环</h6>

<p>例题2-2 3n+ 1问题</p>

<p>猜想<a href="#bookmark3">凶</a>：对于任意大于1的自然数《 ,若《为奇数，则将《变为3«+ 1 ,否则变为《的一半。 经过若干次这样的变换，一定会使《变为1。例如，3^10^5^16^8^4^2^1。</p>

<p>输入n ,输出变换的次数。n&lt;109。</p>

<p>样例输入：</p>

<p>3</p>

<p>样例输出：</p>

<p>7</p>

<p>【分析】</p>

<p>不难发现，程序完成的工作依然是重复性的：要么乘3加1，要么除以2，但和2.1节的程 序又不太一样：循环的次数是不确定的，而且n也不是“递增”式的循环。这样的情况很适合 用while循环来实现。</p>

<p>程序2-4 3n + 1问题（有bug ）</p>

<p>#include<stdio.h></p>

<p>int main()</p>

<p>{</p>

<p>int n, count = 0; scanf(&ldquo;%d&rdquo;, &amp;n); while(n &gt; 1)</p>

<p>{</p>

<p>if(n % 2 == 1) n = n*3+1; else n /= 2;</p>

<p>count++;</p>

<p>printf(&ldquo;%d\n&rdquo;, count) ; return 0;</p>

<p>}</p>

<p>上面的程序有好几个值得注意的地方。首先是“ =0”，意思是定义整型变量count的同时 初始化为0。接下来是while语句。</p>

<p>提示2-8 : while循环的格式为“while （条件）循环体；”。</p>

<p>此格式看上去比for循环更简单，可以用while改写for。“for （初始化；条件；调整）循环 体； ”等价于：</p>

<p>初始化;</p>

<p>while （条件）</p>

<p>{</p>

<p>循环体 ;</p>

<p>调整 ;</p>

<p>}</p>

<p>建议读者再次利用IDE或者gdb跟踪调试，看看执行流程是怎样的。</p>

<p>^ = 2的含义是。=^2,类似于前面介绍过的i++。很多运算符都有类似的用法，例 如，&amp;* = 3表示&amp; =巳*3。</p>

<p>count + +的作用是计数器。由于最终输出的是变换的次数，需要一个变量来完成计数。</p>

<p>提示2-9 ：当需要统计某种事物的个数时,可以用一个变量来充当计数器。</p>

<p>这个程序是否正确？先来测试一下：输入“987654321”,看看结果是什么。很不幸,答 案等于1一这明显是错误的。题目中给出的范围是n^109 ,这个987654321是合法的输入数 据。</p>

<p>提示2-10：不要忘记测试。一个看上去正确的程序可能隐含错误。</p>

<p>问题出在哪里呢？若反复阅读程序仍然无法找到答案,就动手实验吧！一种方法是利用 IDE和gdb跟踪调试，但这并不是本书所推荐的调试方法。一个更通用的方法是：输出中间结</p>

<p>果。</p>

<p>提示2-11 ：在观察无法找出错误时，可以用“输出中间结果”的方法查错。</p>

<p>在给n做变换的语句后加一条输出语句printf ( &ldquo;%d\n&rdquo; , n),将很快找到问题的所在：第 一次输出为－1332004332，它不大于1，所以循环终止。如果认真完成了前面的所有探索实 验，读者将立刻明白这其中的缘由：乘法溢出了。</p>

<p>下面稍微回顾一下数据类型的大小。在第1章中，通过实验得出了int整数的大小——很</p>

<p>可能是-2147483648〜2147483647 ,即-231〜231-1。为什么叫“很可能”呢，因为C99中只规定 了int至少是16位，却没有规定具体值<a href="#bookmark5">⑵</a>。是不是感觉有些别扭？的确如此，所以C99规定了 —些固定长度的整数，例如int32_t、uintS】<a href="#bookmark6">」</a>*。</p>

<p>好在算法竞赛的平台相对稳定，目前几乎在所有的比赛平台上，int都是32位整数。</p>

<p>提示2-12 : C99并没有规定int类型的确切大小，但在当前流行的竞赛平台中，int都是 32位整数，范围是-2147483648 ~ 2147483647。</p>

<p>回到本题。本题中n的上限109只比int的上界稍微小一点，因此溢出了也并不奇怪。只要</p>

<p>使用C99中新增的long long即可解决问题，其范围是-263〜263-1 ,唯一的区别就是要把输入时 的％」改成％lld。但这也是不保险的——在MinGW的gcc<a href="#bookmark9">m</a>中，要把％lld改成％I64d ,但奇怪 的是VC2008里又得改回％lld。是不是很容易搞错？所以如果涉及long long的输入输出，常用 C+ +的输入输出流或者自定义的输入输出方法，本书将在后面的章节对其进行深入讨论。</p>

<p>提示2-13 : long    long在Linux下的输入输出格式符为％叫，但Windows平台中有时</p>

<p>S%I64d。为保险起见，可以用后面介绍的C++流，或者编写自定义输入输出函数。</p>

<p>最后给出long long版本的代码，它避开了对long    long的输入输出，并且成功算出n =</p>

<p>987654321时的答案为180。</p>

<p>程序2-5 3n+ 1问题</p>

<p>#include<stdio.h> int main()</p>

<p>int n2, count</p>

<p>0;</p>

<p>scanf(&ldquo;%d&rdquo;, &amp;n2);</p>

<p>long long n = n2; while(n &gt; 1)</p>

<p>{</p>

<p>if(n % 2 == 1) n = n*3+1 ;</p>

<p>else n /= 2; count++;</p>

<p>}</p>

<p>printf(&ldquo;%d\n&rdquo;, count); return 0;</p>

<p>}</p>

<p>例题2-3近似计算</p>

<p>计算=[<em>丄-丄-丄</em>&hellip;，直到最后一项小于10-6。</p>

<p>4    3 5 7</p>

<p>【分析】</p>

<p>本题和例题2-2一样，也是重复计算，因此可以用循环实现。但不同的是，只有算完一</p>

<p>项之后才知道它是否小于10-6。也就是说，循环终止判断是在计算之后，而不是计算之前。 这样的情况很适合使用do-while循环。</p>

<p>程序2-6 近似计算</p>

<p>#include<stdio.h></p>

<p>int main() {</p>

<p>double sum = 0;</p>

<p>for(int i = 0;    ; i++) {</p>

<p>double term = 1.0 / (i*2+1); if(i % 2 == 0) sum += term; else sum -= term;</p>

<p>if(term &lt; 1e-6) break;</p>

<p>}</p>

<p>printf(&ldquo;%.6f\n&rdquo;, sum);</p>

<p>提示2-14 : do-while循环的格式为“do｛循环体｝while （条件）；”，其中循环体至少执 行一次,每次执行完循环体后判断条件,当条件满足时继续循环。</p>

<h6 id="2-3-循环的代价">2.3 循环的代价</h6>

<p>例题2-4 阶乘之和</p>

<p>输入《 ,计算&lt;S = 1! + 2 ! + 3 ! + &hellip;+n!的末6位(不含前导0 )。n&lt;106 , n !表示 前n个正整数之积。</p>

<p>样例输入：</p>

<p>10</p>

<p>样例输出：</p>

<p>37913</p>

<p>【分析】</p>

<p>这个任务并不难，引入累加变量S之后，核心算法只有“for (int i = 1 ； i&lt;=n; i++) S + =i ! ”。不过，C语言并没有阶乘运算符，所以这句话只是伪代码，而不是真正的代码。</p>

<p>事实上，还需要一次循环来计算i !,即“for ( int j = 1;j&lt;=i;j++) factorial* =j ; ”。代 码如下：</p>

<p>程序2-7 阶乘之和( 1)</p>

<p>#include<stdio.h></p>

<p>int main()</p>

<p>{</p>

<p>int n, S = 0;</p>

<p>scanf ( &ldquo;%d&rdquo;, &amp;n);</p>

<p>for(int i = 1; i &lt;= n; i++)</p>

<p>{</p>

<p>int factorial = 1;</p>

<p>for ( int j = 1; j &lt;= i; j++)</p>

<p>factorial *= j;</p>

<p>S += factorial;</p>

<p>printf(&ldquo;%d\n&rdquo;, S % 1000000); return 0;</p>

<p>}</p>

<p>注意累乘器factorial （英文“阶乘”的意思）定义在循环里面。换句话说，每执行一次循 环体，都要重新声明一次factorial，并初始化为1 （想一想，为什么不是0 ）。因为只要末6 位，所以输出时对106取模。</p>

<p>提示2-15：在循环体开始处定义的变量，每次执行循环体时会重新声明并初始化。</p>

<p>有了刚才的经验，下面来测试一下这个程序：《=100时，输出-961703。直觉告诉我 们：乘法又溢出了。这个直觉很容易通过“输出中间变量”法得到验证，但若要解决这个问 题，还需要一点数学知识。</p>

<p>提示2-16 :要计算只包含加法、减法和乘法的整数表达式除以正整数n的余数，可以在 每步计算之后对n取余，结果不变。</p>

<p>在修正这个错误之前，还可以进行更多测试：当《=106时输出什么？更会溢出不是吗？ 但是重点不在这里。事实上，它的速度太慢！下面把程序改成“每步取模”的形式，然后加一 个“计时器”，看看究竟有多慢。</p>

<p>程序2-8 阶乘之和（ 2）</p>

<p>#include<stdio.h></p>

<p>#include<time.h></p>

<p>int main()</p>

<p>{</p>

<p>const int MOD = 1000000;</p>

<p>int n, S = 0;</p>

<p>scanf(&ldquo;%d&rdquo;, &amp;n);</p>

<p>for(int i = 1; i &lt;= n; i++)</p>

<p>{</p>

<p>int factorial = 1;</p>

<p>for(int j = 1; j &lt;= i; j++)</p>

<p>factorial</p>

<p>(factorial * j % MOD);</p>

<p>printf(&ldquo;%d\n&rdquo;, S);</p>

<p>printf(&ldquo;Time used = %.2f\n&rdquo;, (double)clock() / CLOCKS_PER_SEC); return 0;</p>

<p>}</p>

<p>上面的程序再次使用到了常量定义，好处是可以在程序中使用代号MOD而不是常数 1000000，改善了程序的可读性，也方便修改(假设题目改成求末5位正整数之积)。</p>

<p>这个程序真正的特别之处在于计时函数clock ()的使用。该函数返回程序目前为止运行 的时间。这样，在程序结束之前调用此函数，便可获得整个程序的运行时间。这个时间除以 常数CLOCKS_PER_SEC之后得到的值以“秒”为单位。</p>

<p>提示2-17:可以使用time.h和clock ()函数获得程序运行时间。常数 CLOCKS_PER_SEC和操作系统相关，请不要直接使用clock ()的返回值，而应总是除以 CLOCKS_PER_SEC。</p>

<p>输入“20”，按Enter键后，系统瞬间输出了答案820313。但是，输出的Time used居然不是 0！其原因在于，键盘输入的时间也被计算在内——这的确是程序启动之后才进行的。为了 避免输入数据的时间影响测试结果，可使用一种称为“管道”的小技巧：在Windows命令行下 执行echo 20|abc ,操作系统会自动把20输入，其中abc是程序名<a href="#bookmark14">幽</a>。如果不知道如何操作命令 行，请参考附录A。笔者建议每个读者都熟悉命令行操作，包括Windows和Linux。</p>

<p>在尝试了多个n之后，得到了一张表，如表2-1所示。</p>

<p>表2-1 程序2-8的输出结果与运行时间表</p>

<table>
<thead>
<tr>
<th>n</th>
<th>20</th>
<th>40</th>
<th>80</th>
<th>160</th>
<th>1600</th>
<th>6400</th>
<th>12800</th>
<th>25600</th>
<th>51200</th>
</tr>
</thead>

<tbody>
<tr>
<td>答案</td>
<td>820313</td>
<td>940313</td>
<td>940313</td>
<td>940313</td>
<td>940313</td>
<td>940313</td>
<td>940313</td>
<td>940313</td>
<td>940313</td>
</tr>

<tr>
<td>时间</td>
<td>&lt;0.01</td>
<td>&lt;0.01</td>
<td>&lt;0.01</td>
<td>&lt;0.01</td>
<td>0.05</td>
<td>0.70</td>
<td>2.70</td>
<td>11.08</td>
<td>43.72</td>
</tr>
</tbody>
</table>

<p>由表2-1可知：第一，程序的运行时间大致和n的平方成正比(因为n每扩大1倍，运行时 间近似扩大4倍)。甚至可以估计n=106时，程序大致需要近5个小时才能执行完。</p>

<p>提示2-18 :很多程序的运行时间与规模n存在着近似的简单关系。可以通过计时函数来 发现或验证这—关系。</p>

<p>第二，从40开始，答案始终不变。这是真理还是巧合？聪明的读者也许已经知道了： 25！末尾有6个0，所以从第5项开始，后面的所有项都不会影响和的末6位数字——只需要在 程序的最前面加一条语句“if ( n&gt; 25 ) n = 25 ; ”，效率和溢出都将不存在问题。</p>

<p>本节展示了循环结构程序设计中最常见的两个问题：算术运算溢出和程序效率低下。这</p>

<p>两个问题都不是那么容易解决的，将在后面章节中继续讨论。另外，本节中介绍的两个工具</p>

<p>——输出中间结果和计时函数，都是相当实用的。</p>

<h6 id="2-4-算法竞赛中的输入输出框架">2.4 算法竞赛中的输入输出框架</h6>

<p>例题2-5 数据统计</p>

<p>输入一些整数，求出它们的最小值、最大值和平均值（保留3位小数）。输入保证这些</p>

<p>数都是不超过1000的整数。</p>

<p>样例输入：</p>

<p>2 8 3 5 1 7 3 6</p>

<p>样例输出：</p>

<p>1 8 4.375</p>

<p>【分析】</p>

<p>如果是先输入整数n ,然后输入n个整数，相信读者能够写出程序。关键在于：整数的个 数是不确定的。下面直接给出程序：</p>

<p>程序2-9数据统计（有bug ）</p>

<p>#include<stdio.h> int main()</p>

<p>{</p>

<table>
<thead>
<tr>
<th>int x,</th>
<th>n = 0,</th>
<th>min,</th>
<th>max, s =</th>
</tr>
</thead>

<tbody>
<tr>
<td>while(scanf(&rdquo;</td>
<td>%d&rdquo;,</td>
<td>&amp;x) == 1)</td>
<td></td>
</tr>

<tr>
<td>{</td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td>s +=</td>
<td>x;</td>
<td></td>
<td></td>
</tr>

<tr>
<td>if(x</td>
<td>&lt; min)</td>
<td>min</td>
<td>= x;</td>
</tr>

<tr>
<td>if(x</td>
<td>&gt; max)</td>
<td>max</td>
<td>= x;</td>
</tr>

<tr>
<td>n++;</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

<p>}</p>

<p>printf(&ldquo;%d %d %.3f\n&rdquo;, min, max, (double)s/n);</p>

<p>return 0;</p>

<p>看看这个程序多了些什么内容？ scanf函数有返回值？对，它返回的是成功输入的变量个 数，当输入结束时，scanf函数无法再次读取x，将返回0。</p>

<p>下面进行测试。输入“2 8 3 5 1 7 3 6”，按Enter键，但未显示结果。难道程序速度太慢？ 其实程序正在等待输入。还记得scanf的输入格式吗？空格、TAB和回车符都是无关紧要的， 所以按Enter键并不意味着输入的结束。那如何才能告诉程序输入结束了呢？</p>

<p>提示2-19 :在Windows下，输入完毕后先按Enter键，再按Ctrl+ Z键，最后再按Enter 键，即可结束输入。在Linux下，输入完毕后按Ctrl + D键即可结束输入。</p>

<p>输入终于结束了，但输出却是“1 2293624 4.375”。这个2293624是从何而来？当用-O2编 译（读者可阅读附录A了解-O2 ）后答案变成了 1 10 4.375，和刚才不一样！换句话说，这个 程序的运行结果是不确定的。在读者自己的机器上，答案甚至可能和上述两个都不同。</p>

<p>根据“输出中间结果”的方法，读者不难验证下面的结论：变量max在一开始就等于 2293624（或者10），自然无法更新为比它小的8。</p>

<p>提示2-20：变量在未赋值之前的值是不确定的。特别地，它不一定等于0。</p>

<p>解决的方法就很清楚了：在使用之前赋初值。由于min保存的是最小值，其初值应该是 一个很大的数；反过来，max的初值应该是一个很小的数。一种方法是定义一个很大的常 数，如INF= 1000000000，然后让max=-INF，而min = INF，另一种方法是先读取第一个整数 x，然后令max = min = x。这样的好处是避免了人为的“假想无穷大”值，程序更加优美；而 INF这样的常数有时还会引起其他问题，如“无限大不够大”，或者“运算溢出”，后面还会继 续讨论这个问题。</p>

<p>上面的程序并不是很方便：每次测试都要手动输入许多数。尽管可以用前面讲的管道的</p>

<p>方法，但数据只是保存在命令行中，仍然不够方便。</p>

<p>一个好的方法是用文件——把输入数据保存在文件中，输出数据也保存在文件中。这 样，只要事先把输入数据保存在文件中，就不必每次重新输入了；数据输出在文件中也避免 了“输出太多，一卷屏前面的就看不见了”这样的尴尬，运行结束后，慢慢浏览输出文件即 可。如果有标准答案文件，还可以进行文件比较<a href="#bookmark18">◎</a>，而无须编程人员逐个检查输出是否正 确。事实上，几乎所有算法竞赛的输入数据和标准答案都是保存在文件中的。</p>

<p>使用文件最简单的方法是使用输入输出重定向，只需在main函数的入口处加入以下两条 语句：</p>

<p>freopen（&rdquo;input.txt&rdquo;, &ldquo;r&rdquo;, stdin）;</p>

<p>freopen（&rdquo;output.txt&rdquo;, &ldquo;w&rdquo;, stdout）;</p>

<p>上述语句将使得scanf从文件i叩ut.txt读入，printf写入文件output.txt。事实上，不只是scanf 和printf ,所有读键盘输入、写屏幕输出的函数都将改用文件。尽管这样做很方便，并不是所 有算法竞赛都允许用程序读写文件。甚至有的竞赛允许访问文件，但不允许用freopen这样的 重定向方式读写文件。参赛之前请仔细阅读文件读写的相关规定。</p>

<p>提示2-21 :请在比赛之前了解文件读写的相关规定：是标准输入输出（也称标准I/O , 即直接读键盘、写屏幕），还是文件输入输出？如果是文件输入输出，是否禁止用重定向方 式访问文件？</p>

<p>多年来，无数选手因文件相关问题丢掉了大量分数。一个普适的原则是：详细阅读比赛</p>

<p>规定，并严格遵守。例如，输入输出文件名和程序名往往都有着严格规定，不要弄错大小</p>

<p>写，不要拼错文件名，不要使用绝对路径或相对路径。</p>

<p>例如，如果题目规定程序名称为test ,输入文件名为test.in ,输出文件名为test.out ,就不</p>

<p>要犯以下错误。</p>

<p>错误1 :程序存为tl.c （应该改成test.c ）。</p>

<p>错误2 :从input.txt读取数据（应该从test.in读取）。</p>

<p>错误3 :从tset.in读取数据（拼写错误，应该从test.in读取）。</p>

<p>错误4 :数据写到test.ans （扩展名错误，应该是test.out ）。</p>

<p>错误5 :数据写到c ： \contest\test.out （不能加路径，哪怕是相对路径。文件名应该只有8 个字符 ： test.out）。</p>

<p>提示2-22：在算法竞赛中，选手应严格遵守比赛的文件名规定，包括程序文件名和输</p>

<p>入输出文件名。不要弄错大小写，不要拼错文件名，不要使用绝对路径或相对路径。</p>

<p>当然，这些错误都不是选手故意犯下的。前面说过，利用文件是一种很好的自我测试方</p>

<p>法，但如果比赛要求采用标准输入输出，就必须在自我测试完毕之后删除重定向语句。选手 比赛时—紧张，就容易忘记将其删除。</p>

<p>有—种方法可以在本机测试时用文件重定向，但—旦提交到比赛，就自动“删除”重定向</p>

<p>语句。代码如下：</p>

<p>程序2-10 数据统计（重定向版）</p>

<p>#define LOCAL</p>

<p>#include<stdio.h></p>

<p>#define INF 1000000000</p>

<p>int main()</p>

<p>{</p>

<p>#ifdef LOCAL</p>

<p>freopen(&ldquo;data.in&rdquo;, &ldquo;r&rdquo;, stdin); freopen(&ldquo;data.out&rdquo;, &ldquo;w&rdquo;, stdout);</p>

<p>#endif</p>

<p>int x, n = 0, min = INF, max = -INF, s = 0;</p>

<p>while(scanf(&ldquo;%d&rdquo;, &amp;x) == 1)</p>

<p>{</p>

<table>
<thead>
<tr>
<th>s += x;</th>
<th></th>
<th></th>
</tr>
</thead>

<tbody>
<tr>
<td>if(x</td>
<td>&lt;</td>
<td>min) min = x;</td>
</tr>

<tr>
<td>if(x</td>
<td>&gt;</td>
<td>max) max = x;</td>
</tr>
</tbody>
</table>

<p>/*</p>

<p>printf(&ldquo;x = %d, min = %d, max = %d\n&rdquo;, x, min, max);</p>

<p>*/</p>

<p>n++;</p>

<p>}</p>

<p>printf(&ldquo;%d %d %.3f\n&rdquo;, min, max, (double)s/n); return 0;</p>

<p>}</p>

<p>这是—份典型的比赛代码，包含了几个特殊之处：</p>

<p>□重定向的部分被写在了#ifdef^n#endif中。其含义是：只有定义了符号LOCAL ,才编译两</p>

<p>条freopen语句。</p>

<p>□输出中间结果的printf语句写在了注释中——它在最后版本的程序中不应该出现，但是又 舍不得删除它(万一发现了新的bug ,需要再次用它输出中间信息)。将其注释的好处 是：一旦需要时，把注释符去掉即可。</p>

<p>上面的代码在程序首部就定义了符号LOCAL ,因此在本机测试时使用重定向方式读写文 件。如果比赛要求读写标准输入输出，只需在提交之前删除#defineLOCAL即可。一个更好的 方法是在编译选项而不是程序里定义这个LOCAL符号(不知道如何在编译选项里定义符号的 读者请参考附录A ),这样，提交之前不需要修改程序，进一步降低了出错的可能。</p>

<p>提示2-23：在算法竞赛中，有经验的选手往往会使用条件编译指令并且将重要的测试</p>

<p>语句注释掉而非删除。</p>

<p>如果比赛要求用文件输入输出，但禁止用重定向的方式，又当如何呢？程序如下：</p>

<p>程序2-11数据统计(fopen版)</p>

<p>#include<stdio.h></p>

<p>#define INF 1000000000</p>

<p>int main()</p>

<p>{</p>

<p>FILE *fin, *fout;</p>

<p>fin = fopen(&ldquo;data.in&rdquo;, &ldquo;rb&rdquo;);</p>

<p>fout = fopen(&ldquo;data.out&rdquo;, &ldquo;wb&rdquo;);</p>

<p>int x, n = 0, min = INF, max = -INF, s = 0;</p>

<p>while(fscanf(fin, &ldquo;%d&rdquo;, &amp;x) == 1)</p>

<p>{</p>

<p>s += x;</p>

<p>if(x &lt; min) min = x; if(x &gt; max) max = x; n++;</p>

<p>}</p>

<p>fprintf(fout, &ldquo;%d %d %.3f\n&rdquo;, min, max, (double)s/n); fclose(fin);</p>

<p>fclose(fout); return 0;</p>

<p>}</p>

<p>虽然新内容不少，但也很直观：先声明变量fin和fout （暂且不用考虑FILE* ），把scanf改 成fscanf，第一个参数为fin ;把printf改成fprintf，第一个参数为fout，最后执行fclose，关闭两 个文件。</p>

<p>提示2-24 :在算法竞赛中，如果不允许使用重定向方式读写数据，应使用fopen和 fsca nf/fpri ntf进行输入输出。</p>

<p>重定向和fopen两种方法各有优劣。重定向的方法写起来简单、自然，但是不能同时读 写文件和标准输入输出；fopen的写法稍显繁琐，但是灵活性比较大（例如，可以反复打开 并读写文件）。顺便说一句，如果想把fopen版的程序改成读写标准输入输出，只需赋值“fin =stdin ; fout = stdout ; ”即可，不要调用fopen和fclose<a href="#bookmark20">⑽</a>。</p>

<p>对文件输入输出的讨论到此结束，本书剩余部分的所有题目均使用标准输入输出。</p>

<p>例题2-6数据统计II</p>

<p>输入一些整数，求出它们的最小值、最大值和平均值（保留3位小数）。输入保证这些</p>

<p>数都是不超过1000的整数。</p>

<p>输入包含多组数据，每组数据第一行是整数个数《，第二行是《个整数。《 = 0为输入结束 标记，程序应当忽略这组数据。相邻两组数据之间应输出一个空行。</p>

<p>样例输入：</p>

<p>8</p>

<p>2 8 3 5 1 7 3 6</p>

<p>4</p>

<p>-4 6 10 0</p>

<p>样例输出：</p>

<p>Case 1: 1 8 4.375</p>

<p>Case 2: -4 10 3.000</p>

<p>【分析】</p>

<p>本题和例题2-5本质相同，但是输入输出方式有了一定的变化。由于这样的格式在算法</p>

<p>竞赛中非常常见，这里直接给出代码：</p>

<p>程序2-12数据统计II (有bug )</p>

<p>#include<stdio.h></p>

<p>#define INF 1000000000 int main()</p>

<p>int x, n = 0, min = INF, max = -INF, s = 0, kase = 0;</p>

<p>while(scanf(&ldquo;%d&rdquo;, &amp;n) == 1 &amp;&amp; n)</p>

<p>{</p>

<p>(double)s/n)</p>

<p>int s = 0;</p>

<table>
<thead>
<tr>
<th>for(int</th>
<th>i = 0</th>
<th>; i &lt; n;</th>
</tr>
</thead>

<tbody>
<tr>
<td>scanf(</td>
<td>&rdquo;%d&rdquo;,</td>
<td>&amp;x);</td>
</tr>

<tr>
<td>s += x</td>
<td>;</td>
<td></td>
</tr>

<tr>
<td>if(x &lt;</td>
<td>min)</td>
<td>min = x;</td>
</tr>

<tr>
<td>if(x &gt;</td>
<td>max)</td>
<td>max = x;</td>
</tr>

<tr>
<td>}</td>
<td></td>
<td></td>
</tr>

<tr>
<td>if(kase)</td>
<td>printf(&rdquo;\n&rdquo;);</td>
<td></td>
</tr>

<tr>
<td>printf(&rdquo;</td>
<td>Case</td>
<td>%d: %d %d</td>
</tr>
</tbody>
</table>

<p>return 0;</p>

<p>聪明的读者，你能看懂其中的逻辑吗？上面的程序有几个要点。首先是输入循环。题目 说了n=0为输入标记，为什么还要判断scanf的返回值呢？答案是为了鲁棒性( robustness)。</p>

<p>算法竞赛中题目的输入输出是人设计的，难免会出错。有时会出现题目指明以《 = 0为结束标 记而真实数据忘记以《 = 0结尾的情形。虽然比赛中途往往会修改这一错误，但在ACM/ICPC 等时间紧迫的比赛中，如果程序能自动处理好有瑕疵的数据，会节约大量不必要的时间浪 费。</p>

<p>提示2-25：在算法竞赛中，偶尔会出现输入输出错误的情况。如果程序鲁棒性强，有</p>

<p>时能在数据有瑕疵的情况下仍然给出正确的结果。程序的鲁棒性在工程中也非常重要。</p>

<p>下一个要点是kase变量的使用。不难看出它是“当前数据编号”计数器。当输出第2组或以 后的结果时，会在前面加一个空行，符合题目“相邻两组数据的输出以空行隔开”的规定。注 意，最后一组数据的输出会以回车符结束，但之后不会有空行。不同的题目会有不同的规 定，请读者仔细阅读题目。</p>

<p>像本题这样“多组数据”的题目数不胜数。例如，ACM/ICPC总决赛就只有一个输入文 件，包含多组数据。即使是NOI/IOI这样多输入文件的比赛，有时也会出现一个文件多组数 据的情况。例如，有的题目输出只有Yes和No两种，如果一个文件里只有一组数据，又是每 个文件分别给分，一个随机输出Yes/No的程序平均情况下能得50分，而一个把Yes打成 yes , No打成no的程序却只有。分<a href="#bookmark22">迎</a>。</p>

<p>接下来是找bug时间。上面的程序对于样例输入输出可以得到正确的结果，但它真的是 正确的吗？在样例输入的最后增加第3组数据：10，会看到这样的输出：</p>

<p>Case 3：-4 10 0.000</p>

<p>相信读者已经意识到问题出在哪里了： min和maX殳有“重置”，仍然是上个数据结束后的</p>

<p>值。</p>

<p>提示2-26：在多数据的题目中，一个常见的错误是：在计算完一组数据后某些变量殳</p>

<p>有重置，影响到下组数据的求解。</p>

<p>解决方法很简单，把min和max定义在while循环中即可，这样每次执行循环体时，会新 声明和初始化min和max。细心的读者也许注意到了另外一个问题：为什么第3个数（累加 和）是对的呢？原因在于：循环体内部也定义了一个s ,把main函数里定义的s给“屏蔽”了。</p>

<p>提示2-27 ：当嵌套的两个代码块中有同名变量时，内层的变量会屏蔽外层变量，有时 会引起十分隐蔽的错误。</p>

<p>这是初学者在求解“多数据输入”的题目时常范的错误，请读者留意。这种问题通常很隐 蔽，但也不是发现不了：对于这个例子来说，编译时加一个-Wall就会看到一条警告： warning : unused variable &rsquo;s&rsquo; [-Wunused-variable]（警告：没有用过的变量&rsquo;s&rsquo;）。</p>

<p>提示2-28 :用编译选项-Wall编译程序时，会给出很多（但不是所有）警告信息，以帮 助程序员查错。但这并不能解决所有的问题：有些“错误”程序是合法的，只是这些动作不是 所期望的。</p>

<h6 id="2-5-注解与习题">2.5 注解与习题</h6>

<p>不知不觉，本章已经开始出现一些挑战了。尽管难度不算太高，本章的例题和习题已经</p>

<p>出现了真正的竞赛题目——仅使用简单变量和基本的顺序、分支与循环结构就可以解决很多</p>

<p>问题。在继续前进之前，请认真总结，并且完成习题。</p>

<p>2.5.1 习题</p>

<p>习题2-1 水仙花数( daffodil)</p>

<p>输出100〜999中的所有水仙花数。若3位数5(2满足45C = 4 + 53 + C3 ,则称其为水仙花 数。例如153 = 13 + 53 + 33,所以153是水仙花数。</p>

<p>习题2-2 韩信点兵( hanxin)</p>

<p>相传韩信才智过人，从不直接清点自己军队的人数，只要让士兵先后以三人一排、五人</p>

<p>一排、七人一排地变换队形，而他每次只掠一眼队伍的排尾就知道总人数了。输入包含多组</p>

<p>数据，每组数据包含3个非负整数, b , c ,表示每种队形排尾的人数(a&lt;3 , b&lt;5 , c&lt; 7)，输出总人数的最小值(或报告无解)。已知总人数不小于10，不超过100。输入到文件</p>

<p>结束为止。</p>

<p>样例输入：</p>

<p>2 1 6</p>

<p>2 1 3</p>

<p>样例输出：</p>

<p>Case 1: 41</p>

<p>Case 2: No answer</p>

<p>习题2-3 倒三角形( triangle )</p>

<p>输入正整数《S20 ,输出一个《层的倒三角形。例如，《 = 5时输出如下：</p>

<p>#######</p>

<p>#####</p>

<p>###</p>

<p>#</p>

<p>习题2-4子序列的和(subsequence )</p>

<p>输入两个正整数《 &lt; rn &lt; 106，输出.    ，保留5位小数。输入包含多组数据，</p>

<p>«-    (« + l)2 m2</p>

<p>结束标记为《 = rn = 0。提示：本题有陷阱。</p>

<p>样例输入：</p>

<p>2 4</p>

<p>65536 655360</p>

<p>0 0</p>

<p>样例输出：</p>

<p>Case 1: 0.42361</p>

<p>Case 2: 0.00001</p>

<p>习题2-5分数化小数(decimal)</p>

<p>输入正整数a，b，c，输出a/b的小数形式，精确到小数点后c位。a，b&lt;106，c$100。输 入包含多组数据，结束标记为a = b = c = 0。</p>

<p>样例输入：</p>

<p>1 6 4</p>

<p>0 0 0</p>

<p>样例输出：</p>

<p>Case 1: 0.1667</p>

<p>习题2-6 排列(permutation )</p>

<p>用1 , 2 , 3，…，9组成3个三位数abc , def和ghi ,每个数字恰好使用一次，要 求abc : def: ghi = 1 : 2 : 3。按照“abc def ghi”的格式输出所有解，每行一个解。提示：不必</p>

<p>太动脑筋。</p>

<p>下面是一些思考题。</p>

<p>题目1。假设需要输出2 ，4 ，6 ，8 ，… ，2n ，每个一行，能不能通过对程序2-1进行小小 的改动来实现呢？为了方便，现把程序复制如下:</p>

<p>1 #include<stdio.h></p>

<p>2 int main()</p>

<p>3 {</p>

<p>4 int n;</p>

<p>5 scanf(&ldquo;%d&rdquo;, &amp;n);</p>

<p>6 for(int i = 1; i &lt;= n; i++)</p>

<p>7 printf(&ldquo;%d\n&rdquo;, i);</p>

<p>8 return 0;</p>

<p>9 }</p>

<p>任务1:修改第7行，不修改第6行。</p>

<p>任务2:修改第6行，不修改第7行。</p>

<p>题目2。下面的程序运行结果是什么？ “！= ”运算符表示“不相等”。提示：请上机实</p>

<p>验，不要凭主观感觉回答。</p>

<p>#include<stdio.h></p>

<p>int main()</p>

<p>{</p>

<p>double i;</p>

<p>for(i = 0; i != 10; i += 0.1)</p>

<p>printf(&ldquo;%.1f\n&rdquo;, i);</p>

<p>2.5.2 小结</p>

<p>循环的出现让程序逻辑复杂了许多。在很多情况下，仔细研究程序的执行流程能够很好 地帮助理解算法，特别是“当前行”和变量的改变。有些变量是特别值得关注的，如计数器、 累加器，以及“当前最小/最大值”这样的中间变量。很多时候，用printf输出一些关键的中间 变量能有效地帮助读者了解程序执行过程、发现错误，就像本章中多次使用的一样。</p>

<p>别人的算法理解得再好，遇到问题时还是需要自己分析和设计。本章介绍了“伪代码”这</p>

<p>一工具，并建议“不拘一格”地使用。伪代码是为了让思路更清晰，突出主要矛盾，而不是</p>

<p>写“八股文”。</p>

<p>在程序慢慢复杂起来时，测试就显得相当重要了。本章后面的几个例题几乎个个都有陷 阱：运算结果溢出、运算时间过长等。程序的运行时间并不是无法估计的，有时能用实验的 方法猜测时间和规模之间的近似关系(其理论基础将在后面介绍)，而海量数据的输入输出 问题也可以通过文件得到缓解。尽管不同竞赛在读写方式上的规定不同，熟练掌握了重定 向、fopen和条件编译后，各种情况都能轻松应付。</p>

<p>再次强调：编程不是看书看会的，也不是听课听会的，而是练会的。本章后面的上机编</p>

<p>程习题中包含了很多正文中殳有提到的内容，对能力的提高很有好处。如有可能，请在上机</p>

<p>实践时运用输出中间结果、设计伪代码、计时测试等方法。</p>

<p><a href="#bookmark8">(1)</a>    Visual C+ + 6.0等早期编译器允许在循环体之后访问i ,但这样，如果再写一个for (int i = 0;i&lt;n;i++) ”则会出 现i重定义的错误。</p>

<p><a href="#bookmark10">(2)</a>    这样做，小数部分为0.5的数也会受到浮点误差的影响，因此任何一道严密的算法竞赛题目中都需要想办法解决这 个问题。后面还会讨论这个问题。</p>

<p><a href="#bookmark12">(3)</a>    逻辑与“&amp;&amp;”似乎也没有出现过，但假设读者在学习后已经翻阅了相关资料，或者教师已经给学生补充了这个运算 符。如果确实没有学过，现在学也来得及。</p>

<p><a href="#bookmark14">⑷</a> <a href="http://en.wikipedia">http://en.wikipedia</a>. org/wiki/3n + 1。</p>

<p><a href="#bookmark16">(5)</a>    在笔者中学时期，int—般是16位的，即-32768 ~ 32767。</p>

<p><a href="#bookmark18">(6)</a>    uint32_t表示无符号32位整数，范围是0 ~ 4294967296。</p>

<p><a href="#bookmark20">(7)</a>    这并不是MinGW引起的，而是因为Windows的CRT ( C Runtime )。</p>

<p><a href="#bookmark22">(8)</a> Linux下需要输入“echo|+/abc”，因为在默认情况下，当前目录不在可执行文件的搜索路径中。</p>

<p><a href="#bookmark24">⑼</a>在Windows中可以使用fc命令，而在Linux中可以使用diff命令。</p>

<p><a href="#bookmark26">(10)</a>    有读者可能试过用fopen ( &ldquo;con&rdquo;，&rdquo;r&rdquo;)的方法打开标准输入输出，但这个方法并不是可移植的一一它在Linux下是无 效的。</p>

<p><a href="#bookmark28">(11)</a>    也不总是如此。有些比赛会善意地把这种只是格式不对的结果判成“正确”。可惜这样的比赛非常少。</p>

    </div>

    
    

    
    

    <footer class="post-footer">
      

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/04-%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8/01-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%85%A5%E9%97%A8/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">01 程序设计入门</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/04-%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer%E9%87%8C%E9%9D%A2%E7%9A%84/%E7%AE%97%E6%B3%95%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/">
            <span class="next-text nav-default">算法：从尾到头打印链表</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="iteratelyd@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="http://github.com/iterateself" class="iconfont icon-github" title="github"></a>
      <a href="https://www.zhihu.com/people/thebegin/activities" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="https://www.douban.com/people/68028070/" class="iconfont icon-douban" title="douban"></a>
  <a href="http://iterate.site/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> site pv: <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
    <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> site uv: <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2018
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">iterateself</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>


<script type="text/javascript" src="/dist/even.min.js?v=3.2.0"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>








</body>
</html>
