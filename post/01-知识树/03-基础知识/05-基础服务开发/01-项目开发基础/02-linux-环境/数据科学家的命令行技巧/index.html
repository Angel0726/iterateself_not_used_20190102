<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>数据科学家的命令行技巧 - 迭代自己</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="iterateself" />
  <meta name="description" content="数据科学家的命令行技巧 对于许多数据科学家来说，数据操作起始于Pandas或Tidyverse。从理论上看，这个概念没有错。毕竟，这是为什么这" />

  <meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.47.1" />


<link rel="canonical" href="http://iterate.site/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/05-%E5%9F%BA%E7%A1%80%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/01-%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/02-linux-%E7%8E%AF%E5%A2%83/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%AE%B6%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%8A%80%E5%B7%A7/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">




<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<link href="/dist/even.min.css?v=3.2.0" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">




<meta property="og:title" content="数据科学家的命令行技巧" />
<meta property="og:description" content="数据科学家的命令行技巧 对于许多数据科学家来说，数据操作起始于Pandas或Tidyverse。从理论上看，这个概念没有错。毕竟，这是为什么这" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://iterate.site/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/05-%E5%9F%BA%E7%A1%80%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/01-%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/02-linux-%E7%8E%AF%E5%A2%83/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%AE%B6%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%8A%80%E5%B7%A7/" /><meta property="article:published_time" content="2018-08-03T14:26:28&#43;00:00"/>
<meta property="article:modified_time" content="2018-08-03T14:26:28&#43;00:00"/>
<meta itemprop="name" content="数据科学家的命令行技巧">
<meta itemprop="description" content="数据科学家的命令行技巧 对于许多数据科学家来说，数据操作起始于Pandas或Tidyverse。从理论上看，这个概念没有错。毕竟，这是为什么这">


<meta itemprop="datePublished" content="2018-08-03T14:26:28&#43;00:00" />
<meta itemprop="dateModified" content="2018-08-03T14:26:28&#43;00:00" />
<meta itemprop="wordCount" content="4036">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="数据科学家的命令行技巧"/>
<meta name="twitter:description" content="数据科学家的命令行技巧 对于许多数据科学家来说，数据操作起始于Pandas或Tidyverse。从理论上看，这个概念没有错。毕竟，这是为什么这"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">迭代自己</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">主页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a><a href="/catalog/">
        <li class="mobile-menu-item">目录</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">迭代自己</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">主页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/catalog/">目录</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">数据科学家的命令行技巧</h1>

      <div class="post-meta">
        <span class="post-time"> 2018-08-03 </span>
        
        <span class="more-meta"> 4036 words </span>
        <span class="more-meta"> 9 mins read </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> times read </span>
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  
  <div class="post-toc-content">
    <nav id="TableOfContents">
<ul>
<li><a href="#数据科学家的命令行技巧">数据科学家的命令行技巧</a>
<ul>
<li><a href="#我们会谈及的内容">我们会谈及的内容</a></li>
<li><a href="#iconv">ICONV</a></li>
<li><a href="#head">HEAD</a>
<ul>
<li><a href="#tr命令">TR命令</a></li>
</ul></li>
<li><a href="#wc">WC</a></li>
<li><a href="#split命令">SPLIT命令</a></li>
<li><a href="#sort-uniq">SORT &amp; UNIQ</a></li>
<li><a href="#cut命令">CUT命令</a></li>
<li><a href="#paste">PASTE</a></li>
<li><a href="#join">JOIN</a>
<ul>
<li><a href="#grep">GREP</a></li>
<li><a href="#大杀器">大杀器</a></li>
<li><a href="#sed">SED</a></li>
<li><a href="#awk">AWK</a></li>
<li><a href="#结束前">结束前</a></li>
</ul></li>
<li><a href="#相关资料">相关资料</a></li>
</ul></li>
</ul>
</nav>
  </div>
</div>

    
    

    
    <div class="post-content">
      

<h1 id="数据科学家的命令行技巧">数据科学家的命令行技巧</h1>

<p>对于许多数据科学家来说，数据操作起始于Pandas或Tidyverse。从理论上看，这个概念没有错。毕竟，这是为什么这些工具首先存在的原因。然而，对于分隔符转换等简单任务来说，这些选项通常可能是过于重量级了。
有意掌握命令行应该在每个开发人员的技能链上，特别是数据科学家。学习shell中的来龙去脉无可否认地会让你更高效。除此之外，命令行还在计算方面有一次伟大的历史记录。例如，awk - 一种数据驱动的脚本语言。Awk首次出现于1977年，它是在传奇的<a href="https://en.wikipedia.org/wiki/The_C_Programming_Language">K&amp;R</a>一书中的K，<a href="https://en.wikipedia.org/wiki/Brian_Kernighan">Brian Kernighan</a>的帮助下出现的。在今天，大约50年之后，awk仍然与每年出现的<a href="https://www.amazon.com/Learning-AWK-Programming-cutting-edge-text-processing-ebook/dp/B07BT98HDS">新书</a>保持相关联！ 因此，可以肯定的是，对命令行技术的投入不会很快贬值的。</p>

<p>于 3个月前0人顶</p>

<p>顶 翻译得不错哦！</p>

<h2 id="我们会谈及的内容">我们会谈及的内容</h2>

<ul>
<li>ICONV</li>
<li>HEAD</li>
<li>TR</li>
<li>WC</li>
<li>SPLIT</li>
<li>SORT &amp; UNIQ</li>
<li>CUT</li>
<li>PASTE</li>
<li>JOIN</li>
<li>GREP</li>
<li>SED</li>
<li>AWK</li>
</ul>

<h2 id="iconv">ICONV</h2>

<p>文件编码总是棘手的问题。目前大部分文件都是采用的 UTF-8 编码。要想了解 UTF-8 的魔力，可以看看这个<a href="https://www.youtube.com/watch?v=MijmeoH9LT4">优秀的视频</a>。尽管如此，有时候我们还是会收到非 UTF-8 编码的文件。这种情况下就需要尝试转码。iconv 就是这种状况下的救世主。iconv 是一个简单的程序，可以输入某种编码的文本，然后以另一种编码输出。</p>

<pre><code># Converting -f (from) latin1 (ISO-8859-1)
# -t (to) standard UTF_8

iconv -f ISO-8859-1 -t UTF-8 &lt; input.txt &gt; output.txt
</code></pre>

<ul>
<li><p>常用选项：</p></li>

<li><ul>
<li>iconv -l 列出所有支持的编码</li>
</ul>

<ul>
<li>iconv -c 不作提示就丢弃无法转换的字符</li>
</ul></li>
</ul>

<p>顶 翻译得不错哦！</p>

<h2 id="head">HEAD</h2>

<p>如果你是重度Pandas的用户，那么你会对head很熟悉。通常在处理新数据时，我们想要做的第一件事就是了解究竟存在那些东西。这会引起Panda启动，读取数据，然后调用df.head() - 很费劲，至少可以说。head，不需要任何标志，将输出文件的前10行。head真正的能力在于彻查清除操作。 例如，如果我们想将文件的分隔符从逗号改变为pipe通配符。一个快速测试将是：head mydata.csv | sed &rsquo;s/,/|/g&rsquo;</p>

<pre><code># Prints out first 10 lines

head filename.csv

# Print first 3 lines

head -n 3 filename.csv
</code></pre>

<ul>
<li><p>有用的选项:</p></li>

<li><ul>
<li>head -n 输出指定行</li>
</ul>

<ul>
<li>head -c 输出指定的字节</li>
</ul></li>
</ul>

<h3 id="tr命令">TR命令</h3>

<p>Tr类似于翻译，它是基于文件清理的一个强大使用的工具。一个理想的用法是替换文件中的分隔符。</p>

<pre><code>#将文件中的制表符分割转换成逗号
cat tab_delimited.txt | tr &quot;\t&quot; &quot;,&quot; comma_delimited.csv
</code></pre>

<p>Tr的另一个特性是在你的处理中设置上所有的[:class:]变量。包括：</p>

<pre><code>[:alnum:] 所有字母和数字
[:alpha:] 所有字母
[:blank:] 所有水平空白
[:cntrl:] 所有控制字符
[:digit:] 所有数字
[:graph:] 所有可打印的字符，不包括空格
[:lower:] 全部小写字母
[:print:] 所有可打印的字符，包括空格
[:punct:] 所有标点符号
[:space:] 所有的水平或垂直空格
[:upper:] 全部大写字母
[:xdigit:] 所有十六进制数字
</code></pre>

<p>可以将这些多样化的变量链接在一起，组成一个强大的程序。下面是一个基于字数统计的程序，用来检查你的README文件是否使用过度。</p>

<pre><code>cat README.md | tr &quot;[:punct:][:space:]&quot; &quot;\n&quot; | tr &quot;[:upper:]&quot; &quot;[:lower:]&quot; | grep . | sort | uniq -c | sort -nr
</code></pre>

<p>另外一个例子用于正则表达式</p>

<pre><code># 将所有的大写字母转换成小写
cat filename.csv | tr '[A-Z]' '[a-z]'
</code></pre>

<ul>
<li><p>有用的选项：</p></li>

<li><ul>
<li>tr -d删除字符</li>
</ul>

<ul>
<li>tr -s压缩字符</li>
<li>\b退格</li>
<li>\f换页</li>
<li>\v垂直选项卡</li>
<li>\NNN八进制值为NNN的字符</li>
</ul></li>
</ul>

<h2 id="wc">WC</h2>

<p>字数统计。它的价值主要体现在使用 -l 参数可以进行行数统计。</p>

<pre><code># Will return number of lines in CSV

wc -l gigantic_comma.csv
</code></pre>

<p>个用这个工具来验证各个命令的输出实在方便。因此，如果我们要在文件中转换分隔符，然后运行 wc -l，验证总行数是相同的。如果不同，我们就知道一定是哪里出错了。</p>

<ul>
<li><p>常用选项：</p></li>

<li><ul>
<li>wc -c 打印字节数</li>
</ul>

<ul>
<li>wc -m 打印字符数</li>
<li>wc -L 打印最长一行的长度</li>
<li>wc -w 打印字数</li>
</ul></li>
</ul>

<h2 id="split命令">SPLIT命令</h2>

<p>文件大小可以有显著变化。根据工作的不同，拆分文件是有益的，就像split。基本用法如下：</p>

<pre><code>#我们拆分这个CSV文件，每500行分割为一个新的文件new_filename

split -l 500 filename.csv new_filename_

# filename.csv
# ls output
# new_filename_aaa
# new_filename_aab
# new_filename_aac
</code></pre>

<p>两个地方很奇怪：一个是命名方式，一个是缺少扩展名。后缀约定可以通过-d标识来数字化。添加文件扩展名，你需要执行下面这个find命令。他会给当前文件夹下的所有文件追加.csv后缀，所以需要小心使用。</p>

<pre><code>find . -type f -exec mv '{}' '{}'.csv \;

# ls output
# filename.csv.csv
# new_filename_aaa.csv
# new_filename_aab.csv
# new_filename_aac.csv
</code></pre>

<ul>
<li><p>有效的选项：</p></li>

<li><ul>
<li>split -b按特定字节大小拆分</li>
</ul>

<ul>
<li>split -a生成长度为N的后缀</li>
<li>split -x使用十六进制后缀分割</li>
</ul></li>
</ul>

<h2 id="sort-uniq">SORT &amp; UNIQ</h2>

<p>前面的命令是显而易见的：他们按照自己说的做。这两者提供了最重要的一击（即去重单词计数）。这是由于有uniq，它只处理重复的相邻行。因此在管道输出之前进行排序。一个有趣的事情是，sort -u将获得与sort file.txt | uniq相同的结果。</p>

<p>Sort确实对数据科学家来说是一种很有用的小技巧：能够根据特定的列对整个CSV进行排序。</p>

<pre><code># Sorting a CSV file by the second column alphabetically

sort -t&quot;,&quot; -k2,2 filename.csv

# Numerically

sort -t&quot;,&quot; -k2n,2 filename.csv

# Reverse order

sort -t&quot;,&quot; -k2nr,2 filename.csv
</code></pre>

<p>这里的-t选项是指定逗号作为分隔符。通常假设是空格或制表符。此外，-k标志是用来指定我们的键的。它的语法是-km,n，m是起始字段，n是最后一个字段。</p>

<ul>
<li><p>有用的选项:</p></li>

<li><ul>
<li>sort -f 忽略大小写</li>
</ul>

<ul>
<li>sort -r 逆序</li>
<li>sort -R 乱序</li>
<li>uniq -c 计算出现次数</li>
<li>uniq -d 只打印重复行</li>
</ul></li>
</ul>

<h2 id="cut命令">CUT命令</h2>

<p>cut用于删除列。举个栗子，如果我们只想要第一列和第三列。</p>

<pre><code>cut -d, -f 1,3 filename.csv
</code></pre>

<p>选择除了第一列以外的所有列</p>

<pre><code>cut -d, -f 2- filename.csv
</code></pre>

<p>与其他的命令组合使用，cut命令作为过滤器</p>

<pre><code>＃打印存在“some_string_value”的第1列和第3列的前10行

head filename.csv | grep &quot;some_string_value&quot; | cut -d, -f 1,3
</code></pre>

<p>找出第二列中唯一值的数量。</p>

<pre><code>cat filename.csv | cut -d, -f 2 | sort | uniq | wc -l

# 计算唯一值出现的次数，限制输出前10个结果

cat filename.csv | cut -d, -f 2 | sort | uniq -c | head
</code></pre>

<h2 id="paste">PASTE</h2>

<p>paste 是个有趣的小命令。如果你想合并两个文件，而这两个文件的内容又正好是有序的，那 paste 就可以这样做。</p>

<pre><code># names.txt
adam
john
zach

# jobs.txt
lawyer
youtuber
developer
</code></pre>

<pre><code># Join the two into a CSV

paste -d ',' names.txt jobs.txt &gt; person_data.txt
</code></pre>

<pre><code># Output
adam,lawyer
john,youtuber
zach,developer
</code></pre>

<p>关于更多 SQL_-esque 变体，请看下面。</p>

<h2 id="join">JOIN</h2>

<p>Join是一种简单的、准切向的SQL。最大的区别在于Join将返回所有列，匹配可能只发生在一个字段上。默认情况下，join将尝试使用第一列作为匹配键。对于不同的结果，需要以下语法：</p>

<pre><code># Join the first file (-1) by the second column
# and the second file (-2) by the first

join -t&quot;,&quot; -1 2 -2 1 first_file.txt second_file.txt
</code></pre>

<p>标准连接是一个内部连接。然而，外部连接也可以通过-af滞后来实现。另一个值得注意的是-e标志，如果发现有字段丢失，它可以用来替换成其他值。</p>

<pre><code># Outer join, replace blanks with NULL in columns 1 and 2
# -o which fields to substitute - 0 is key, 1.1 is first column, etc...

join -t&quot;,&quot; -1 2 -a 1 -a2 -e ' NULL' -o '0,1.1,2.2' first_file.txt second_file.txt
</code></pre>

<p>虽然它不是最容易使用的命令，但是在绝望的时刻，它就是唯一可用的措施。</p>

<ul>
<li><p>常用的选项:</p></li>

<li><ul>
<li>join -a 打印未成对的行</li>
</ul>

<ul>
<li>join -e 替换缺失字段</li>
<li>join -j 等同于 -1 FIELD -2 FIELD</li>
</ul></li>
</ul>

<h3 id="grep">GREP</h3>

<p>全局搜索正则表达式并输出，或使用grep;可能是最知名的命令，并且有很好的理由。 Grep具有很强的能力，特别是在大型代码库中查找方法。在数据科学领域，它充当了其他命令的改进机制。但其标准用法也很有用。</p>

<pre><code># 递归搜索并列出当前目录下包含'word'的所有文件
grep -lr 'word' .

# 列出包含word的文件数目
grep -lr 'word' . | wc -l
</code></pre>

<p>对包含word/pattern的行数进行计数</p>

<pre><code>grep -c 'some_value' filename.csv

# 同样的功能，但是按照文件名列出当前目录下所有包含该关键词的文件

grep -c 'some_value' *
</code></pre>

<p>Grep使用or运算符- |来检索多个值.</p>

<pre><code>grep &quot;first_value\|second_value&quot; filename.csv
</code></pre>

<ul>
<li><p>有用的选项</p></li>

<li><ul>
<li>alias grep=&ldquo;grep &ndash;color=auto&rdquo; 使grep支持彩色输出</li>
</ul>

<ul>
<li>grep -E 使用扩展正则表达式</li>
<li>grep -w 仅匹配完整单词</li>
<li>grep -l 打印匹配文件的名称</li>
<li>grep -v 倒序匹配</li>
</ul></li>
</ul>

<p><a href="javascript:show_other(63838,63874);">其它翻译版本(1)</a></p>

<h3 id="大杀器">大杀器</h3>

<p>Sed和Awk是本文两个最有用的命令。为了简洁，我不会讨论那些令人费解的细节。相反，我会讨论各种各样的命令来证明他们令人印象深刻的实力。如果你想了解的更多，<a href="https://www.amazon.com/sed-awk-Dale-Dougherty/dp/1565922255/ref=sr_1_1?ie=UTF8&amp;qid=1524381457&amp;sr=8-1&amp;keywords=sed+and+awk">这本书</a>就可以。</p>

<h3 id="sed">SED</h3>

<p>在内核中sed是一个流编辑器。它擅长替换，但是也可以用来重构。
最基本的sed命令包含了s/old/new/g。也就是全局搜索旧值，替换新值。没有/g 我们的命令可能在第一次出现旧值就会终止。
为了尽快了解它的能力，我们来看一个例子。在这个情况你会拿到下面的文件：</p>

<pre><code>balance,name
$1,000,john
$2,000,jack
</code></pre>

<p>我们要做的第一件事就是移除美元符。-i 标识表示就地修改。&rdquo;就是代表一个零长度文件扩展，因此重写我们的初始文件。理想情况下，你会单独测试这些并输出到一个新文件。</p>

<pre><code>sed -i '' 's/\$//g' data.txt

# balance,name
# 1,000,john
# 2,000,jack
</code></pre>

<p>下一步，我们的balance列的逗号。</p>

<pre><code>sed -i '' 's/\([0-9]\),\([0-9]\)/\1\2/g' data.txt

# balance,name
# 1000,john
# 2000,jack
</code></pre>

<p>最终，Jack有一天起来并准备辞职了。所以，再见吧，我的朋友。</p>

<pre><code>sed -i '' '/jack/d' data.txt

# balance,name
# 1000,john
</code></pre>

<p>就像你所看到的，sed功能强大，但是乐趣不止于此。</p>

<h3 id="awk">AWK</h3>

<p>最好的放最后。Awk不仅是一个简单的命令：它是一个成熟的语言。在本文中包含的每一个命令中，awk目前是最酷的。如果你发现它令你印象深刻，这有大量的资源- 看<a href="https://www.amazon.com/AWK-Programming-Language-Alfred-Aho/dp/020107981X/ref=sr_1_1?ie=UTF8&amp;qid=1524388936&amp;sr=8-1&amp;keywords=awk">这</a>，<a href="http://www.grymoire.com/Unix/Awk.html">这</a>，和<a href="https://www.tutorialspoint.com/awk/index.htm">这</a>。
awk包含的常用案例：</p>

<ul>
<li>文本处理</li>
<li>格式化文本报告</li>
<li>执行计算操作</li>
<li>执行字符串操作</li>
</ul>

<p>Awk在其最初雏形可以与grep平行。</p>

<pre><code>awk '/word/' filename.csv
</code></pre>

<p>或者多使用一点魔法，让grep和cut结合。在这，awk对所有行通过word打印了以tab分隔的第三和第四列。-F，只是将分隔符变为逗号。</p>

<pre><code>awk -F, '/word/ { print $3 &quot;\t&quot; $4 }' filename.csv
</code></pre>

<p>Awk具有大量有用的内置变量。例如， NF -字段数 - 和NR - 记录数。为了获取文件中这53个记录：</p>

<pre><code>awk -F, 'NR == 53' filename.csv
</code></pre>

<p>添加一个小窍门可以基于一个值或者多个值过滤。下面的第一个例子，会打印这些记录中第一列为string的行数和列。</p>

<pre><code>awk -F, ' $1 == &quot;string&quot; { print NR, $0 } ' filename.csv

# Filter based off of numerical value in second column

awk -F, ' $2 == 1000 { print NR, $0 } ' filename.csv
</code></pre>

<p>多数值表达式：</p>

<pre><code># Print line number and columns where column three greater
# than 2005 and column five less than one thousand

awk -F, ' $3 &gt;= 2005 &amp;&amp; $5 &lt;= 1000 { print NR, $0 } ' filename.csv
</code></pre>

<p>计算第三列之和：</p>

<pre><code>awk -F, '{ x+=$3 } END { print x }' filename.csv
</code></pre>

<p>计算那些第一列值为“something”的第三列之和。</p>

<pre><code>awk -F, '$1 == &quot;something&quot; { x+=$3 } END { print x }' filename.csv
</code></pre>

<p>获取文件的行数列数：</p>

<pre><code>awk -F, 'END { print NF, NR }' filename.csv

# Prettier version

awk -F, 'BEGIN { print &quot;COLUMNS&quot;, &quot;ROWS&quot; }; END { print NF, NR }' filename.csv
</code></pre>

<p>打印出现过两次的行：</p>

<pre><code>awk -F, '++seen[$0] == 2' filename.csv
</code></pre>

<p>移除多行：</p>

<pre><code># Consecutive lines
awk 'a !~ $0; {a=$0}']

# Nonconsecutive lines
awk '! a[$0]++' filename.csv

# More efficient
awk '!($0 in a) {a[$0];print}
</code></pre>

<p>使用内置函数gsub()替换多个值。</p>

<pre><code>awk '{gsub(/scarlet|ruby|puce/, &quot;red&quot;); print}'
</code></pre>

<p>这个awk命令合并了多个CSV文件，忽略头并在结尾追加。</p>

<pre><code>awk 'FNR==1 &amp;&amp; NR!=1{next;}{print}' *.csv &gt; final_file.csv
</code></pre>

<p>需要精简一个大文件？好的，awk可以在sed的帮助下完成这件事。具体来说，基于一个行数，这个命令将一个大文件分为多个小文件。这个一行文件也会添加一个扩展名。</p>

<pre><code>sed '1d;$d' filename.csv | awk 'NR%NUMBER_OF_LINES==1{x=&quot;filename-&quot;++i&quot;.csv&quot;;}{print &gt; x}'

# Example: splitting big_data.csv into data_(n).csv every 100,000 lines

sed '1d;$d' big_data.csv | awk 'NR%100000==1{x=&quot;data_&quot;++i&quot;.csv&quot;;}{print &gt; x}'
</code></pre>

<h3 id="结束前">结束前</h3>

<p>命令行拥有无穷的力量。本文所涵盖的命令行知识足以让你从零基础到入门。除了这些已涉及的内容外，针对日常数据操作还有需要可考虑的实用程序。<a href="http://csvkit.readthedocs.io/en/1.0.3/">Csvkit</a>, <a href="https://github.com/BurntSushi/xsv">xsv</a>和<a href="https://github.com/harelba/q">q</a>是其中三个值得关注的。如果你希望进一步深入到命令行的数据科学领域，那么请看<a href="https://www.amazon.com/Data-Science-Command-Line-Time-Tested/dp/1491947853/ref=sr_1_1?ie=UTF8&amp;qid=1524390894&amp;sr=8-1&amp;keywords=data+science+at+the+command+line">此书</a>。它也可以<a href="https://www.datascienceatthecommandline.com/">在此</a>免费获得！</p>

<h2 id="相关资料">相关资料</h2>

<ul>
<li><a href="https://www.oschina.net/translate/cli-4-ds">数据科学家的命令行技巧 </a></li>
</ul>

    </div>

    
    

    
    

    <footer class="post-footer">
      

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/05-%E5%9F%BA%E7%A1%80%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/01-%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/01-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86/git/git-server/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Git Server</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/05-%E5%9F%BA%E7%A1%80%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/01-%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/02-linux-%E7%8E%AF%E5%A2%83/linux/linux-%E5%AD%A6%E4%B9%A0%E7%AE%80%E4%BB%8B/">
            <span class="next-text nav-default">Linux 学习简介</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="iteratelyd@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="http://github.com/iterateself" class="iconfont icon-github" title="github"></a>
      <a href="https://www.zhihu.com/people/thebegin/activities" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="https://www.douban.com/people/68028070/" class="iconfont icon-douban" title="douban"></a>
  <a href="http://iterate.site/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> site pv: <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
    <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> site uv: <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2018
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">iterateself</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>


<script type="text/javascript" src="/dist/even.min.js?v=3.2.0"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>








</body>
</html>
