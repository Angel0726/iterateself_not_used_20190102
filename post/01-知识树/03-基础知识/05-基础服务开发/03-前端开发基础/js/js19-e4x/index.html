<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>JS19 E4X - 迭代自己</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="iterateself" />
  <meta name="description" content="E4X 本耷内容 □ E4X新增的类型 □使用E4X操作XML □语法的变化 2002年，由BEA Systems为行的儿家公司建议为ECMAScript增加" />

  <meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.47.1" />


<link rel="canonical" href="http://iterate.site/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/05-%E5%9F%BA%E7%A1%80%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/03-%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/js/js19-e4x/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">




<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<link href="/dist/even.min.css?v=3.2.0" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">




<meta property="og:title" content="JS19 E4X" />
<meta property="og:description" content="E4X 本耷内容 □ E4X新增的类型 □使用E4X操作XML □语法的变化 2002年，由BEA Systems为行的儿家公司建议为ECMAScript增加" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://iterate.site/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/05-%E5%9F%BA%E7%A1%80%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/03-%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/js/js19-e4x/" /><meta property="article:published_time" content="2018-06-12T20:27:15&#43;00:00"/>
<meta property="article:modified_time" content="2018-06-12T20:27:15&#43;00:00"/>
<meta itemprop="name" content="JS19 E4X">
<meta itemprop="description" content="E4X 本耷内容 □ E4X新增的类型 □使用E4X操作XML □语法的变化 2002年，由BEA Systems为行的儿家公司建议为ECMAScript增加">


<meta itemprop="datePublished" content="2018-06-12T20:27:15&#43;00:00" />
<meta itemprop="dateModified" content="2018-06-12T20:27:15&#43;00:00" />
<meta itemprop="wordCount" content="13561">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="JS19 E4X"/>
<meta name="twitter:description" content="E4X 本耷内容 □ E4X新增的类型 □使用E4X操作XML □语法的变化 2002年，由BEA Systems为行的儿家公司建议为ECMAScript增加"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">迭代自己</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">主页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a><a href="/catalog/">
        <li class="mobile-menu-item">目录</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">迭代自己</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">主页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/catalog/">目录</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">JS19 E4X</h1>

      <div class="post-meta">
        <span class="post-time"> 2018-06-12 </span>
        
        <span class="more-meta"> 13561 words </span>
        <span class="more-meta"> 28 mins read </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> times read </span>
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  
  <div class="post-toc-content">
    
  </div>
</div>

    
    

    
    <div class="post-content">
      <p>E4X</p>

<p>本耷内容</p>

<p>□ E4X新增的类型 □使用E4X操作XML □语法的变化</p>

<p>2002年，由BEA Systems为行的儿家公司建议为ECMAScript增加一项扩展，以便在这门语言 中添加原生的XML支持。2004年6月，E4X ( ECMAScript for XML)以ECMA-357标准的形</p>

<p>式发布；2005年12月乂发布了修订版。E4X本身不是，门语言.它只是ECMAScript语言的可选扩展。 就其本身而言，E4X为处理XML定义了新的语法，也定义了特定于XML的对象。</p>

<p>尽管浏览器实现这个扩展标准的步伐非常缓慢，但Firefoxl.5及更髙版本则支持几乎全部E4X标准。 本章主要讨论Firefox对E4X的文现。</p>

<p>19.1 E4X的类型</p>

<p>作为对ECMAScript的扩展，E4X定义了如下几个新的全局类型。</p>

<p>□ XML： XML结构中的任何一个独立的部分,,，</p>

<p>□ XMLList： XML对象的集合。</p>

<p>□ Namespace：命名空间前缀与命名空间URI之间的映射。</p>

<p>□ QName：由内部名称和命名空间URI组成的一个限定名。</p>

<p>E4X定义的这个4个类型可以表现XML文档中的所有部分，其内部机制是将每一种类型(特别是 XML和XMLList )都映射为多个D0M类铟。</p>

<p>19.1.1 XML 类型</p>

<p>XML类沏足E4X中定义的一个重耍的新类型，nf以用它来表现XML结构屮任何独立的部分。XML 的文例可以表现元索、特性、注释.处理指令或文本节点。xml类坦继承自Object类型，因此它也继 承了所有对象默认的所有属性和方法。创建XML对象的方式不止-种，第-种方式屋像下面这样调用其 构造函数：</p>

<p>var x = new XML();</p>

<p>这行代码会创建一个空的XML对象，我们能够向其中添加数据。另外，也可以向构造函数中传人一 个XML字符申，如下面的例子所示：</p>

<p>var x = new XML(<em><employee position=\"Software Engineer\"><name>Nicholas • + &ldquo;Zakas</name></einployee></em>};</p>

<p>传入到构造函数屮的XML字符串会被解析为分层的XML对象。除此之外，还可以向构造函数中 传人DOM文档或节点，以便它们的数据可以通过E4X来表现，语法如下：</p>

<p>var x s new XML(xmldom)；</p>

<p>虽然这种创建XML对象的方式都还不错，但最强大也吸引人的方法，则是使用XML字面fi将XML 数据直接指定给一个变量。XML字面量就足嵌人到JavaScript代码巾的XML代码。下面来看&ndash;个例子。</p>

<p>var employee = &lt; employee pos it ions11 Software Engineer* &gt;</p>

<p><narae>Nicholas C. Zakas</name></p>

<p></employee>;</p>

<p>XMLTypeExampIeOl. htm</p>

<p>在这个例子中，我们将•-个XML数据结构直接指定给了一个变a,这种简洁的语法M样可以创建 一个XML对象，外将它赋值给employee变量。</p>

<p>Firefox对E4X的实现不支持解析XML的开头代码(prolog )：,无论&lt;?xml version=&ldquo;1.0° 出现在伸递给XML构造函数的文本中，还是出现在XML字面量 中，都会导致语法错误。</p>

<p>19</p>

<p>XML类型的toXMLString()方法会返回XML对象及其子节点的XML字符串表示。另一方面，该 类型的toStringU方法则会基于不同XML对象的内容返回不同的字符串。如果内容简单(纯文本)， 则返回文本；否贝!I，toString ()方法与toXMLString()方法返回的字符串一样。来看下面的例子。</p>

<p>var data = <name>Nicholas C. Zakas</name>;</p>

<p>alert(data.toStringO)；    //&ldquo;Nicholas C. Zakas&rdquo;</p>

<p>alsrt(data.toXMLString())；    //&rdquo;<naine>Nicholas C. Zakas</name>&ldquo;</p>

<p>使用这两个方法，几乎可以满足所有序列化XML的崙求。</p>

<p>19.1.2 XMLList 类型</p>

<p>XMLList类型表现XML对象的有序集合。XMLList的DOM对等类型是NodeList,但与Node和 NodeList之间的K别相比，XML和XMLList之间的［X:别是有意设汁得比较小的。要逋式地创建一^ XMLList对象，可以像下面这样使用XMLList构造函数：</p>

<p>var list = new XMLList()；</p>

<p>与XML构造函数一样，也可以向其中传入一个待解析的XML字符串。这个字符串可以不止包含一 个文捫元素，如下面的例子所示：</p>

<p>var list = new XMLList {&rdquo;<item/><item/>”；</p>

<p>XMLListTypeExampleO 1. htm</p>

<p>结果，保存在这个list变ttip的XMLList就包含了两个XML对象，分别是两个<item/>元素。</p>

<p>还可以使用加号(+ )操作符来组合两个或多个XML对象，从而创建XMLList对象。加号操作符 在E4X中已经被弟:载，可以用于创建XMLList,如下所示：</p>

<p>var list = <item/> + <item/> ；</p>

<p>这个例子使用加号操作符组合了两个XML字面量，结果得到一个XMLList。同样的组合操作也可 以使用特殊的和&lt;/&gt;语法来完成，此时不使用加号操作符，例如：</p>

<p>var list = &lt;&gt;<item/xitem/>&lt;/&gt;；</p>

<p>尽管可以创建独立的XMLList对象,但是这类对象通常是在解析较人的XML结构的过程中捎带着 被创建出来的。来看下面的例子：</p>

<p>var employees = <employees></p>

<p><employee positions"Software Engineer"></p>

<p><name>Nicholas C. Zakas</name></p>

<p></employee></p>

<p><employee position="Salesperson,r> <name>Jim Smith</name></p>

<p></employee></p>

<p></employees>;</p>

<p>XMLListTypeExampleO2. htm</p>

<p>以上代码定义的employees变量中包含着一个XML对象，表示<employees/〉元素。由于这个元 素又包含两个<employee/>元索，因而就会创建相应的XMLList对象，•并将其保存在employees, employee中。然后，可以使用方括号语法及位置来访问毎个元素：</p>

<p>var firstEmployee = employees.employee[0]； var seconaEmployee = employees.employee[1];</p>

<p>每个XMLList对象都有length ()方法，用于返同对象中包含的元素数量。例如： alert(employees.employee.length(})； Z/2</p>

<p>注意，length ()是方法，不是属性。这一点是故意与数组和NodeList相区别的。</p>

<p>E4X有意模糊XML和XMLList类型之间的区别，这一点很值得关注。实际上，一个XML对象与一 个只包含一个XML对象的XMLList之间，并没有显而易见的区别。为了减少两者之间的区别，毎个XML 对象也同样有•十length()方法和一个由[0]引用的滅性(返回XML对象自身)。</p>

<p>XML与XMLList之间的这种兼容性可以简化E4X的使用，因为有些方法可以返回任意一个类型。</p>

<p>XMLList对象的toString()和toXMLString ()方法返回相同的字符串值，也就是将其包含的 XML对象序列化之后再拼接起来的结果。</p>

<p>19.1.3 Namespace 类型</p>

<p>E4X中使用Namespace对象來表现命名空间。通常，Namespace对象是用来映射命名空间前缀和 命名空间URI的，不过有时候并不需要前缀。要创建Namespace对象，可以像下面这样使用Namespace 构造函数：</p>

<p>var ns - new Namespace^};</p>

<p>而传人URI或前缀加URI,就可以初始化Namespace对象，如下所示:</p>

<p>var ns = new Namespace (&ldquo;http: &ldquo;<a href="http://www.wrox.com/%e2%80%a2">www.wrox.com/•</a>);</p>

<p>var wrox = new Namespace(&ldquo;wrox&rdquo;, <em><a href="http://www.wrox.com/*">http://www.wrox.com/*)</a>%ef%bc%9b)[；](<a href="http://www.wrox.com/">http://www.wrox.com/</a></em>)%ef%bc%9b)</p>

<p>可以使用prefix和uri属性来取得Namespace对象中的信息:</p>

<p>alert{ns.uri); alert{ns.prefix)； alert{wrox.uri)； alert(wrox.prefix);</p>

<p>&rdquo;&rdquo;<a href="http://www.wrox.com">http://www.wrox.com</a>&ldquo;</p>

<p>//undefined</p>

<p>//&ldquo;http：//www.wrox.com/&rdquo; //&ldquo;wrox&rdquo;</p>

<p>//没有前蜓的命名空间 //wrox命名空间</p>

<p>Namespace TypeExampleO 1. him</p>

<p>NamespaceT^peExampleO I. htm</p>

<p>在没有给Namespace对象指定前缀的情况下，prefix属性会返回undefined。要想创建默认的 命名空间，应该将前缀设置为空字符串。</p>

<p>如果XML字面量中包含命名空间，或者通过XML构造函数解析的XML字符串中包含命名空间信息, 那么就会自动创建Namespace对象。然后，就以通过前缀和namespace ()方法来取得对Namespace 对象的引用。来看下面的例子：</p>

<p>var xral = <wrox:root xmlns：wrox=*http：//www.wrox.com/*> <a href="wrox:message">wrox:message</a>Hello World!&lt;/wrox:messago</p>

<p>19</p>

<p></wrox：root>;</p>

<p>var wrox = xml.namespace(&ldquo;wrox&rdquo;)；</p>

<p>alert(wrox.uri};</p>

<p>alert(wrox.prefix);</p>

<p>NamespaceiypeExampleO2. htm</p>

<p>在这个例子中，我们以XML字面的形式创建了一个包含命名空间的XML片段。而表现wrox命 名空间的Namespace对象可以通过namespace (&ldquo;wrox&rdquo;)取得，然后就可以访问这个对象的uri和 prefix属性了。如果XML片段中有馱认的命名空间，那么向namespace()中传人空字符串，即可取 得相应的Namespace对象&lt;&gt;</p>

<p>Namespace对象的toString ()方法始终会返回命名空间URI。</p>

<p>19.1.4 QName 类型</p>

<p>QName类型表现的是XML对象的限定名，即命名空间与内部名称的组合。向QName构造函数中传 人名称或Namespace对象和名称，可以手工创建新的QNaroe对象，如下所示：</p>

<p>var wrox = new Namespace(*wrox&rdquo;, &ldquo;<a href="http://www.wrox.com/%22">http://www.wrox.com/&ldquo;)</a>%ef%bc%9b)<a href="http://www.wrox.com/%22">；</a>%ef%bc%9b)</p>

<p>var wroxMessage = new QName (wrox, &ldquo;message&rdquo;)；    &ldquo;表示&rdquo;wrox:message&rdquo;</p>

<p>QNameTypeExampleOl .htm</p>

<p>创建了 QName对象之后，可以访问它的两个属性：uri和JLocalName。其中，uri属性返回在创 建对象时指定的命名空间的URI (如果朱指定命名空间，则返回空字符串)，而localName属性返回限 定名中的内部名称，如下面的例子所示：</p>

<p>alert(wroxMessage.uri)；    &ldquo;&rdquo;<a href="http://www.wrox.com/">http://www.wrox.com/</a></p>

<p>alert (wroxMessage. localName) ;    /&ldquo;message&rdquo;</p>

<p>QNameTypeExampleO 1 .htm</p>

<p>这两个属性是只读的，如果你想修改它们的值，会导致错误发生。QName对象重写了 toStringO 方法，会以uri : : localName形式返阿一个字符串，对于前面的例+来说，就是-<a href="http://www.wrox">http://www.wrox</a>. com/::message&rdquo;o</p>

<p>在解析XML结构吋，会为表示相应元素或特性的XML对象自动创建QName对象。可以使用这个XML 对象的naneO方法取得与该XML对象关联的QName对象，如下面的例子所示：</p>

<p>var xml &lt; wrox：root xmlns：wrox=&rdquo;<a href="http://www.wrox.com/">http://www.wrox.com/</a>&rdquo;&gt;</p>

<p><wrox：message>Hello World!<a href="/wrox:roessage">/wrox:roessage</a></p>

<p></wrox：root> ；</p>

<p>var wroxRoot = xml.name{)；</p>

<p>alert(wroxRoot.uri)；    &ldquo;-<a href="http://www.wrox.com/">http://www.wrox.com/</a>&ldquo;</p>

<p>alert(wroxRoot.localName);    //&ldquo;root&rdquo;</p>

<p>QNameTypeExampleO2.htm</p>

<p>这样，即便没有指定命名空间信息，也会根据XML结构中的元素和特性创建一个QName对象。</p>

<p>使用setNameO方法并传入一个新QName对象，可以修改XML对象的限定名，如下所示： xml.setName(new QName(&ldquo;newroot&rdquo;))；</p>

<p>通常，这个方法会在修改相应命名空间下的元素标签名或特性名吋用到。如果该名称不属于任何命 名空间，则可以像下面这样使用setLocalNamet)方法来修改内部名称：</p>

<p>xml.setLocalName(&ldquo;newtagname&rdquo;);</p>

<p>19.2    —般用法</p>

<p>在将XMI.对象、元素、特性和文本集合到一个层次化对象之后，就可以使用点号加特性或标签名的 方式来访问其中不同的层次和结构。毎个子元素都是父元索的一个属性，而属性名与元素的内部名称相 同。如果子元素只包含文本，则相应的属性只返冋文本，如下面的例子所示。</p>

<p>var employee = <employee position?Software Engineer*></p>

<p><name>Nicholas C. Zakas</name></p>

<p></employee>;</p>

<p>alert(employee.name)/ //&ldquo;Nicholas C- ZakasM</p>

<p>以上代码巾的<name/>^&amp;素只包含文本。访问employee. name即可取得该文本，而在内部需要定 位到<name/>元索，然后返回相应文本。由于传人莉alert U时，会隐式调川toString ()方法，因此 显示的中包含的文本。这就使得访问XML文档中包含的文本数据非常方便。如果有多个元素 具有相同的标签名，则会返回XMLList。下面再看，-个例子。</p>

<p>var employees = <employees></p>

<p><employee position="Software Engineer■></p>

<p><name>Nicholas C. Zakas</naroe></p>

<p></employee></p>

<p><employee position="Salesperson"></p>

<p><name>Jim Smith</name></p>

<p></employee></p>

<p></employees>；</p>

<p>alert(employees.employee[0].name);    //&ldquo;Nicholas C. Zakas*</p>

<p>alert (employees. employee [1J .name) ;    Smith**</p>

<p>这个例子访问了每个<emPlOyee/>元素并返间了它们<naine/>元素的值。如果你不确定子元素的内</p>

<p>部名称，或者你想访问所有子元素，不管其名称是什么，也可以像下面这样使用星号(* )。</p>

<p>. var allchildren = employees. * ；    //返因所有子元素，不管其名称是什么</p>

<p>alert (employees. * [0] .nameJ;    /&ldquo;Nicholas C. Zakas■</p>

<p>UsageExampleOl. htm</p>

<p>与M•他属性一样，星号也可能返回XML对象，或返回XMLList对象，这要取决于XML结构。</p>

<p>要达到同样的目的，除了属性之外，还可以使川childU方法。将屈性名或索引倌传递给child!) 方法，也会得到相同的偵。來看下面的例子。</p>

<p>var firstChild = employees.child(0) ;    //与 employees. * [0]相同</p>

<p>var employeeList = en^loyees.child(&ldquo;employee&rdquo;)；    &ldquo;与 employees.employee 相同</p>

<p>var allChildren = employees.child{&rdquo; *&ldquo;) ;    //与 employees .*相同</p>

<p>为了再方便一些，还有一个children(1方法始终返回所有子元索。例如：</p>

<p>19</p>

<p>var allChildren = employees. children ()；    &ldquo;与 employees .*相同</p>

<p>而另一^方法elements()的行为与chiW()类似，区别仅在于它只返回表示元索的狐对象。例如：</p>

<p>var employeeL丄st = employees.elements (&ldquo;employee&rdquo;) ;    //与 employees-employee 相同</p>

<p>var allChildren = employees. elements {&rdquo;<em>&lsquo;</em>);    //与 employees 相同</p>

<p>这些方法为JavaScript开发人员提供了访问XML数据的较为熟悉的语法。</p>

<p>要删除子元素，可以使用delete操作符，如下所示：</p>

<p>delete employees.employee(01;</p>

<p>alert(employees.employee.length{))；    //I</p>

<p>显然，这也IE是将子节点看成嵐性的一个主要的优点。</p>

<p>19.2.1访问特性</p>

<p>访问特性也可以使用点语法，不过其语法稍有扩充。为了区分特性名与子元素的标签名，必须在名</p>

<p>称前面加上一个@字符。这是从XPath中借鉴的语法；XPath也是使用@来区分特性和标签的名称。不过，</p>

<p>结果可能就是这种语法看起来比较奇怪，例如：</p>

<p>var employees = <employees></p>

<p><employee position」Software Engineer■></p>

<p><name>Nicholas C. 2akas</nanie></p>

<p></employee></p>

<p>〈employee position= ^Salespersonw&gt;</p>

<p><name>Jiin Smith</nanie></p>

<p></employee></p>

<p></employees>;</p>

<p>alert(employees.employee[0].^position); //&ldquo;Software Engineer&rdquo;</p>

<p>A tributesExampleO 1. htm</p>

<p>与元素-样，每个特性都由一个属性来表示，而且可以通过这种简写语法来访问。以这种语法访问 特性会得到一个表示特性的XML对象，对象的toStringO方法始终会返间特性的值。要取得特性的名 称，可以使用对象的name ()方法。</p>

<p>另外，也可以使用child ()方法来访问特性，只要传人带有@前缀的特性的名称即可。 alert(employees.employee(0].child(K@position&rdquo;));    //&ldquo;Software Engineer&rdquo;</p>

<p>AitributesExampleOl .htm</p>

<p>由T-访问XML对象的属性时也可以使用childO,因此必须使用@字符麥区分标签名和特性名。 使用attributed方法并传人特性名，可以只访问XML对象的特性。*与child(＞方法不同，使</p>

<p>用attributed方法时，不需要传人带@字符的特性名。下面是一个例子。</p>

<p>alert(employees.employee[0].attribute(&ldquo;position&rdquo;))； //&ldquo;Software Engineer*</p>

<p>AttributesExampleOl .htm</p>

<p>这三种访问特性的方式同时适用于XML和XMLList类型。对于XML对象来说，会返回一个表示相 应特性的XML对象；对XMLList对象来说，会返回一个XMLList对象，其中包含列表中所有元素的 特性XML对象。对于前面的例子而言，employees. employee. ©position返回的XMLList将包含两 个对象：一个对象表示第一个〈employee/;^素中的position特性，另一个对象表示第二个元素中 的同一特性。</p>

<p>要取得XML或XMLList对象中的所有特性，可以使用attributes ()方法。这个方法会返冋一个 表示所有特性的XMLList对象。使用这个方法与使用@*的结果相同，如下面的例子所示。</p>

<p>/ /下面两种方式都会取得所有特性</p>

<p>var attsl = employees.employee[0].0*;</p>

<p>var atts2 = employees.employee[0].attributes();</p>

<p>在E4X中修改特性的值与修改属性的值一样非常简单，只要像下面这样为特性指定一个新值即可。 employees .employee [0] .©position = &ldquo;Author**;    //修改 position 特性</p>

<p>修改的特性会在内部反映出来，换句话说，此后再序列化XML对象，就会使用新的特性值。同样， 为特性K值的语法也可以用来添加新特性，如下面的例子所示。</p>

<p>employees.employee[0] .©experience = &ldquo;8 years*;    &ldquo;添加 experience 特性</p>

<p>employees.employee[0] .©manager = &ldquo;Jim Smith&rdquo;；    &ldquo;添加 manager 特性</p>

<p>由于特性与其他ECMAScript属性类似，因此也可以使用delete操作符来删除特性，如下所示。 delete employees.employee [0] . ©position；    //州除 position 特性</p>

<p>通过属性来访问特性极大地简化了与底层XML结构交互的操作。</p>

<p>19.2.2其他节点类型</p>

<p>E4X定义了表现XML文档中所有部分的类型，包括注释和处理指令。在默认情况上，E4X不会解 析注释或处理指令，因此这些部分不会出现在最终的对象层次中。如果想让解析器解析这些部分，可以 像下面这样设置XML构造函数的下列两个属性。</p>

<p>XML.ignoreComments = false；</p>

<p>xml.ignoreProcessinglnstructions = false；</p>

<p>在设置了这两个属性之后，E4X就会将注释和处理指令解析到XML结构中。</p>

<p>由于XML类型可以表示所有节点，因此必须有一种方式来确定节点类型。使用nodeKindU方法可</p>

<p>以得到XML对象表#的类型，该访问可能会返回11 text*、&rdquo;element&rdquo;、&rdquo;comment&rdquo;、&rdquo;processing-</p>

<p>instruction&rdquo;或&rdquo;attribute&rdquo;。以下面的 XML 对象为例。</p>

<p>var employees = <employees></p>

<p>&lt;?Dont forget the donutb?&gt;</p>

<p><employee position:"Software Engineer"></p>

<p><name>Nicholas C. zakas</name></p>

<p></employee></p>

<p><I--just added--></p>

<p><employee position?Salesperson"></p>

<p><name>Jim Smith</name></p>

<p></employee></p>

<p></employees> ;</p>

<p>我们可以通过下面的表格来说明nodeKindO返回的节点类型。</p>

<p>语 句    返回值</p>

<p>employees.nodeKind()</p>

<p>employees.* fO].nodeKind()</p>

<p>employees.employee[0].^position.nodeKindO employees.employee[0].nodeKind() employees.* 12J.nodeKind() emp] oyees . emp] cyee【0: . r.ame • * [ C j . nodeKi nd ()</p>

<p>■element&rdquo;</p>

<p>•processing-instruction&rdquo;</p>

<p>■element&rdquo; • comment&rdquo; •text&rdquo;</p>

<p>19</p>

<p>不能在包含多个XML对象的XMLList上调用nodeKindO方法；否则，会抛出一个错误。</p>

<p>可以只取得特定类型的节点，而这就要用到下列方法。</p>

<p>□    attributes ():返回XML对象的所有特性。</p>

<p>□    comments ():返回XML对象的所有子注释节点。</p>

<p>口 elements ( LagName):返回XML X寸象的所省子元素。可以通过提供元素的tagName (标签名) 来过滤想要返回的结果。</p>

<p>□    processinglnstructions (name):返冋XML对象的所有处理指令。可以通过提供处理指令 的name (名称)来过滤想要返回的结果。</p>

<p>□    text ():返冋XML对象的所有文本子节点。</p>

<p>上述的每一个方法都返回一个包含适当XML对象的XMLList0</p>

<p>使用hasSimpleContent ()和hasComplexContent ()方法，可以确定XML对象中是只包含文本， 还是包含更复杂的内容。如果XML对象中只包含子文本节点，则前一个方法会返回tsrue;如果XML对 象的子节点中有任何非文本节点，则后一个方法返回true。来看下面的例子。</p>

<p>alert(employees.employee[0 J.hasComplexCont ent());    //true</p>

<p>alert(employees.employee[0].hasSimpleContent());    //false</p>

<p>alert{employees-employee[0].name.hasComplexContent());    //false</p>

<p>alert(employees.employee[0].name.hasSimpleContent())；    //true</p>

<p>利用这些方法，以及前面提到的其他方法，可以极大地方便查找XML结构中的数据。</p>

<p>19.2.3查询</p>

<p>实际上，E4X提供的査询语法在很多方面都与XPath类似。取得元素或特性值的简单操作是最基本</p>

<p>的查询，在査尚之前,不会创建表现XML文档结构中不同部分的XML对象，从底层来看,XML和XMLList 的所有属性事实上都是查询的结果。也就是说，引用不表现XML结构中某一部分的W性仍然会返回 XMLList;只不过这个XMLList中什么也不会包含。例如，如果基于前面的XML示例执行下列代码， 则返四的结果就是空的。</p>

<p>var cats = employees.cat; alert (cats, length⑴；    Z/0</p>

<p>QueryingExampleO 1 .htm</p>

<p>这个査询想要査找＜emplOyeeS/＞中的＜cat/＞元索，似这个元素并不存在。L面的第一行代码会返 囲一个空的XMLList对象。虽然返冋的是空对象，但査询可以照常进行，而不会发生异常。</p>

<p>前面我们看到的大多数例子都使/U点语法来访M直接的子节点。而像下面这样使用两个点.则以 进一步扩展杏询的深度，查尚到所有后代节点3</p>

<p>var allDescendants = employees.    //取俘＜employees/＞^所有后代节点</p>

<p>上面的代码会返回＜emplOyeeS/＞X素的所有后代节点。结果中将会包含元素、文本、注释和处理 指令，最后两种节点的有无取决于在XML构造函数上的设H (前面曾经讨论过)；但结果中不会包含特 性。要想取得特定标签的元素.需要将星号替换成实恥的标签名„</p>

<p>var a^-lNames = employees, .name；    //取坏作*＜employees/＞后代的所有cname/^节点</p>

<p>同样的奄询可以使用descendants (＞方法来完成。在不给这个方法传递参数的情况F,它会返回 所有后代节点(与使用相同)，而传递一个名称作为参数则可以限制结果。下面就是这两种情况的 例子。</p>

<p>var a] lDescendants = employees .descendants () ；    //所有后代节点</p>

<p>var allNames = employees .descendants (&ldquo;name&rdquo;);    //后代中的所有</p>

<p>还nr以取得所有后代元素屮的所打特性，方法是使用F列任何一行代码。</p>

<p>var allAttributes = employees. .；    //取得所有后代元素中的所有特性</p>

<p>var allAttributes2 = employees.descendants (&ldquo;@*&ldquo;) ;    //同上</p>

<p>与限制结果中的后代元素一样，也町以通过用完整的特性名来荇换星号达到过滤特性的目的。例如:</p>

<p>var allAttributes = employees, .©position；    //取得所有 position 特性</p>

<p>var aLlAttributes2 - employees .descendants (&ldquo;©position&rdquo;) ；    //同上</p>

<p>除了访问后代元素之外，还可以指定査询的条件。例如，要想返回position特性值为 &ldquo;Salesperson&rdquo;的所有＜ employee/＞元素，可以使用下面的丧询：</p>

<p>var salespeople = employees.employee.(^position == *Salesperson&rdquo;);</p>

<p>同样的语法也可以用尸修改XML结构中的某一部分。例如，可以将第一位销售员(salesperson) 的position特性修改为MSenior Salesperson&rdquo;,代码如下：</p>

<p>employees.employee.(^position == &ldquo;Salesperson&rdquo;)[0].©positions &ldquo;Senior Salesperson&rdquo;；</p>

<p>注意，阏括号中的表达式会返冋一个包含结果的XMLList,而力IS号返冋其中的第一项，然后我们 童写了©position厲性的值。</p>

<p>使用parent （）方法能够在XML结构中上亂这个方法会返M&rsquo; +•个XML对象，表示当前XML对象 的父元素。如果在XMLList上调用parent:（&gt;方法，则会返间列表中所有对象的公共父元素。下而是 一个例子。</p>

<p>var employees2 = employees.employee.parent｛）;</p>

<p>这ffl,变虽employees2中包含着与变S: employees相同的值。在处理来源未知的XML对象时， 经常会用到parent U方法。</p>

<p>19.2.4构建和操作XML</p>

<p>将XML数据转换成XML对象的方式有很多种,，前面曾经讨论过，可以将XML字符串传递到XML 构造函数中，也可以使用XML字面fi。相对而言，XML字面量方式更方便一些，因为可以在字面S中嵌 人JavaScript变fi,语法是使用花括号（（ &gt; ）。可以将JavaScript变量嵌人到字面皺中的任意位置上，如 下面的例子所示。</p>

<p>var tagName = &ldquo;color-；</p>

<p>var color = &ldquo;red&rdquo;;</p>

<p>var xml = &lt;{tagName}&gt;{color}&lt; Z{tagName}&gt;;</p>

<p>alert(xml.toXMLScring())；    //&rdquo;<color>red</color></p>

<p>19</p>

<p>XML ConstructionExample01. htm</p>

<p>在这个例了•中，XML字面量的标签名和文本值都是使用花括号语法插入的。有了这个语法，就可以 省去在构建XML结构时拼接字符串的麻烦。</p>

<p>E4X也支持使用标准的JavaScript语法来构建完整的XML结构。如前所述，大多数必要的操作都 是查询，而且即便元素或特性不存在也不会抛出错误。在此基础上更进一步，如果将一个值指定给一个 不存在的元素或特性，E4X就会首先在底层创建相应的结构，然后完成赋值。来看下面的例子。</p>

<p>var employees = <employees/>;</p>

<p>employees.employee.name = &ldquo;Nicholas C. Zakas&rdquo;； employees.employee.@posiCion = &ldquo;Software Engineer&rdquo;；</p>

<p>XMLConstructionExample02. htm</p>

<p>这个例子一开始声明了<employeeS/>元索，然后在这个元索基础上开始构建XML结构。第二行 代砰在〈employees/〉1!1创建了—■个<employee/>元素和一个<name/>元素，并指定了文本值。第三行 代码添加了一个position特性并为该特性指定了值。此时构建的XML结构如下所示。</p>

<p><employees></p>

<p><employee position="Software Engineer></p>

<p><namc>Nicholas C. Zakas</name></p>

<p></employee></p>

<p></employees></p>

<p>当然，使川加号操作符也可以19添加一f<emPlOyee/>元素，如下所示。</p>

<p>employees.employee += <employee position="Salesperson></p>

<p><name>Jim Smith</name></p>

<p></employee>；</p>

<p>XML ConstructionExample02. htm</p>

<p>最终构建的XML结构如下所示:</p>

<p><eraployees></p>

<p><employee position:”Software Engineer*></p>

<p><name>Nicholas C. Zakas</name></p>

<p></employee></p>

<p><employee position="Salesperson■></p>

<p><name>Jim Smith</name></p>

<p>&lt;/employee；*</p>

<p></employees></p>

<p>除了上面介绍的基本的XML构建语法之外，还有一些类似DOM的方法，简介如下。</p>

<p>□    appendChild(child):将给定的chi Jd作为子节点添加到XMLList的末尾。</p>

<p>□    copy ():返回XML.对象副本。</p>

<p>□    insertChildAfter (refNode,    :将 chi 2d 作为子节点插入到 XMLList 中 refNode 的后面。</p>

<p>□    insert Chi ldBe fore (refNode, chiJd):将 child 作为子节点插人到 XMLList 中 refNode 的前面。</p>

<p>□    prependChild(child):将给定的child作为子节点添加到XMLList的开始位置。</p>

<p>□    replace (property Name f value): 用value值替换名为propertyName的屈性，这个属性 可能是一个元素，也可能是一个特性。</p>

<p>□    setChildren( children):用children替换当前所有的子元素，chi J dr en可以是XML对 象，也可是XMLList对象。</p>

<p>这些方法既非常有用，也非常容易使用。下列代码展示了这些方法的用途。</p>

<p>var employees 二 <employees></p>

<p><employee positions"Software Engineer-></p>

<p><name>Nicholas C. Zakas</name></p>

<p>&lt;/employee〉</p>

<p><employee position-"Salesperson"></p>

<p><name>Jim Smith</name></p>

<p></employee></p>

<p></employees>;</p>

<p>employees.appendChild(<axoployee positions"Vic© PresidentN> <name>Benjamin AnderBon&lt; /ziame&gt;</p>

<p></employee>)j</p>

<p>eaployees.prependChiId(<employee position置"User Interface Designer*> <ziame>Micbael Johnson&lt; / name &gt;</p>

<p></employee>);</p>

<p>employees.insertChildBefore(employees.child(2),</p>

<p><employee positions■Human Resources ManagerR></p>

<p><namo>Margaret Jones</name></p>

<p><Zemployee>);</p>

<p>employees.setchildren(<employee position*"President"></p>

<p><name>Richard McMichael</name></p>

<p></employee> +</p>

<p><employee positions"Vice PresidentM></p>

<p><ziame>Rebecca    Znai&amp;e&gt;</p>

<p></einployee>) j</p>

<p>XMLConstructionExample03. him</p>

<p>以上代码首先在员工列表的底部添加了一个名为Benjamin Anderson的副总统(vice president)。然 后，在员工列表顶部又添加了一个名为Michael Johnson的界面设计师。接着，在列表中位置为2的员</p>

<p>工-此时这个员_丁.是Jim Smith,因为他前面还有Michael Johnson和Nicholas C. Zakas-之前又添加</p>

<p>了一个名为Margaret Jones的人力资源部经理。始后，所有这些子元素都被总统Richard McMichael和副 总统Rebecca Smith替代。结果XML如下所示。</p>

<p><employees></p>

<p>〈employee posi t i on=&ldquo;Pres ident■&gt;</p>

<p><name>Richard McMichael</name></p>

<p></employee></p>

<p><employee position="Vice President"></p>

<p><name>Rebecca Smith</name></p>

<p></employee></p>

<p></employees></p>

<p>熟练运用这些技术和方法，就能够使用E4X执行任何DOM风格的操作。</p>

<p>19.2.5解析和序列化</p>

<p>E4X将解析和序列化数据的控制放在了 XML构造函数的一些设置当中。与XML解析相关的设置有 如下三个。</p>

<p>19</p>

<p>□    ignoreComments：表示解析器应该忽略标记中的注释。献认设置为true。</p>

<p>□    ignoreProcessinglnstructions:表豕解析器应该忽略标记中的处理指令。默认设S为true。</p>

<p>□    ignoreWhitespace：表示解析器应该忽略元素间的空格，而不是创建表现这些空格的文本节 点。默认设置为 trueo</p>

<p>这三个设置会影响对传人到XML构造函数中的字符串以及XML字面量的解析。</p>

<p>另外，与XML数据序列化相关的设置有如下两个。</p>

<p>□    pretty Indent：表乐•在序列化XML时，每次缩进的空格数量。默认值为2。</p>

<p>□    prettyPrinting:表示应该以方便人类认读的方式输出XML,即每个元素重起一行，而且子 元素都要缩进。默认设置为true。</p>

<p>这两个设置将影响到toString()和toXMLString()的输出。</p>

<p>以上五个设置都保存在settings对象中，通过XML构造函数的settings ()方法可以取得这个对 象，如下所示。</p>

<p>var settings = XML.settings();</p>

<p>alert(settings.ignoreWhitespace)；    //true</p>

<p>alert(settings.ignoreComments);    //true</p>

<p>Pars ingAndSerializationExampleO 1. htm</p>

<p>通过向setSettingsO方法中传人包含全部5项设置的对象，可以一次性指定所有设置。在需要 临时改变设置的情况下，这种设置方式非常相用，如下所示。</p>

<p>var settings = XML.settings(); XML.prettyIndent = 8;</p>

<p>XML.ignoreComments = false;</p>

<p>//执行某些处理</p>

<p>XML. setSettings (settings) ;    //重前面的设置</p>

<p>而使用defaulcSettingsf)方法则可以取得•个包含默认设置的对象，因此任何时候都可以使用 下面的代码重置设置、.</p>

<p>XML.setSettings(XML.defaultSettings()};</p>

<p>19.2.6命名空间</p>

<p>E4X提供了方便使用命名空间的特性。前面曾经讨论过，使用r.amspaceO方法对以取得与特定前 缀对应的Namespace Xt象j,而通过使用setNamespace ()并传人Namespace X寸象，也可以为给定元 素设置命名空间。来看下面的例子。</p>

<p>var messages = <messages></p>

<p><message>Hello world!</message></p>

<p></messages>?</p>

<p>messages.setNamespace (new Namespace (&ldquo;wrox&rdquo;, &ldquo;http ： //wv/w. wrox. com/ ■));</p>

<p>调用setNamespace &lt;)方法后，相应的命名空间只会应用到调用这个方法的元素。此时，序列化 messages变景会得到如下結果。</p>

<p><wrox:messages xmlns:wrox="<http://www.wrox.com/>&rdquo;&gt;</p>

<p><message>Hello world!</message></p>

<p></wrox：messages></p>

<p>可见，由于调用了 setNamespace (}方法，<1^353965/>元索有了 wrox命名空间前缀，而 <message/>元素则没有变化。</p>

<p>如果只想添加一个命名空间声明，而不想改变元素，可以使用addNamespaceU方法并传人 Namespace对象，如下面的例子所示。</p>

<p>messages. addNamespace (new Namespace (&ldquo;wrox&rdquo;, &ldquo;http: &ldquo;ww.wrox.com/&rdquo;)};</p>

<p>在将这行代码应用于原先的〈niessages/^元素时，就会创建如下所示的XML结构。</p>

<p><messages xmlns: wrox?http: "[www.wrox.com/](http://www.wrox.com/) •></p>

<p><message>Hello world I</message></p>

<p></niessages></p>

<p>凋用removeNamespace ()方法并传人Namespace对象，可以移除表Z5特定命名空间前缀和URI 的命名空间声明；注意，必须传人丝毫不差的表示命名空间的Namespace对象。例如：</p>

<p>messages.removeNamespace(new Namespace{^wrox&rdquo;, Mhttp：//www.wrox.com/&ldquo;));</p>

<p>这行代码可以移除wrox命名空间。不过，引用前缀的限定名不会受影响。</p>

<p>有两个方法町以返回与节点相关的Namespace对象的数组：namespaceDeclarations ()和 inScopeNamespacesOc前者返回在给定节点上声明的所有命名空间的数组，后者返回位于给定节点 作用域中(即包括在节点自身和祖先元素中声明的)所有命名空间的数组。如下面的例7所示：</p>

<p>var messages = cmessages xmlns:wrox=Mhttp://www.wrox.com/&ldquo;&gt;</p>

<p><message>Hello world!</mGssage></p>

<p></messages>;</p>

<p>alert(messages.namespaceDeclarations()); alert(messages.inScopeNamespaces());</p>

<p>//&ldquo;http：//www.wrox.com&rdquo; //&ldquo;,http：//www.wrox.com&rdquo;</p>

<p>alert(messages.message.namespaceDeclarations())?    //”*</p>

<p>alert {messages.message. inScopeNamespaces ()) ;    //**, <a href="http://www.wrox.com-">http://www.wrox.com-</a></p>

<p>这里，〈messages/＞元素在调用namespaceDeclarations ()时，会返回包含一命名空间的数组， 而在调用inScopeNamespaces ()时，则会返回包含两个命名空间的数组。作用域中的这两个命名空间， 分别是默认命名空间(由空字符串表示)和wrox命名空间。在＜iuesSage/＞元素上调用这些方法时， namespaceDeclarat ions (),会返回一个空数组，而inScopeNamespaces ()方法返回的结果与在 ＜meSSageS/＞元素上调用时的返回结果相同。</p>

<p>使用双H号(：：)也可以基于Namespace对象来査询XML结构中具有特定命名空间的元素。例 如，要取得包含在wrox命名空间中的所有cmessage/〉元素，可以参考下面的代码。</p>

<p>var messages = 〈messages xmlns:wrox-&rdquo;<a href="http://www.wrox.com/">http://www.wrox.com/</a>&rdquo;&gt; <a href="wrox:message">wrox:message</a>Hello world!</message></p>

<p></messages>；</p>

<p>var wroxNS = new Namespace(&ldquo;wrox&rdquo;, &ldquo;<a href="http://www.wrox.com/">http://www.wrox.com/</a>&rdquo;)? var wroxMessages = messages.wroxNS::message;</p>

<p>这里的双冒号表示返回的元素应该位于其中的命名空间。注意.这里使用的是JavaScript变贵，而 不是命名空间前缀。</p>

<p>还可以为某个作用域中的所有XML对象设置默认命名空间。为此，要使用default xml namespace 语句，并将一个Namespace对象或一个命名空间URI作为值赋给它。例如：</p>

<p>default xml namespace - &ldquo;<a href="http://www.wrox.com/%22%ef%bc%9b">http://www.wrox.com/&rdquo;</a><a href="http://www.wrox.com/%22%ef%bc%9b">；</a></p>

<p>19</p>

<p>function doSomething(){</p>

<p>/ /只为这个轟数设置默认的命名空间</p>

<p>default xml namespace = new Namespace(&ldquo;your&rdquo;, &ldquo;<a href="http://www.yourdomain.com&quot;}">http://www.yourdomain.com&quot;}</a>;</p>

<p>}</p>

<p>在doSomething ()函数体内设置默认命名空间并不会改变全局作用域中的默认XML命名空间。 在给定作用域中，当所有XML数据都需要使用特定的命名空间时，就可以使用这个语句，从而避免多 次引用命名空间的麻烦。</p>

<p>19.3其他变化</p>

<p>为了与ECMAScript做到无缝集成，E4X也对语言基础进行了一些修改。其中之_就是引人了 for-each-in循环，以便迭代遍历每一个属性并返冋属性的值，如下面的例子所示。</p>

<p>var employees = <employees></p>

<p><employee position?Software Engineer"></p>

<p><name>Nicholas C. Zakas</name></p>

<p></employee></p>

<p><employee position="Salesperson"></p>

<p><name>Jim Smith</name></p>

<p></employee></p>

<p></employees>;</p>

<p>for each (var child in employees){ alert(child.coXKLString())?</p>

<p>}</p>

<p>ForEachlnExampleO L htm</p>

<p>在这个例子的for-each-in循环中，〈employees/;^每个子节点会依次被赋值给child变盘， 其中包括注释、处理指令和域文本节点。要想返回特性节点,则需要对一个由特性节点组成的XMLList 对象进行操作，如下所示。</p>

<p>for each (var attribute in employees.@*) { //遍历特41 alert(attribute);</p>

<p>}</p>

<p>虽然for-each-in循环是在E4X中定义的，但这个语句也可以用于常规的数组和对象，例如：</p>

<p>var colors - [&ldquo;red&rdquo;,&ldquo;green&rdquo;,&ldquo;blue&rdquo;]; for each(var color in colors){</p>

<p>alert(color)；</p>

<p>}</p>

<p>ForEachlnExampleO 1. htm</p>

<p>对于数组，for-eaCh-in循环会返回数组中的每一项。对于非XML对象，这个循环返回对象每个 属性的值。</p>

<p>E4X还添加了一个全局函数，名叫isXMLNameO。这个函数接受一个字符申，并在这个字符串是</p>

<p>元素或特性的冇效内部名称的情况下返冋true。在使用未知字符串构建XML数据结构时，这个确数可</p>

<p>以为开发人员提供方便。来看下面的例子。</p>

<p>alert(isXMLNamef&rdquo;color&rdquo;));    //true</p>

<p>alert (isXMIiName( &ldquo;hello world&rdquo;) } ?    //false</p>

<p>如果你不确定某个字符申的来源，而又需要将该字符串川作一个内部名称，那么最好在使用它之前 先通过isXMLNameO检测一下是否有效，以防发生错误。</p>

<p>E4X对标准ECMAScript的最后一个修改是typeof操作符。在对XML对象或XMLList对象使用 这个操作符时，typeof返回字符串-xml’•。但在对其他对象使用这个操作符时，返回的都是&rdquo;object”， 例如：</p>

<p>var xml - new XML()； var list = new XMLList(); var object = {};</p>

<p>alert(typeof xml); //&ldquo;xml&rdquo; alert(typeof list);    //&ldquo;xml&rdquo;</p>

<p>alert(typeof object); //&ldquo;object0</p>

<p>多数悄况下，都没有必要区分XML和XMLList对象。在E4X中，这两个对象都被看成是基本数据 类型.因而也无法通过instanceof操作符来将它们区分开来。</p>

<p>19.4全面启用E4X</p>

<p>鉴于E4X在很多方面给标准JavaScript带来了不同，因此Firefox在默认情况下只启用E4X中与其</p>

<p>他代码能够相安无事的那些特性。要想完整地启用E4X,需要将<Script>标签的type特性设置为 &ldquo;text/javascript ；e4x=ln,例如：</p>

<script type="text/javascript; e4x=l,f src= -e4x_file. js"></script>

<p>在打开这个“开关”之后，就会全面启用E4X,从而能够正确地解析嵌入在E4X字面最中的注释 和CData片段。在没有完整泊用E4X的情况下使用注释和/或CData片段会导致语法错误。</p>

<p>19.5小结</p>

<p>E4X是以ECMA-357标准的形式发布的对ECMAScript的一个扩展。E4X的H的是为操作XML数 据提供与标准ECMAScript更相近的语法。E4X具有下列特征。</p>

<p>□与DOM不同，E4X只用一个类铟来表示XML中的各种节点。</p>

<p>□ XML对象中封装了对所有节点都有用的数据和行为。为表现多个节点的集合，这个规范定义了 XMLList 类S。</p>

<p>□另外两个类趣，Namespace和QName,分别表现命名空间和限定名。</p>

<p>为便于査询XML结构，E4X还修改了标准了的ECMAScript语法，修改的地方如下。</p>

<p>口使用两个点（..）表示要匹配所有后代元家，使用@字符表示应该返回一或多个特性。</p>

<p>□星号字符（* ）是一个通配符，可以匹配任意类铟的节点。</p>

<p>□所有这些査询都町以通过&ndash;组执行相同操作的方法来实现。</p>

<p>到2011年底，Firefox还是唯一一个支持E4X的浏览器。尽管没冇其他浏览器提供商承诺会实现E4X, 但在服务器上，由于BE A Workshop for WebLogic和Yhaoo! YQL的推动，E4X已经取得了不小的成功。</p>

    </div>

    
    

    
    

    <footer class="post-footer">
      

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/05-%E5%9F%BA%E7%A1%80%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/03-%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/js/js20-json/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">JS20 JSON</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/05-%E5%9F%BA%E7%A1%80%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/03-%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/js/js18-javascript%E4%B8%8Exml-/">
            <span class="next-text nav-default">JS18 JavaScript与XML</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="iteratelyd@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="http://github.com/iterateself" class="iconfont icon-github" title="github"></a>
      <a href="https://www.zhihu.com/people/thebegin/activities" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="https://www.douban.com/people/68028070/" class="iconfont icon-douban" title="douban"></a>
  <a href="http://iterate.site/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> site pv: <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
    <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> site uv: <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2018
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">iterateself</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>


<script type="text/javascript" src="/dist/even.min.js?v=3.2.0"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>








</body>
</html>
