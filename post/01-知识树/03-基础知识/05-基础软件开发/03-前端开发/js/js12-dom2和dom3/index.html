<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>JS12 DOM2和DOM3 - 迭代自己</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="iterateself" />
  <meta name="description" content="第.12章 DOM2 和 DOM3 本章内容 □ DOM2和D0M3的变化 □操作样式的DOM API □ DOM遍历与范闱 Domi级主要定义的是html和xml文档的底层结构" />

  <meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.47.1" />


<link rel="canonical" href="http://iterate.site/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/05-%E5%9F%BA%E7%A1%80%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/03-%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/js/js12-dom2%E5%92%8Cdom3/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">




<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<link href="/dist/even.min.css?v=3.2.0" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">




<meta property="og:title" content="JS12 DOM2和DOM3" />
<meta property="og:description" content="第.12章 DOM2 和 DOM3 本章内容 □ DOM2和D0M3的变化 □操作样式的DOM API □ DOM遍历与范闱 Domi级主要定义的是html和xml文档的底层结构" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://iterate.site/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/05-%E5%9F%BA%E7%A1%80%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/03-%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/js/js12-dom2%E5%92%8Cdom3/" /><meta property="article:published_time" content="2018-08-21T18:16:23&#43;00:00"/>
<meta property="article:modified_time" content="2018-08-21T18:16:23&#43;00:00"/>
<meta itemprop="name" content="JS12 DOM2和DOM3">
<meta itemprop="description" content="第.12章 DOM2 和 DOM3 本章内容 □ DOM2和D0M3的变化 □操作样式的DOM API □ DOM遍历与范闱 Domi级主要定义的是html和xml文档的底层结构">


<meta itemprop="datePublished" content="2018-08-21T18:16:23&#43;00:00" />
<meta itemprop="dateModified" content="2018-08-21T18:16:23&#43;00:00" />
<meta itemprop="wordCount" content="36225">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="JS12 DOM2和DOM3"/>
<meta name="twitter:description" content="第.12章 DOM2 和 DOM3 本章内容 □ DOM2和D0M3的变化 □操作样式的DOM API □ DOM遍历与范闱 Domi级主要定义的是html和xml文档的底层结构"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">迭代自己</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">主页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a><a href="/catalog/">
        <li class="mobile-menu-item">完整目录</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">迭代自己</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">主页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/catalog/">完整目录</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">JS12 DOM2和DOM3</h1>

      <div class="post-meta">
        <span class="post-time"> 2018-08-21 </span>
        
        <span class="more-meta"> 36225 words </span>
        <span class="more-meta"> 73 mins read </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> times read </span>
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  
  <div class="post-toc-content">
    
  </div>
</div>

    
    

    
    <div class="post-content">
      <p>第.12章</p>

<p>DOM2 和 DOM3</p>

<p>本章内容</p>

<p>□    DOM2和D0M3的变化 □操作样式的DOM API</p>

<p>□    DOM遍历与范闱</p>

<p>Domi级主要定义的是html和xml文档的底层结构。dom2和dom3级则在这个结构 的基础上引入了更多的交S:能力，也支持丁更髙级的XML特性。为此，DOM2和DOM3</p>

<p>级分为许多模块(模块之间具有某种关联)，分别描述了 DOM的某个非常具体的子集。这些模块 如下。</p>

<p>□ DOM2级核心(DOM Level 2 Core):在1级核心基础上构建，为节点添加了更多方法和属性。 □ D0M2级视图(DOM Level 2 Views )：为文档定义了基于样式信息的不同视图。</p>

<p>□ DOM2级事件(DOM Level 2 Events )：说明了如何使用事件与DOM文档交互。</p>

<p>□ DOM2级样式(DOM Level 2 Style )：定义了如何以编程方式来访问和改变CSS样式信息。</p>

<p>□ DOM2级遍历和范围(DOM Level 2 Traversal and Range )：引人了遍历DOM文档和选择其特定</p>

<p>部分的新接口。</p>

<p>□ DOM2级HTML (DOMLevel2HTML):在1级HTML基础上构建，添加了更多属性、方法和 新接口。</p>

<p>本章探讨除“DOM2级事件”之外的所有模块，“DOM2级事件”模块将在第13章进行全面讲解。</p>

<p>DOM3级又增加了 “XPath”模块和“加载与保存” 些模块将在第18章讨论。</p>

<p>(Load and Save )模块。这</p>

<p>12.1 DOM 变化</p>

<p>DOM2级和3级的目的在于扩展DOMAPI,以满足操作XML的所有需求，同时提供更好的错误处 理及特性检测能力。从某种意义上讲，实现这一R的很大程度意味着对命名空间的支持。“DOM2级核 心”没有引人新类型，它只是在D0M1级的基础上通过增加新方法和新属性来墦强了既有类型。&rdquo;DOM3 级核心”同样增强了既有类型，但也引人了一些新类型。</p>

<p>类似地，“DOM2级视图”和“DOM2级HTML”模块也增强了 DOM接U,提供了新的属性和方 法。由于这两个模块很小，因此我们将把它们与“D0M2级核心”放在一起，讨论基本JavaScript对象 的变化。可以通过下列代码来确定浏览器是否支持这些DOM模块。</p>

<p>var supportsDOM2Core = document.implementat ion.hasFeature(■Core■, ■2.0&rdquo;); var supportsDOM3Core = document.implementation.hasFeature(&ldquo;Core&rdquo;, *3.0&rdquo;); var support8DOM2HTML = document.implementation.hasFeature(&ldquo;HTML&rdquo;, &ldquo;2.0&rdquo;); var supportsDOM2Views = document.implementation.hasFeature(&ldquo;Views&rdquo;/ &ldquo;2.0&rdquo;); var supportsDOK2XML = document .implementation. hasFeature (&ldquo;XML&rdquo;, **2.0&rdquo;};</p>

<p>(^\z章只讨论那些已经有浏览器实现的部分，任何浏览器都没有实现的部分将不作</p>

<p>Y讨论。</p>

<p>12.1.1针对XML命名空间的变化</p>

<p>有了 XML命名空问，不同XML文档的元素就可以混合在一起，共同构成格式良好的文档，而小&rsquo; 必担心发生命名冲突。从技术上说，HTML不支持XML命名空间，但XHTML支持XML命名空间。 因此，本节给出的都是XHTML的示例。</p>

<p>命名空间要使用xmlns特性来指定。XHTML的命名空间是<a href="http://www.w3.org/1999/xhtml,在任何">http://www.w3.org/1999/xhtml,在任何</a> 格式良好XHTML页面中，都应该将其包含在元素中，如下而的例子所求。</p>

<p><html xmlns="http：//www.w3.org/1999/xhtmi"></p>

<p><head></p>

<p><title>Example XHTML page</title></p>

<p></head></p>

<p><body></p>

<p>Hello world I &lt;/&lsquo;body&gt;</p>

<p></html></p>

<p>对这个例子而言，其中的所有元素默认都被视为XHTML命名空间中的元索。要想明确地为XML 命名空间创建前缀，可以使用xmlns后跟冒号，再后跟前缀，如下所示。</p>

<p><xhtml:html xmlns:xhtrol = ■http:/Zwww.w3.org/1999/xhtml"></p>

<p><a href="xhtml:head">xhtml:head</a></p>

<p><xhtml：title>Example XHTML page<a href="/xhtml:title">/xhtml:title</a></p>

<p></xhtml：head></p>

<p><a href="xhtml:body">xhtml:body</a></p>

<p>Hello world J <a href="/xhtml:body">/xhtml:body</a></p>

<p></xhtml：html></p>

<p>这里为XHTML的命名空间定义了一个名为xhtml的前缀，并要求所有XHTML元索都以该前缀</p>

<p>开头。有时候为了避免不同语言间的冲突，也需要使用命名空间来限定特性，如下面的例子所示。</p>

<p><xhtml:html xmlns：xhtml="http：//www.w3.org/1999/xhtml•></p>

<p><a href="xhtml:head">xhtml:head</a></p>

<p><a href="xhtml:title">xhtml:title</a>Example XHTML page<a href="/xhtml:title">/xhtml:title</a></p>

<p><a href="/xhtml:head">/xhtml:head</a></p>

<p><xhtiol：body xhtml x alassa"homeN ></p>

<p>Hello world J <a href="/xhtml:body">/xhtml:body</a></p>

<p><a href="/xhtml:html">/xhtml:html</a></p>

<p>这个例子中的特性class带有一个xhtml前缀。在只基于一种语言编写XML文档的情况下，命 名空间实际上也没有什么用。不过，在混合使用两种语言的情况下，命名空间的用处就非常大了。来看</p>

<p>-看下面这个混合了 XHTML和SVG语言的文档：</p>

<p><html xmlns="http：//www.w3.org/1999/xhtml"></p>

<p><head></p>

<p><title>Example XHTML page</title></p>

<p></head></p>

<p><body></p>

<p>&lt;Bvg xmlnB=!Mhttpj //<a href="http://www.w3">www.w3</a> .org/2000/svg&rdquo; version-Ml.l&rdquo;</p>

<p>viewBox=&ldquo;0 0 100 100&rdquo; style*&ldquo;width:100%; height:100%&ldquo;&gt;</p>

<p><rect x="0M y="0" width="100" height="100w styles"fill:red"/></p>

<p></avg></p>

<p></body></p>

<p></html></p>

<p>在这个例子中，通过设置命名空间，将&lt;^9&gt;标识为了与包含文档无关的元索。此时，<Svg>元素的 所有子元素，以及这些元素的所有特性，都被认为属于<a href="http://www.w3.org/2000/svg命名空间。即">http://www.w3.org/2000/svg命名空间。即</a> 使这个文档从技术上说是一个XHTML文档，但因为有了命名空间，其中的SVG代m仍然是有效的。</p>

<p>对于类似这样的文档来说，最有意思的事发生在调用方法操作文档节点的情况下。例如，在创建一 个元素时，这个元素属于哪个命名空间呢？在查询一个特殊禄签名时，应该将結果包含在哪个命名空间 中呢？ “DOM2级核心”通过为大多数DOM1级方法提供特定于命名空间的版本解决了这个问题。</p>

<p>1-Node类型的变化</p>

<p>在DOM2级中，Node类型包含下列特定于命名空间的属性。</p>

<p>□    localName：不带命名空间前缀的节点名称。</p>

<p>□    namespaceURI:命名空间URI或者（在未指定的情况T■是）null。</p>

<p>□    prefix：命名空间前缀或者（在未指定的情况下是）mill。</p>

<p>当节点使用了命名空间前缀时，其nodeName等于prefix+localName。以下面的文构为例：</p>

<p><html xralns="http：//www.w3.org/1999/xhtml*></p>

<p><head></p>

<p><title>Example XHTML page</title></p>

<p></head></p>

<p><body></p>

<p><s：Bvg xznlns：s=N<http://www.w3.orgZ2000/svgN> vorflion=Ml.l&rdquo;</p>

<p>viowBox=&ldquo;0 0 100 100&rdquo; stylo*&ldquo;widthj100%; height:100%&ldquo;&gt;</p>

<p><s:rect x=w0" y«"0" width-*100" heiffht="100" style="fill:red"/></p>

<p><a href="/s:svg">/s:svg</a></p>

<p></body></p>

<p></html></p>

<p>NamespaceExample.xml</p>

<p>对于＜html＞兀素来说，它的 localName 和 tagName 是&rdquo;html&rdquo;，namespaceURI 是&rdquo;<a href="http://www">http://www</a>. w3.org/1999/xhtml&rdquo;,而 prefix 是 null。对于＜s:svg＞元素而言，它的 localName 是&rdquo;svg&rdquo;， tagName 是&rdquo;s : svgh, namespaceURI 是&rdquo;http: / Z<a href="http://www.w3">www.w3</a> . org/2000/svg&rdquo;,而 prefix 是1• stt o</p>

<p>D0M3级在此基础上更进一步，又引入了下列与命名空间有关的方法。</p>

<p>□ isDefaultNamespace (namespaceURI):在指定的 namespaceC7/?J 是当前节点的默认命名空 间的情况下返回true。</p>

<p>□    lookupNamespaceURI (prefix):返回给定 prefix 的命名空间。</p>

<p>□    lookupPre fix (namespaceURI):返问给定 namespaceURI 的前缀。</p>

<p>针对前面的例子，可以执行下列代码：</p>

<p>alert(document-body.isDefaultNamespace(&rdquo;<a href="http://www.v/3.org/1999/xhtml%22">http://www.v/3.org/1999/xhtml&rdquo;)</a>%ef%bc%9b)<a href="http://www.v/3.org/1999/xhtml%22">；</a>%ef%bc%9b) //true</p>

<p>/ /假设svg中包合着对＜3: svg＞的？I用</p>

<p>alert{svg.lookupPrefix{&rdquo;<a href="http://www.w3.org/2000/svg%22">http://www.w3.org/2000/svg&rdquo;))</a>)%ef%bc%9b)<a href="http://www.w3.org/2000/svg%22">；</a>)%ef%bc%9b) /&rdquo; s&rdquo;</p>

<p>alert(svg.lookupNamespaceURI(&ldquo;s&rdquo;)); //&rdquo;<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>&ldquo;</p>

<p>在取得了一个节点，但不知道该节点与文档其他元素之间关系的情况下，这些方法是很有用的=</p>

<p>\2.    Document类型的变化</p>

<p>DOM2级中的Document类型也发生了变化，包含了下列与如名空间有关的方法。</p>

<p>□    createElementNS (namespace(7}?I? tagName):使用给定的 tagWa/ne 创建一个属于命名空 间namespaceURI的新元素。</p>

<p>□    createAttributeNS (namespaceURIf attribuLeName):使川给定的 attributeName 建一个属于命名空间namespaceURI的新特性。</p>

<p>□    getElementsByTagNameNS (namespaceURI/ tagName}:返问属于命名空间 的 tagName 元素的 NodeList。</p>

<p>使用这些方法时需要传人表示命名空间的URI (而不是命名空间前缀)，如下面的例子所示。</p>

<p>//创建一个新的SVG元索</p>

<p>var svg = document.createElementNS(&rdquo;<a href="http://www.w3.org/2000/svg%22z%22svg">http://www.w3.org/2000/svg&rdquo;z&rdquo;svg</a>&rdquo;);</p>

<p>/ /创建一个属于某个命名空间的新特性</p>

<p>var att = document .createAttributeNS (&ldquo;<a href="http://www">http://www</a>. somewhere.com1&rsquo;, &ldquo;random&rdquo;);</p>

<p>//取得所有XHTML元素</p>

<p>var elems = document .getElementsByTagNameNS (&ldquo;http： //<a href="http://www.w3">www.w3</a> .org/1999/xhcml,&rsquo; # &ldquo; *&ldquo;)；</p>

<p>只有在文档中存在两个或多个命名空间时，这些与命名空间有关的方法才是必需的。</p>

<p>\3.    Element类型的变化</p>

<p>“DOM2级核心”中有关Element的变化，主要涉及操作特性。新增的方法如下。</p>

<p>□    getAttributeNS (namespaceURI, localName):取得属于命名空间 namespaceURI 且名为 localName 的特性。</p>

<p>□    getAttributeNodeNS (namespaceURI, localName):取得属于命名空间 namespaceURI 名为localName的特性节点。</p>

<p>□    getElementsByTagNameNS (namespaceURI, tagName):返回属于命名空间 name印dcetZHI 的 tagName 兀素的 NodeList。</p>

<p>□    hashttributeVlS (namespaceURI, localName):确定当前元素是否有一个名为 localNajne 的特性，而且该特性的命名空间是namespaces Jo注意，“DOM2级核心”也增加了一个 hasAttributeO方法，用于不考虑命名空间的情况。</p>

<p>□    removeAttriubteNS (namespaceURI, localName):删除属于命名空间 namespacelTRI 且名 为2oca2_Wawie的特性。</p>

<p>□    set AC t r ibuteNS (namespaceCZRJ, qualifiedNaine, value):设置 W 于命名空间 namespace-URI且名为qualifiedNAme的特性的值为valueo</p>

<p>□    setAttributeNodeNS(attNode):设置属于命名空间 namespaceURI 的特性节点。</p>

<p>除了第一个参数之外，这些方法与DOM1级中相关方法的作用相同；第一个参数始终都是一个命 名空间URI。</p>

<ol>
<li>NamedNodeMap类型的变化</li>
</ol>

<p>NamedNodeMap类型也新增了下列与命名空间有关的方法。由于特性是通过NamedNodeMap表示 的，㈥此这些方法多数情况下只针对特性使用。</p>

<p>□    getNamedltemNS (nainespaceURI, localName):取得属于命名空间 namespaceURI 且名为 local Name 的项 o</p>

<p>□    r emoveNamedl t emNS (name spa ce UR I, localName):移除属于命名空间 namespa ceURI 且名 为 localName 的项。</p>

<p>□    setNamedltemNS (node):添加node,这个节点已经事先指定了命名空间信息。</p>

<p>由于一般都是通过元素访问特性，所以这些方法很少使用。</p>

<p>12.1.2其他方面的变化</p>

<p>DOM的其他部分在“DOM2级核心”中也发生了一些变化。这些变化与XML命名空间无关，而是 更倾向于确保API的可靠性及完整性。</p>

<p>\1.    Document Type类型的变化</p>

<p>DocuraenCType 类型新增了 3 个属性：publicld、systemld 和 internalSubset。其中，前两 个属性表示的是文档类逛声明中的两个信息段，这两个信息段在DOM1级中是没有办法访问到的。以 下面的HTML文档类型声明为例。</p>

<p>&lt;:DOCTYPE HTML PUBLIC &ldquo;-Z/W3C//DTD HTML 4.01//EN&rdquo;</p>

<p>&ldquo;<a href="http://www.w3，org/TR/html4/strict.dtd*&gt;">http://www.w3，org/TR/html4/strict.dtd*&gt;</a></p>

<p>对这个文档类型声明而言，publicld是//W3C//DTD HTML 4.01//EN■，而 systemld是 //<a href="http://www.w3.org/TR/html4/strict.dtd-%e3%80%82%e5%9c%a8%e6%94%af%e6%8c%81DOM2%e7%ba%a7%e7%9a%84%e6%b5%8f%e8%a7%88%e6%92%b0%e4%b8%ad%ef%bc%8c%e6%88%90%e8%af%a5%e5%8f%af%e4%bb%a5%e8%bf%90%e8%a1%8c%e4%b8%8b%e5%88%97%e4%bb%a3%e7%a0%81%e3%80%82">www.w3.org/TR/html4/strict.dtd-</a><a href="http://www.w3.org/TR/html4/strict.dtd-%e3%80%82%e5%9c%a8%e6%94%af%e6%8c%81DOM2%e7%ba%a7%e7%9a%84%e6%b5%8f%e8%a7%88%e6%92%b0%e4%b8%ad%ef%bc%8c%e6%88%90%e8%af%a5%e5%8f%af%e4%bb%a5%e8%bf%90%e8%a1%8c%e4%b8%8b%e5%88%97%e4%bb%a3%e7%a0%81%e3%80%82">。在支持DOM2级的浏览撰中，成该可以运行下列代码。</a></p>

<p>alert(document.doctype.publicld)； alert(document.doctype.systemld)；</p>

<p>实际上，很少需要在网页中访问此类倍息。</p>

<p>最后一个属性internalSubset,用于访问包含在文档类型声明中的额外定义，以下面的代码为例。</p>

<p>&lt;!DOCTYPE html PUBLIC &ldquo;-//W3C//DTD XHTML 1.0 Strict//EN&rdquo;</p>

<p>&ldquo;<a href="http://www.w3.org/TR/xhtmll/DTD/xhtmll-strict.dtd">http://www.w3.org/TR/xhtmll/DTD/xhtmll-strict.dtd</a>&ldquo;</p>

<p>(&lt;!ELEMENT name (#PCDATA)&gt;] &gt;</p>

<p>访问 document.doctype. internalSubset 将得到&rdquo;&lt;! ELEMENT name (#PCDATA) &gt;&ldquo;o 这种内部 子集(internal subset)在HTML中极少用到，在XML中可能会更常见一些。</p>

<p>\2.    Document类型的变化</p>

<p>Document类型的变化中唯一与命名空间无关的方法是importNode () o这个方法的用途是从一个 文档中取得一个节点，然后将其导人到另一个文档，使其成为这个文档结构的-部分。需要注意的是， 每个节点都冇-个ownerDocument属性，表示所属的文档。如果调用aE&gt;pendChild()时传人的节点 域于不同的文档(ownerDocument属性的值不一样)，则会导致错误。但在调用importNode ()时传人 不同文捫的节点则会返回一个新节点，这个新节点的所有权归当前文档所有。</p>

<p>说起来，importNode (&gt;方法与Element的cloneNode(&gt;方法非常相似，它接受两个参数：要复</p>

<p>制的节点和一个表示是否复制子节点的布尔值。返回的结果是原来节点的副木，但能够在当前文档中使 用。来看下面的例子：</p>

<p>var newNode = document. importNode (oldNodG, true) ? //导入节点及其所有子节点 document.body.appendChild(newNode)；</p>

<p>这个方法在HTML文档中并不常用，在XML文档中用得比较多(更多讨论请参见第18章)。</p>

<p>“DOM2级视图”模块添加了一个名为defaultView的属性，其中保存着一个指针，指向拥有给 定文档的窗口(或框架)。除此之外，“视图”规范没有提供什么时候其他视图可用的信息，因而这是唯 一一个新增的屈性。除IE之外的所有浏览器都支持defaultView属性。在IE中有一个等价的厲性名 叫parentWindovUOpera也支持这个属性)。因此，要确定文档的归属窗口，可以使用以下代码，</p>

<p>var parentWindow = document.defaultView I| document.parentWindow；</p>

<p>除了上述一方法和一个属性之外，“DOM2级核心”还为document. implementation对象规定了 两个新方法：createDocumentType ()和 createDocument {) o 前者用于创建一个新的 DocumentType 节点，接受3个参数：文档类型名称、publicld、sysfcemldo例如，下列代码会创建斗新的HTML 4.01 Strict文档类型c</p>

<p>var doctype = document.implementation.createDocumentType(&ldquo;html&rdquo;,</p>

<p>&rdquo;-//W3C//DTD HTML 4.01//EN*1,</p>

<p>&ldquo;http: //<a href="http://www.w3">www.w3</a> . org/TR/htinl4/strict .dtd11);</p>

<p>由于既有文档的文杜类瑚不能改变，因此createDocumentType ()只在创逮新文档时布用；创建 新文钓时需要用到creatcDocumcnt ()方法。这个方法接受3个参数：针对文档中元素的namesp， aceURI ,文档元素的标签名、新文档的文档类型。下面这行代码将会创建一个空的新XML文梢。</p>

<p>var doc = document.implementation.createDocument(■&rdquo;, &ldquo;root&rdquo;, null);</p>

<p>这行代码会创建一个没有命名空间的新文档，文档元素为＜rOOt＞,而且没有指定文档类型。要想 创建一个XHTML文档，可以使用以下代码。</p>

<p>var doctype = document•implementation.createDocumentType(&ldquo;html&rdquo;,</p>

<p>•| -//W3C//DTD XHTML 1.0 Strict//ENB,</p>

<p>&ldquo;http: / /www. w3 .org/TR/xhtmll/DTD/xh.tml 1-strict .dtd&rdquo;);</p>

<p>var doc = document.implementation.createDocument(&ldquo;http：//www.w3.org/1999/xhtml&rdquo;, &ldquo;html&rdquo;, doctype);</p>

<p>这样，就创建了一个带有适当命名空间和文档类型的新XHTML文挡。不过，新文档当前只有文档 元素剩下的所有元素都需要继续添加。</p>

<p>“DOM2 级 HTML&rdquo;模块也为 document. implementation 新增 了一个方法，名叫 createHTML-Document ()。这个方法的用途是创建&rsquo; •个完整的HTML文档，包括＜html＞、＜head＞、＜title;^U ＜body＞元素。这个方法只接受一个参数，即新创建文档的标题(放在元素中的字符串)，返回 新的HTML文档，如下所示：</p>

<p>var htmldoc = document.implementation.createHTKLDociwent(&ldquo;New Doc&rdquo;)； alert(htmldoc.title)；    //&ldquo;New Doc，</p>

<p>alert(typeof htmldoc.body);    //&ldquo;object&rdquo;</p>

<p>CreateHTMLDocumentExample. htm</p>

<p>通过调用createHTMLDocximent ()创建的这个文，是HTMLDocument类型的实例，因而具有该 类型的所有属性和方法，包括title和body属性。只有Opera和Safari支持这个方法。</p>

<p>\3. Node类型的变化</p>

<p>Node类型中唯一与命名空间无关的变化，就是添加了 isSupported(}方法。与DOM1级为document. implementation引人的hasFeature ()方法类似，isSupported()方法用于确定当前节点具有 什么能力。这个方法也接受相同的两个参数：特性名和特性版本号。如果浏览器实现了相应特性，而且 能够基于给定节点执行该特性，isSupported()就返回true。来看一个例子：</p>

<p>if (document.body.isSupported(&ldquo;HTML&rdquo;, &ldquo;2.0*)}{</p>

<p>//执行只有-DOM2级HTML•才支持的操作</p>

<p>)</p>

<p>由于不同实现在决定对什么特性返回true或false时并不一致，这个方法同样也存在与hasFeature {) 方法相同的问题。为此，我们建议在确定某个特性是否可用时，最好还是使用能力检测。</p>

<p>DOM3级引人了两个辅助比较节点的方法：isSameNode{)和isEqualNodeU。这两个方法都接受 一个节点参数，并在传人节点与引用的节点相同或相等时返冋true。所谓相同，指的是两个节点引用的 是同一个对象。所谓相等，指的是两个节点是相同的类型，具有相等的属性(nodeName、nodeValue, 等等)，而且它们的attributes和childNodes属性也相等(相同位S包含相同的值)。来看一个例子。</p>

<p>var divl = document-createElement(&ldquo;div&rdquo;); divl.setAttribute(&ldquo;class&rdquo;, &ldquo;box&rdquo;);</p>

<p>var di.v2 = document. createElement (&ldquo;div&rdquo;): div2.setAttribute(&ldquo;class&rdquo;, &ldquo;box*)；</p>

<p>alert(divl.isSameNode(divl))； //true alert(divl.isEquaINode(div2))； //true alert(divl.isSameNode(div2)); //false</p>

<p>这里创建了两个具有相同特性的＜div＞元素。这两个元素相等，但不相同。</p>

<p>DOM3级还针对为DOM节点添加额外数据引人了新方法。其中，setUserDacaO方法会将数据指</p>

<p>定给节点，它接受3个参数：要设置的键、实际的数据(可以是任何数据类型)和处理函数。以下代码 可以将数据指定给一个节点。</p>

<p>document.body.setUserData{&ldquo;name&rdquo;, ”Nicholas&rdquo;, function(》{} };</p>

<p>然后，使用getUserDataU并传人相同的键，就可以取得该数据，如下所示：</p>

<p>var value = document.body.getUserData(&ldquo;naxe&rdquo;);</p>

<p>传人setUserData()中的处理函数会在带有数据的节点被复制、删除、重命名或引人一个文档时 调用，因而你可以事先决定在上述操作发生时如何处理用户数据。处理函数接受5个参数：表示操作类 型的数值(1表示复制，2表示导人，3表示删除，4表示重命名)、数据键、数据值、源节点和目标节 点。在删除节点时，源节点是null;而在复制节点时，口标节点是null。在函数内部，你可以决定如 何存储数据。来看下面的例子。</p>

<p>var div = document.createElement(&ldquo;div&rdquo;);</p>

<p>div .setUserData (&ldquo;name**, &ldquo;Nicholas&rdquo;, function (operation, key, value, src, dest) { if (operation == 1){</p>

<p>dest.setUserData(key, value, function(J{});    )</p>

<p>})；</p>

<p>var newDiv = div.cloneNode(true);</p>

<p>alert{newDiv.getUserData(&ldquo;name&rdquo;))；    //&ldquo;Nicholas</p>

<p>UserDataExample.htm</p>

<p>这里，先创建了 jh＜div＞元素，然后又为它添加了一些数据(用户数据)。在使用cloneNodeO 复制这个元素时，就会调用处理函数，从而将数据ft动复制到了副本节点。结果在通过副本节点调用 getUserData ()时，就会返回与原始节点中包含的相同的值c</p>

<p>4.框架的变化</p>

<p>梢架和内嵌框架分别用HTMLFrameEleraent和HTMLIFrameElement表不,它们在DOM2级中都有 了一个新属性，名叫contentDocument。这个属性包含•-个指针，指向表zf;框粱内容的文档对象。在此 之前，无法6:接通过元素取得这个文档对象(只能使用frames集合)。可以像下面这样使用这个属性。</p>

<p>、 var i frame =： document .get ElementBy Id (&ldquo;my I frame&rdquo;)；</p>

<p>f var ifraineDoc = if rame. content Document;    //在 IE8 以前的版本中无效</p>

<p>IFrameElementExample. htm</p>

<p>由于content Document属性是Document类型的实例，因此可以像使用其他HTML文档一样使 用它，包括所有厲性和方法。Opera、Hrefox、Safari和Chrome支持这个属性。IE8之前不支持框架中 的contencDocument属性，但支持一个名叫contentWinaow的賊性，该属性返M框架的window对 象，而这个window对象又有一个document属性。因此，要想在上述所有浏览器中访问内嵌框架的文 档对象，可以使用下列代码。</p>

<p>var iframe = document.getElementById(&ldquo;mylframe&rdquo;);</p>

<p>var iframeDoc = iframe.contentDocument II iframe.contentWindow.document;</p>

<p>lFrameElementExample2. htm</p>

<p>所有浏览器都支持contentWindow属性。</p>

<p>访问框架或内嵌框架的文档对象要受到跨域安全策略的限制。如果某个框架中的 页面来自其他域或不同子域，或者使用了不同的协议，那么要访问这个框架的文档对 象就会导致错误。</p>

<p>12.2样式</p>

<p>在HTML中定义样式的方式有3种：通过＜link/:＞元素包含外部样式表文件、使用＜style/：＞元素 定义嵌人式样式，以及使用style特性定义针对特定元素的样式。“DOM2级样式&rdquo;模块围绕这3种应用 样式的机制提供了•一套API。要确定浏览器是杏支持DOM2级定义的CSS能力，可以使用下列代码。</p>

<p>var support sD0M2 CSS = document. implementation, has Feature (HCSS&rdquo;, &ldquo;2.0”； var supportsDOM2CSS2 = document.implementation.hasFeature(&ldquo;CSS2&rdquo;,    &ldquo;2.0*);</p>

<p>12.2.1访问元素的样式</p>

<p>任何支持style特性的HTML元素在JavaScript屮都有&rsquo;一^对应的style属性。这个style对象 是CSSStyleDeclaration的实例，包含着通过HTML的style特性指定的所有样式位息，但不包含 与外部样式表或嵌人样式表经层叠而来的样式。在style特性中指定的任何CSS属性都将表现为这个 style对象的相应属性。对于使用短划线(分隔不同的词汇，例如background-image )的CSS属性 名，必须将艿转换成驼峰大小写形式，才能通过JavaScript来访问。下表列出了几个常见的CSS属性及 其在style对象中对应的属性名。</p>

<table>
<thead>
<tr>
<th>cssn性</th>
<th>JavaScript 厲性</th>
</tr>
</thead>

<tbody>
<tr>
<td>background-image</td>
<td>style.backgroundImage</td>
</tr>

<tr>
<td>color</td>
<td>style.color</td>
</tr>

<tr>
<td>display</td>
<td>style, display</td>
</tr>

<tr>
<td>font-family</td>
<td>style. font Family</td>
</tr>
</tbody>
</table>

<p>多数情况下，都可以通过简单地转换属性名的格式来实现转换。其中一个不能直接转换的CSS属性 就是float。由于float是JavaScript中的保留字，因此不能用作属性名。“D0M2级样式”规范规定 样式对象上相应的属性名应该是cssFloat; Firefox、Safari、Opera和Chrome都支持这个属性，而IE 支持的则是styleFloato</p>

<p>只要取得一个有效的DOM元素的引用，就可以随时使用JavaScript为其设置样式。以下是几个例子。 var myDiv = document •getElementById( •myDiv&rdquo;) ,•</p>

<p>//设置背素顏色</p>

<p>myDiv.style.backgroundedor = &ldquo;red&rdquo;;</p>

<p>//改变大小</p>

<p>myDiv. style .width = &ldquo; lOOpx&rdquo;； myDiv.style.height = ■200px*;</p>

<p>//指定边框</p>

<p>myDiv.style.border = &ldquo;lpx solid black&rdquo;;</p>

<p>在以这种方式改变样式时，元素的外观会自动被更新。</p>

<p>在标准模式下，所有度量值都必须指定一个度量单位。在混杂模式下，可以将 style .width设置为&rdquo;20*,浏览器会假设它是&rdquo;20px-;但在标准模式下，将</p>

<p>style.width设置为&rdquo;20•会导致被忽略-因为没有度量单位。在实践中，最好始</p>

<p>终都指定度量单位。</p>

<p>通过style对象同样可以取得在style特性中指定的样式。以下面的HTML代码为例。 <div id="myDiv" style="background-color:blue； width：lOpx； height:25px"></div> 在style特性中指定的样式信息可以通过下列代码取得。</p>

<p>alert(myDiv.style.backgroundColor)；    //&ldquo;blue&rdquo;</p>

<p>alert(myDiv.style.width)；    //■10px-</p>

<p>alert(myDiv.style-height);    //&ldquo;25px&rdquo;</p>

<p>如果没有为元素设肾style特性，那么style对象屮可能会包含一独默认的值，但这残值并不能 准确地反映该元素的样式信息。</p>

<p>1.DOM样式属性和方法</p>

<p>“DOM2级样式&rdquo;规范还为style对象定义了一些属性和方法。这些属性和方法在提供元素的style 特性值的同时，也可以修改样式。下面列出了这些属性和方法。</p>

<p>□    cssText:如前所述，通过它能够访问到style特性中的CSS代码。</p>

<p>□    length：应用给元素的CSS属性的数量。</p>

<p>□    parentRule:表示CSS信息的CSSRule对象d本节后面将讨论CSSRule类型。</p>

<p>□    getPropertyCSSValue (propertyName):返冋包含给定属性值的 CSSValue 对象。</p>

<p>□    get Property Priority (propercyName):如果给定的属性使用了 ! important 设则返回 &ldquo;important&rdquo;;否则，返回空字符串。</p>

<p>□    getPropertyValue (propertyWame):返M给定属性的字符串值。</p>

<p>□    item (index):返回给定位置的CSS属性的名称。</p>

<p>□    remove Property [propertyName):从样式中删除给定属性。</p>

<p>U setProperty (propertyName, value,priority):将给定属性设置为相应的值，并加上优先 权栋志(&ldquo;important•或者一个空字符串)。</p>

<p>通过cssText属性可以访问style特性中的CSS代码。在读取模式下,cssText返回浏览器对style 特性中CSS代码的内部表示。在写入模式下，赋给cssText的值会重写整个style特性的值；也就是 说，以前通过style特性指定的样式倍息都将丢失。例如，如果通过style特性为元素设置了边框， 然后再以不包含边框的规则重写cssText,那么就会抹去元素上的边框。下面是使用cssText属性的 一个例子。</p>

<p>myDiv.style.cssText = &ldquo;width: 25px； height: lOOpx； background-color: green&rdquo;； alert(myDiv.style.cssText)；</p>

<p>设置cssText是为元素应用多项变化最快捷的方式，因为可以一次性地应用所有变化。</p>

<p>设计length属件的R的，就是将其与iteiM )方法配套使用，以便迭代在元素中定义的CSS属性。 在使用length和时，style对象实际上就相当于一个集合，都可以使用方括号语法来代替 item()来取得给定位B的CSS属性，如下面的例子所示。</p>

<p>for (var i=0, len=myDiv.style.length； i &lt; len； i++){ alert (myDiv. style [iI); //或青 myDiv. style. item(i)</p>

<p>}</p>

<p>无论是使用方括号语法还是使用item (}方法，都可以取得CSS属性名(&ldquo;background-color&rdquo;, 然后，就可以在getPropertyValue ()中使用了取得的屈性名进一步取</p>

<p>得属性的值，如下所示。</p>

<p>var prop, value, i, len;</p>

<p>for {i=0, len=myDiv.style.length; i &lt; len; i++)(</p>

<p>prop 面 myDiv. otyle [i] /    &ldquo;或:# myDiv. style. item(i)</p>

<p>value ■町Div.style.getPropertyValue(prop); alert(prop + &ldquo; ： ■+ value)；</p>

<p>}</p>

<p>getPropertyValue ()方法取得的始终都是CSS «性值的字符串表禾。如果你需要更多信息，可 以使用getPropertyCSSValue ()方法，它返回一个包含两个属性的CSSValue对象，这两个属性分</p>

<p>别是：cssText和cssValueType。其中，cssText属性的值与getPropertyValue()返网的值相同, 而cssValueType属性则是&mdash;个数值常量，表示值的类型：0表示继承的值，1表示基本的值，2表示 值列表，3表示自定义的值。以下代码既输出CSS属性值，也输出值的类型。</p>

<p>var prop, value, i, len;</p>

<p>for (i=0z len=myDiv.style.length; i &lt; len； i++){</p>

<p>prop = myDiv. style [i]; //或老 myDiv. style .item (i)</p>

<p>value = wyDiv.style.getPropertyCSSValue(prop)/</p>

<p>alert(prop + &ldquo; : ■ + value.cssText + ■ (&rdquo; + value.cosValueType + &ldquo;)’)；</p>

<p>)</p>

<p>DOMStyleObjectExample. htm</p>

<p>在实际开发中，getPropertyCSSValue&lt;）使用得比 getPropertyValue （）少得多。IE9+、Safarie 3+以及Chrome支持这个方法。Firefox 7及之前版本也提供这个访问，但调用总返回nul 1。</p>

<p>要从元素的样式中移除某个CSS属性，需要使用removePropertyO方法。使用这个方法移除一 个属性，意味着将会为该属性应用默认的样式（从其他样式表经层叠而来）。例如，要移除通过style 特性设置的border属性，可以使用下面的代碑。</p>

<p>myDiv.style.removeProperty（&rdquo;border&rdquo;）；</p>

<p>在不确定某个给定的css属性拥有什么默认值的情况下，就可以使用这个方法。只要移除相应的属 性，就可以为元素应用默认值。</p>

<p>除非另有说明，本节讨论的属性和方法都得到了 IE9+, Firefox、Safari、Opera9+ 以及Chrome的支持。</p>

<p>2.计算的样式</p>

<p>虽然style对象能够提供支持style特性的任何元素的样式信息，但它不包含那些从其他样式表 层叠而来并影响到当前元素的样式信息。“DOM2级样式”增强了 document.defaultView,提供了 getComputedStylef）方法。这个方法接受两个参数：要取得计算样式的元素和一个伪元素字符串（例 如&rdquo;：after-）。如果不需要伪元素信息，第二个参数可以是null。getComputedStyle （&gt;方法返回一 个CSSStyleDeclaration对象（与style属性的类型相同），其巾包含当前元素的所有计算的样式。 以下面这个HTML页面为例。</p>

<p>&lt;!DOCTYPE html&gt;</p>

<p><html></p>

<p><head></p>

<p><title>Computed Styles Example<Ztitle></p>

<style type=”text/css">

\#myDiv {

background color: blue； width： lOOpx； height: 200px；

}

</style>

<p></head></p>

<p><body></p>

<div id="myDiv" style=’background-color: red； border: lpx solid black*></div>

<p></body></p>

<p>ComputedStylesExample. htm</p>

<p>316 第 12 章 D0M2 和 D0M3</p>

<p>应用給这个例子中＜div＞元素的样式一方面来自嵌人式样式表(＜style＞兀素中的样式)，另一方 面來自其style特性。但是，style特性中设S了 backgroundColor和border，没有设凭width 和height,后者是通过样式表规则应用的。以下代码可以取得这个元素计算后的样式。</p>

<p>var myDiv = document .getsElementBy 工d (* my Di v&rdquo;);</p>

<p>var computedStyLe = document.defaultView.getComputedStyle(myDiv, null);</p>

<p>alert(computedStyle.backgroundColor)；    //    &ldquo;red”</p>

<p>alert(computedStyle.width)；    //    &ldquo;100pxrt</p>

<p>alert(computedStyie.height);    //    &ldquo;200px&rdquo;</p>

<p>alert (computedStyle.border) ;    //    在某些浏 JL器中是ulpx. solid black&rdquo;</p>

<p>ComputedStylesExample. htm</p>

<p>在这个元索H嘴后的样式中，背景颜色的值是-red-,宽度值是■lOOpx，，髙度值是QOOpx%我 们注意到，背景颜色不是-blue-,因为这个样式在自身的style特性中已经被覆盖了。边框属性可能 会也可能不会返回样式表中实际的border规则（Opera会返回，但其他浏览器不会）。存在这个差别的 原因是不同浏览器解释综合（rollup ）属性（如border）的方式不同，因为设置这种属性实际上会涉及 很多其他属性。在设置border时，实际上是设置了四个边的边框宽度、颜色、样式属性 （border-left - width、border-top-color、border-bottom-style ,等等）o 因此，.即使 computedS- tyle.border 不会在所有浏览器巾都返回值，但 computedStyie.borderLeftwidth 则会返回值。</p>

<p>需要注意的是，即使有些浏览器支持这种功能，但表示值的方式可能会有所区别C &lsquo;例如，Fkefox和Safari会将所有顏色转换成RGB格式（例如红色是rgb&lt;255,0，0} ）c</p>

<p>因此，在使用getComputedStyle （）方法时，嚴好多在几种浏览器中測试一下6</p>

<p>IE不支持getComputedStyle （）方法，但它有一种类似的概念。在IE中，每个具冇style属性 的元素还有一个currentStyle属性。这个属性是CSSStyleDeclaration的实例，包含当前元索全 部计算后的样式。取得这些样式的方式也差不多，如下面的例子所示。</p>

<p>var myDiv = document.getEiementByld(&ldquo;myDiv&rdquo;);</p>

<p>var computedStyie » myDiv.currentStyle;</p>

<p>alert(computedStyie.backgroundColor);    //&ldquo;red&rdquo;</p>

<p>alert(computedStyie.width)；    //&ldquo;100pxM</p>

<p>alert(computedStyie.height);    //&ldquo;200px&rdquo;</p>

<p>alert(computedStyie.border);    //undefined</p>

<p>IEComputedStyles Example, htm</p>

<p>与DOM版本的方式一样，IE也没有返回border样式，因为这是一个综合属性。</p>

<p>无论在哪个浏览器中，呆ffi要的一条是要记住所有计算的样式都是只读的；不能修改计算后样式对</p>

<p>象中的CSS属性。此外.计算后的样式也包含属于浏览器内部样式表的样式信息，因此任何具衣默认值 的CSS属性都会表现在计算后的样式中。例如，所有浏览器中的visibility属性都冇-个默认值， 但这个值会因实现而异。在默认情况下，有的浏览器将visibility属性设置为-visible&rsquo;而有的 浏览器则将其设置为-inherit%换句话说，不能指望某个CSS域性的默认值在不同浏览器中是相同 的。如果你需要元素具有某个特定的默认值，应该手工在样式表中指定该值。12.2.2操作样式表</p>

<p>CSSStyleSheet类型表示的是样式表，包括通过＜link＞元索包含的样式表和中定义 的样式表。有读者可能记得，这两个元素本身分别是由HTMLLi&rsquo;nkElement和HTMbStyleElement类型 表示的。但是，CSSStyleSheet类塑相对更加通用-些，它只表示样式表，而不管这些样式表在HTML 中是如何定义的。此外，上述两个针对元素的类型允许修改》TML特性，但CSSStyleSheet对象则是一 套只读的接口(有一个属性例外)。使用下面的代码可以确定浏览器是否支持DOM2级样式表。</p>

<p>var supportSD0M2Stylesheets =</p>

<p>document.implementation.hasFeature(&ldquo;Stylesheets&rdquo;x &ldquo;2.0&rdquo;)?</p>

<p>CSSStyleSheet继承自Stylesheet,后者可以作为一个基础接门来定义非CSS样式表。从 Stylesheet接口继承而来的属性如下。</p>

<p>□    disabled:丧示样式表是否被禁用的布尔值。这个属性是可读的，将这个值设置为true可 以禁用样式表。</p>

<p>□    href：如果样式表挂通过＜link＞;fe含的，则是样式表的URL;否则，是null。</p>

<p>□    media：当前样式表支持的所有媒体类型的集合。与所有DOM集合一样，这个集合也有一个 length®性和一个item()方法。也可以使用方括号语法取得集合中特定的项。如果集合是空 列表，表示样式表适用于所有媒体。在IE中，media是■—个反映＜link;^＜style＞元素media 特性值的字符串。</p>

<p>□    ownerNode：指向拥有当前样式表的节点的指针，样式表可能是在HTML中通过＜1^)＜＞或 ＜styie/＞引人的(在XML中可能是通过处理指令引人的)。如果当前样式表是其他样式表通过 @import?导人的，则这个属性值为null。IE不支持这个屈性。</p>

<p>U parentStyleSheet:在当前样式表是通过@import导人的情况下，这个属性是一个指向导人 它的样式表的指针=</p>

<p>□    title： ownerNode 中 title W性的俄。</p>

<p>□    type:表示样式表类型的字符串。对CSS样式表而言，这个字符奉是&rdquo;type/css&rdquo;。</p>

<p>除了 disabled属性之外，其他属性都是只读的。在支持以上所有这些属性的基础上， CSSStyleSheet类型还支持下列属性和方法：</p>

<p>□    cssRules：样式表中包含的样;iS；规则的粱合。IE不支持这个诚性，但有一个类似的rules属性。</p>

<p>□    ownerRule：如果样式表是通过@import导人的，这个属性就是一个指针，指向表示导人的规 则；否则，值为null。IE不支持这个属性。</p>

<p>□    deleteRule( index):删除cssRules集合中指定位置的规则。IE不支持这个方法，但支持 一&rdquo;l&rsquo;类似的 removeRule ()方法。</p>

<p>□    insertRule (ru_io, index):向cssRules集合中指定的位置插人字符申。IE不支持这 个方法，但支持一个类似的addRule ()方法。</p>

<p>应用于文档的所有样式表是通过document, stylesheets集合来表示的。通过这个集合的length 厲性可以获知文杓屮样式表的数ft,而通过方括号语法或item ()方法可以访问每一个样式表。來看一个 例子。</p>

<p>var sheet = null;</p>

<p>for (var i=0, len=document.sty 1 eSheets..length; i ＜ len； i++) {</p>

<p>sheet = document.stylesheets[i]; alert(sheet.href);</p>

<p>StyleSheetsExample. htm</p>

<p>以上代码可以输出文档中使用的每一个样式表的href属性（＜31^1^＞元素包含的样式表没有 href属性）。</p>

<p>不同浏览器的document. stylesheets返回的样式表也不同。所有浏览器都会包含＜style＞元索 和rel特性被设置为-stylesheet11的＜link〉元素引入的样式表。1E和Opera也包含rel特性被设置为 &ldquo;alternate stylesheet&rdquo;的＜link＞元索引人的样式表。</p>

<p>也可以直接通过＜11111＜＞或＜31¥16＞元素取得CSSStyleSheet对象。DOM规定了一个包含 CSSStyleSheet对象的属性，名叫sheet;除了 IE,其他浏览器都支持这个属性。IE支持的是 stylesheet属性。要想在不同浏览器中都能取得样式表对象，可以使用下列代码。</p>

<p>function getStyleSneet（element）（</p>

<p>return element.sheet II element.stylesheet;</p>

<p>}</p>

<p>//取锊苐一个＜link/＞元索41入的样式表</p>

<p>var link = document.getElementsByTagName(&ldquo;link&rdquo;)[0]; var sheet = getStylesheet{link)?</p>

<p>StyleSheetsExample2. htm</p>

<p>这里的getStylesheet （＞返的样式衷对象与document. styleSheets集合中的样式表对象相同。</p>

<p>1.CSS规则</p>

<p>CSSRule对象表示样式表中的毎一条规则。实际上，CSSRule是一个供其他多种类型继承的基类 型，其屮披常见的就是CSSStyleRule类型，表示样式信息（其他规则还有@import、@font-face、 0page但这狴规则很少有必要通过脚本来访问）。CSSStyleRule对象包含下列属性。</p>

<p>□    cssText:返回整条规则对应的文本。由于浏览器对样式表的内部处理方式不同，返回的文本 可能会与样式表中实际的文本不一样；Safari始终都会将文本转换成全部小写。1E不支持这个 属性。</p>

<p>□    parentRule：如果当前规则是导人的规则，这个属性引用的就是导人规则；否则，这个值为 null。IE不支持这个属性。</p>

<p>□    parentStyleSheet:当前规则所属的样式表。正不支持这个属性。</p>

<p>□    solcctorText：返回当前规则的选择符文本。由于浏览器对样式表的内部处理方式不同，返回 的文本呵能会与样式表中实际的文本不-样（例如，Safari 3之前的版本始终会将文本转换成全 部小写）。在Firefox、Safari、Chrome和IE中这个厲性是只读的。Opera允许修改selectorText。</p>

<p>□    style： 一个CSSStyleDeclaration对象，可以通过它设置和取得规则中特定的样式值。</p>

<p>□    type：表示规则类瑠的常量值。对于样式规则，这个值是1。IE不支持这个属性。</p>

<p>其中二个最常用的屈性是 cssText、selectorText 和 style。cssText 厲性与 style.cssText 厲性类似，也并不相同。前者包含选择符文本和围绕样式信息的花括号，后者只包含样式信息（类似于 元素的style.cssText ）。此外，cssText是只读的，而style.cssText也可以被重写。</p>

<p>大多数情况下，仅使用style属性就可以满足所有操作样式规则的需求了。这个对象就像每个元 素上的style属性-样，可以通过它读取和修改规则中的样式信息。以下面的CSS规则为例。</p>

<p>div.box {</p>

<p>background-color： blue； width: lOOpx; height: 200px；</p>

<p>}</p>

<p>CSSRulesExample. htm</p>

<p>假设这条规则位于页面中的第一个样式表中，而且这个样式表中只有这一条样式规则，那么通过下 列代码可以取得这条规则的各种信息。</p>

<p>var sheet = document.stylesheets(0]； var rules = sheet.cssRules I I sheet.rules? var rule = rules[0];</p>

<p>//取铒规则列表 &ldquo;取锊第一条规则</p>

<p>//&ldquo;div.box&rdquo;</p>

<p>//完整的CSS代码 //&ldquo;blue&rdquo; //&ldquo;100px&rdquo; //■200px&rdquo;</p>

<p>alert(rule.selectorText);</p>

<p>alert(rule.style.cssText);</p>

<p>alert(rule.style.backgroundColor)；</p>

<p>alert(rule.style.width)；</p>

<p>alert(rule.style.height);</p>

<p>CSSRulesExample. htm</p>

<p>使用这种方式，可以像确定元素的行内样式信息一样，确定与规则相关的样式信息。与使用元素的 方式&ndash;样，在这种方式下也可以修改样式信息，如下面的例子所示。</p>

<p>var sheet = document.styleSheets(0］；</p>

<p>var rules = sheet. cssRules II sheet ♦ rules；    //取拜規则列表</p>

<p>var rule = rules (0J;    //取得第一条規则</p>

<p>rule.style.backgroundColor - &ldquo;red&rdquo;</p>

<p>CSSRulesExample. htm</p>

<p>必须要注意的是，以这种方式修改规则会影响贞面中适用于该规则的所有元素。换句话说，如果有 两个带有box类的＜div＞元素，那么这两个元素都会应用修改后的样式。</p>

<p>2.创建规则</p>

<p>DOM规定，要向现有样式表中添加新规则，需要使用insertRuleU方法。这个方法接受两个参 数：规则文木和表示在哪里插人规则的索引。下面是一个例子。</p>

<p>sheet. insertRule (&ldquo;body { background-color: silver }•, 0) ； //DOM 方法</p>

<p>这个例子插人的规则会改变元素的背景颜色。插入的规则将成为样式表中的第一条规则(插人到了</p>

<p>位S 0 )-规则的次序在确定屋叠之后应用到文档的规则时至关重要。Firefox、Safari、Opera和Chrome</p>

<p>都支持insertRule ()方法。</p>

<p>IE8及更早版本支持一个类似的方法，名叫addRuleO ,也接收两必选参数：选择符文本和CSS 样式信息；一个可选参数：插人规则的位置,，在IE中插入与前面例子相同的规则，可使用如下代码。</p>

<p>sheet. addRu 1 e {&rdquo; body&rdquo;, * background-color: silver&rdquo;, 0) ； //仅对 IE 有效</p>

<p>有关这个方法的规定中说，最多可以使用addRuleO添加4 095条样式规则。超出这个上限的调用 将会导致错误。</p>

<p>耍以垮浏览器的方式向样式表中插人规则，可以使用下面的函数„这个函数接受4个参数：要向其 中添加规则的样式表以及与addRuleO相同的3个参数，如下所示。</p>

<p>I;</p>

<p>function insertRule&lt;sheet, selectorText, cssText, position){ if (sheet.insertRule){</p>

<p>position)；</p>

<p>sheet. insertRule (selectorText + • {&rdquo; + cssText 十, } else if (sheet.addRule){</p>

<p>sheet.addRule(selectorText# cssText, position)；</p>

<p>}</p>

<p>J</p>

<p>CSSRulesExample2. htm</p>

<p>下面是调用这个函数的示例代码。</p>

<p>insertRule(document.styleSheets[0], -body&rdquo;, &ldquo;background-color： silver&rdquo;r 0)；</p>

<p>虽然可以像这样来添加规则，似随着要添加规则的增多，这种方法就会变得非常繁琐。因此，如果 要添加的规则非常多，我们建议还是采用第10章介绍过的动态加载样式表的技术。</p>

<p>3.删除规则</p>

<p>从样式表中删除规则的方法是deleteRuleO,这个方法接受一个参数：要删除的规则的位置。例 如，要删除样式表中的第一条规则，可以使用以下代码„</p>

<p>sheet .deleteRule (0) ； //DOM 方法</p>

<p>IE支持的类似方法叫removeRuleO,使用方法相同，如下所示： sheet. removeRule (0);    //仅对 IE 有效</p>

<p>下面是一个能够跨浏览器删除规则的函数。第一个参数是要操作的样式表，第二个参数是要删除的 规则的索引。</p>

<p>function deleteRule(sheetr index){ if (sheet.deleteRule){</p>

<p>sheet.deleteRule(index)；</p>

<p>} else if (sheet.removeRule){</p>

<p>sheet.removeRule(index)；</p>

<p>)</p>

<p>}</p>

<p>CSSRulesExample2. htm</p>

<p>调用这个函数的方式如下。</p>

<p>deleteRule(document.stylesheets(0]z 0)?</p>

<p>与添加规则相似，删除规则也不是实际Web开发中常见的做法。考虑到删除规则可能会影响CSS 戾叠的效果，因此请大家慎重使用。</p>

<p>12.2.3元素大小</p>

<p>本节介绍的属性和方法并不厲于“DOM2级样式”规范，但却与HTML元素的样式息息相关。DOM 中没有规定如何确定页面中元素的大小。1E为此率先弓|人了一些属性，以便开发人员使用。目前，所存 主要的浏览器都已经支持这些属性。</p>

<p>1.偏移量</p>

<p>首先要介绍的届性涉及偏移量（offsetdimension）,包括元素在屏幕上占用的所有可见的空间。元素 的讨见大小由其高度、宽度决定，包括所有内边距、滚动条和边框大小（注意，不包括外边距）。通过 下列4个属性可以取得元素的偏移量。</p>

<p>□    offsetHeight:元素在垂直方向上占用的空间大小，以像素计。包括元素的髙度、（可见的） 水平滚动条的髙度、上边框髙度和下边框髙度。</p>

<p>□    offsetWidth：元索在水平方向上rf用的空间大小，以像素计。包括元素的宽度、（可见的）垂 直滚动条的宽度、左边框宽度和右边框宽度。</p>

<p>□    offsetLeft:元素的左外边框至包含元素的左内边框之间的像素距离。</p>

<p>□    offsetTop：元素的上外边框至包含元素的上内边框之间的像素距离。</p>

<p>其中，of fsetLeft和of fsetTop属性与包含元素有关，包含元索的引用保存在of fsetParent 属性中。of fsetParent厲性不一定与parentNode的值相等。例如，＜td＞元素的offsetParent是 作为其祖先元素的＜table＞元素，因为＜（;北16:＞是在DOM层次中距4（3＞最近的一个具有大小的元素。 图12-1形象地展示了上面几个属性表示的不同大小。</p>

<p>of fsetParent</p>

<p>r.&rsquo;t &lsquo; set Top</p>

<p>offsecwidth</p>

<p>图 12-1</p>

<p>要想知道某个元索在页面上的偏移鐘，将这个元索的offsetLeft和offsetTop与其of fsetParent 的相同属性相加，如此循环直至根元索，就对以得到一个基本准确的值。以下两个函数就可以用于分别 取得元索的左和上偏移量。</p>

<p>function getElementbeft(element){</p>

<p>var actualLeft = element.offsetLeft; var current = element.offsetParent;</p>

<p>while (current !== null){</p>

<p>actualLeft += current.offsetLeft; current = current.offsetParent;</p>

<p>}</p>

<p>return actualLeft；</p>

<p>function getElementTop(element){</p>

<p>var accualTop = element-offsetTopj var current = element.offsetParent;</p>

<p>while {current i=- null){</p>

<p>actualTop current. offsetTop； current = current.off sec Parent;</p>

<p>)</p>

<p>return actualTop;</p>

<p>OffsetDimensionsExample. htm</p>

<p>这两个兩数利用offsetParent厲性在DOM层次中逐级向上回溯，将毎个层次中的偏移量属性 合计到一块。对于简单的CSS布局的页面，这两函数可以得到非常精确的结果。对于使用表格和内嵌 框架布局的贞面，由于不同浏览器实现这些元素的方式不同，因此得到的值就不太精确了。一般来说, 贞面中的所有元素都会被包含在几个素中，而这些＜div＞元素的offsetParent又是 ＜body＞元素，所以 getElementLeft ＜)与 geCElementTop ()会返冋与 offsetLeft 和 of f setTop 相同的值。</p>

<p>(^\ 所有这些偏移量属性都是只读的，而且每次访问它们都需要重新计算。因此，应</p>

<p>该尽量避免重复访问这些属性；如果需要重复使用其中某些属性的值，可以将它们保 存在局部变量中，以提高性能。</p>

<p>2客片区大小</p>

<p>元素的客户区大小(clientdimension),指的是元索内容及其内边距所占据的空间大小。有关客户区 大小的属性有两个：clientwidth和clientHeight。其中，clientwidth属性元素内容区宽度加 上左右内边距宽度；clientHeight属性是元素内容区髙度加上上下内边距髙度。團12-2形象地说明 了这些属性表示的大小。</p>

<p>offsetParent</p>

<p>图 12-2</p>

<p>从字面上看，客户区大小就是元素内部的空间大小，因此滚动条占用的空间不计算在内。最常用到 这些属性的情况，就是像第8章讨论的确定浏览器视口大小的时候。如下面的例子所示，要确定浏览器 视U大小，可以使用document, document Element或document. body （在IE7之前的版木中）的 clientWidth 和 clientHeighto</p>

<p>function getViewport(){</p>

<p>if (document.compatMode == &ldquo;BackCompat•){</p>

<p>return {</p>

<p>width： document.body.clientWidth, height: document.body.clientHeight</p>

<p>};</p>

<p>} else {</p>

<p>return {</p>

<p>width： document.documentElement.clientWidth, height: document.documentElement.clientHeight</p>

<p>这个函数首先检査document.compatMode属性，以确定浏览器是否运行在混杂模式。Safari 3.1 之前的版本不支持这个属性，因此就会自动执彳f else语句。Chrome、Opera和Firefox大多数情况下都 运行在标准模式下，因此它们也会前进到else语句。这个函数会返回一个对象，包含两个属性：width 和height;表示浏览器视口（ ＜肚101＞或＜130＜37＞元素）的大小。</p>

<p>与偏移量相似，客户区大小也是只读的，也是每次访问都要重新计算的。</p>

<p>3.滚动大小</p>

<p>最后要介绍的是滚动大小（scrolldimension）,指的是包含滚动内容的元素的大小。有些元素（例如 ＜11比1＞元素），即使没有执行任何代码也能自动地添加滚动条；但另外一些元素，则需要通过CSS的 overflow属性进行设置才能滚动。以下是4个与滚动大小相关的属性。</p>

<p>□    scrollHeight:在没有滚动条的情况下，元素内容的总髙度。</p>

<p>□    scrollWidth：在没有滚动条的情况下，元素内容的总宽度。</p>

<p>□    scrollLeft:被隐藏在内容区域左侧的像素数。通过设置这个属性可以改变元素的滚动位置。</p>

<p>□    scrollTop：被隐藏在内容区域上方的像素数。通过设S这个属性可以改变元素的滚动位置。 图12-3展示了这些属性代表的大小。</p>

<p>scrollWidth和scrollHeight主要用于确定元素内容的实际大小。例如，通常认*＜htm：l ＞元索 是在Web浏览器的视口中滚动的元素（IE6之前版本运行在混杂模式下时是＜1＞0＜^＞元素）。因此，带有 垂直滚动条的页面总髙度就是document.documentElement .scrollHeight。</p>

<p>对于不包含滚动条的页面而言，scrollWidth和scrollHeight与clientWidth和</p>

<p>clientHeight之间的关系并不十分清晰。在这种情况下，基于document. documentElement査看 这些厲性会在不同浏览器间发现一些不一致性问题，如下所述。</p>

<p>□    Firefox中这两组属性始终都是相等的，但大小代表的是文档内容区域的实际尺寸，而非视口的 尺寸。</p>

<p>□    Opera、Safari 3.1及更髙版本、Chrome中的这两组属性是有差别的，其中scrollWidth和 scrollHeight等于视口大小，而clientWidth和clientHeight等于文档内容区域的大小。</p>

<p>□ IE (在标准模式)中的这网组属性不相等，其中scrollWidth和scrollHeight等丁*文梢内 容区域的大小，而clientWidth和clientHeight等于视口大小。</p>

<p>scrollTop</p>

<p>scrollLeft</p>

<p>图 12-3</p>

<p>在确定文档的总商度时(包括基于视口的最小高度时)，必须取得scrollWidth/clientWidth和 scrollHeight/clientHeight中的最大值，才能保证在跨浏览器的环境下得到精确的结果。下面就 是这样一个例子。</p>

<p>var docHeight = Math.max (document .documentElement.. scrollHeight, document.documentElement.clientHeight)；</p>

<p>var docWidch = Math.max(document.documentElement.scroliWidth#</p>

<p>document.documentElement.clientwidth)；</p>

<p>注意，对于运行在混杂模式下的IE,则需要用document. body代替document. document-Elements</p>

<p>通过scrollLeft和scrollTop屈性既可以确定元素当前滚动的状态，也可以设置元素的滚动位 置。在元素尚未被滚动时，这两个属性的值都等于0。如果元素被垂直滚动了，那么scrollTop的值 会大于0,且表示元素上方不可见内容的像素高度。如果元素被水平滚动了，那么scrollLeft的值会 大于0,旦表示元素左侧不可见内容的像素宽度。这两个属性都是可以设置的，因此将元索的 scrollLeft和scrollTop设置为0,就可以®置元素的滚动位置。下面这个函数会检测元素是否位 于顶部，如果不是就将其回滚到顶部。</p>

<p>function scrollToTop(element){ if {element.scrollTop != 0){</p>

<p>element.scrollTop =0;</p>

<p>}</p>

<p>}</p>

<p>迭个函数既取得了 scrollTop的值，也设置了它的值。</p>

<p>4.确定元素大小</p>

<p>IE、Firefox3+、Safari4+s Opera9.5及 Chrome为每个元素都提供了一个 getBoundingClientRect ()方 法。这个方法返回会一^矩形对象，包含4个厲性：left、top、right和bottom。这搜属性给出了 元素在页面中相对F视口的位置。但是，浏览器的实现稍有不同。IE8及更早版本认为文档的左上角坐 标是(2,2)，而其他浏览器包括IE9则将传统的(0,0)作为起点坐标。W此，就潘要在，-开始检查一下位于 (0,0)处的元素的位置，在IE8及更早版本中，会返回(2,2),而在其他浏览器中会返回(0,0)。来看下面的 函数：</p>

<p>function getBoundingClientRect(element){</p>

<p>if (typeof arguments.callee.offset != &ldquo;number&rdquo;){</p>

<p>var scrollTop = document.documentElement.scrollTop? var temp = document.createElement(&ldquo;div&rdquo;)； temp.style.cssText = *position：absoluce；left：0;top：0;&ldquo;; document.body.appendChiId(temp);</p>

<p>arguments.callee.offset = -temp.getBoundingClientRect().top - scrollTop? document.body.removeChild{temp}； temp = null；</p>

<p>var rect = element.getBoundingClientRect(,; var offset = arguments.callee.offset；</p>

<p>return {</p>

<p>left: rect.left 十 offset, right: rect.right + offset, top： rect.top + offset, bottom： rect.bottom + offset</p>

<p>GetBoundingClientRectExample.htm</p>

<p>这个函数使用了它自身的属性來确定是否要对坐标进行调整。第-步是检测属性是否有定义，如果 没布就定义一个。S终的offset会被设置为新元索上坐标的负值，实际上就是在1E中设置为-2,在 Firefox和Opera中没置为-0。为此，需要创建一个临时的元索，将其位置设置在(0,0),然后再调用其 getBoundingClientRect ()。而之所以要减去视口的scrollTop,是为了防止调用这个函数时窗口 被滚动了。这样编写代码，就无需毎次调用这个函数都执行两次getBoundingClientRect () 了。接 下来，再在传人的元素上调用这个方法并基丁•新的汁算公式创建一个对象。</p>

<p>对于不支持getBoundingClientRect (＞的浏览器，可以通过K他手段取得相同的信息。一般来 说，right和left的差值与offsetWidth的值相等，而bottom和top的差值与offsetHeight 相等。而且，left和top戚性大致等于使用本章前面定义的getElementLeft (＞和getElementTop () 函数取得的值。综合上述，就可以创建出下面这个跨浏览器的函数：</p>

<p>function getBoundingClientRect(element){</p>

<p>var scrollTop = docviment.documentElement. scrollTop; var BcrollLeft = document.documentElement.acrollLeft;</p>

<p>if (element.getBoundingClientRect){</p>

<p><img src="E:/11.ProgramFiles/Typora/JavaScriptd8a70b8fbea1082c34809-54.jpg" alt="img" /></p>

<p>if (typeof arguments-callee.offset != &ldquo;number&rdquo;){ var temp = document.createElement(； temp.style.cssText = &ldquo;position：absolute；left：0；top：0;&rdquo;; document.body.appendChiId(temp);</p>

<p>arguments.callee.offset = -temp.getBoundingClientRect &lt;).top - scrollTop; document.body.removeChiId(temp)；</p>

<p>temp = null；</p>

<p>}</p>

<p>var rect = element.getBoundingClientRect{); var offset = arguments.callee-offset；</p>

<p>return {</p>

<p>left: rect.left + offset, right: rect.right + offset, top: rect.top + offset, bottom： rect.bottom + offset</p>

<p>}；</p>

<p>} else {</p>

<p>var actualLeft ■ getElementLeft{element); var actualTop 龍 getElementTop(element);</p>

<p>return {</p>

<p>left: actualLeft - scrollLeft,</p>

<p>right: actualLeft + element.offaetwidth - acrollLeft, tops actualTop - scrollTop,</p>

<p>bottom: actualTop + element.offsetHeight - scrollTop</p>

<p>GetBoundingCHentRectExample.htm</p>

<p>这个函数在getBoundingClientRect (}有效时，就使用这个原生方法，而在这个方法无效时贝［J 使用默认的计算公式。在某些情况下，这个函数返冋的值可能会有所不同，例如使用表格布局或使用滚 动元素的情况下。</p>

<p>由于这里使用了 arguments.callee,所以这个方法不能在严格模式下使用c</p>

<p>12.3遍历</p>

<p>“DOM2级遍历和范围”模块定义了两个用于辅助完成顺序遍历DOM结构的类型：Nodeiterator 和TreeWalkero这两个类型能够基于给定的起点对DOM结构执行深度优先(depth-first)的遍历操作。 在与DOM兼容的浏览器中(Firefox 1及吏商版本、Safari 1.3及更髙版本、Opera 7.6及更髙版本、Chrome 0.2及更髙版本)，都可以访问到这些类型的对象。IE不支持DOM遍历。使用下列代码可以检测浏览器 对DOM2级遍历能力的支持情况。</p>

<p>var supportsTraversals = document.implementation.hasFeature(&ldquo;Traversal&rdquo;z &ldquo;2.0&rdquo;); var supportsNodelterator = (typeof document.createNodelterator == &ldquo;function&rdquo;}; var support sTreeWalker = (typeof document. ere at eTr ee Walker == &ldquo;function**,；</p>

<p>如前所述，DOM遍历是深度优先的DOM结构遍历，也就是说，移动的方向至少有两个(取决 于使用的遍历类型)。遍历以给定节点为根，不可能向上超出D0M树的根节点。以下面的HTML页 面为例》</p>

<p>&lt;!DOCTYPE html&gt;</p>

<p><head></p>

<p></r.ead></p>

<p><body></p>

<p><pxb>Hello</b> world!</p> </body></p>

<p></html></p>

<p>阁12-4展示了这个页面的0014树。</p>

<p><img src="E:/11.ProgramFiles/Typora/JavaScriptd8a70b8fbea1082c34809-55.jpg" alt="img" /></p>

<p>阁 12-4</p>

<p>任和了节点都可以作为遍历的根节点。如果假设＜130办＞元素为根A点,那么遍历的第一步就是访问＜P＞ 元素，然后再访问同为＜^0办＞元素后代的两个文本节点。不过，这次遍历永远不会到达^）：!!^、＜head＞ 元素，也不会到达不属于＜body＞X素子树的任何节点。而以document为根节点的遍历则可以访问到文 档中的全部节点。阁12-5展示了对以document为根节点的DOM树进行深度优先遍历的先后顺序。</p>

<p>|    head</p>

<p>CD「El邮的:</p>

<p>(J) P^exVE;ajnpie |    Element o |</p>

<p>(?)| Te:</p>

<p>ixt Hello</p>

<p>图 12-5</p>

<p>从document开始依序向前，访问的第一个节点是document,访问的般后一个节点是包含 〜orldr•的文本节点。从文档最后的文本节点开始，遍历可以反向移动到DOM树的顶端。此时，访 问的第一个节点是包含&rdquo;Hello1•的文本节点，访问的最后一个节点是document节点。Nodelterator 和TreeWalker都以这种方式执行遍历a</p>

<p>12.3.1 Nodeiterator</p>

<p>Nodeiterator类型是两者中比较简單的一个，可以使用document. createNodelt erat or ()方 法创建它的新实例。这个方法接受下列4个参数。</p>

<p>□    root：想要作为搜索起点的树中的节点。</p>

<p>□    whatToShow：表示要访问哪些节点的数字代码。</p>

<p>□    filter：是一个NodeFilter对象，或者一个表示应该接受还是拒绝某种特定节点的函数。</p>

<p>口 entityReferenceExpansion：布尔值，表术是否要扩展■实体引用。这个参数在HTML页面 中没有用，因为其中的实体弓I用不能扩展。</p>

<p>whatToShow参数是一个位掩码，通过应用一或多个过滤器(filter)来确定要访问哪些节点。这个 参数的值以常量形式在NodeFilter类型中定义，如下所示。</p>

<p>□    NodeFilter.SHOW_ALL：显示所有类型的节点。</p>

<p>□    NodeFilter. SHOW一ELEMENT:显示元素节点0</p>

<p>□    NodeFi 11er.SHOW_ATTRIBUTE:显示特性节点。由于DOM结构原因，实际上不能使用这个值。</p>

<p>□    NodeFilter. SHOW_TEXT：显示文本节点。</p>

<p>□    NodeFilter .SHOW_CDATA_SECTION：显示 CDATA 节点。对 HTML 页面没有用。</p>

<p>□    NodeFilter.SHOW_ENTITY_REFERENCE：显示实体引用节点。对HTML页面没有用。</p>

<p>□    NodeFilter.SHOW_ENTITYE:擺示实体节点。对HTML页囟没有用。</p>

<p>□    NodeFil.ter. SHOW_PROCESSING_INSTRUCTION:显示处理指令节点。对 HTML 页面没有用。</p>

<p>□    NodeFi 1 ter.SHOW_COMMENT：显示注释节点。</p>

<p>□    NodeFilter. SHOW_DOCUMENT：显示文档节点。</p>

<p>□    NodeFilter.SHOW_DOCUMENT_TYPE:显示文档类型节点。</p>

<p>□    NodeFilter.SHOW_DOCUMENT_FRAGMENT：显示文榜片段节点。对HTML页面没有用。</p>

<p>□    NodeFilter. SHOW_NOTATION：显示符号节点。对 HTML %•面没有用。</p>

<p>除了 NodeFilter. SHOW_ALL之外，可以使用按位或操作符来组合多个选项，如下面的例子所示：</p>

<p>var whatToShow = NodeFilter.SHOW_ELEMENT I NodeFilter.SHOW_TEXT;</p>

<p>可以通过createNodelterator ()方法的filter参数来指定自定义的NodeFilter对象，或者 指定一个功能类似节点过滤器(node filter)的函数c每个NodeFilter对象只有一个方法，即accept-Node ();如果应该访问给定的节点，该方法返回NodeFilter. FILTER_ACCEPT，如果不应该访问给 定的节点，该方法返回NodeFilter.FILTER_SKIP。由于NodeFilter是一个抽象的类型，因此不能 直接创建它的实例。在必要时，只要创建一个包含acceptNodeU方法的对象，然后将这个对象传入 createNodelterator ()中即可。例如，下列代码展示了如何创违一个只显示＜口＞元素的节点迭代器。</p>

<p>var filter = {</p>

<p>acceptNode： function(node){</p>

<p>return, node.tagName.toLowerCase() == Mp&rdquo; ?</p>

<p>NodeFilter.F工LTSR_ACCEPT : NodeFilter.FILTER_SKIP;</p>

<p>var iterator - document.createNodeIterator(root, NodeFilLer.SHOW_ELEMENT, filter, false);</p>

<p>第三个参数也可以是-•个与acceptNodeO方法类似的函数，如下所示。</p>

<p>var filter =« function (node) {</p>

<p>return node.tagNazne. toLowerCase () ==    ?</p>

<p>NodeFilter.FILTER一ACCEPT :</p>

<p>NodePilter.PILTER_SKIP;</p>

<p>&gt; t</p>

<p>var iterator - document.createNodelterator(rootr NodeFilter.SHOW_ELEMENT, filter, false);</p>

<p>&ndash;般来说，这就是在JavaScript中使用这个方法的形式，这种形式比较简单，而且也跟其他的 JavaScript代码很相似。如果不指定过滤器，那么应该在第H个参数的位置上传入null。</p>

<p>下面的代碍创建了一个能够访问所有类型节点的简单的Nodeiterator。</p>

<p>var iterator = document.createNodelterator(document r NodeFilter.SHOW_ALLr null, false);</p>

<p>Nodeiterator类型的两个主要方法是nextNode ()和previousNode () y顾名思义，在深度优先 的DOM子树遍历中，nextNode ()方法用于向前前进一步，而previousNode ()用于向后后退一步。 在刚刚创建的Nodeiterator对象中，有一个内部指针指向根节点，因此第-次调用nextNode ()会 返回根节点。当遍历到DOM子树的最后一个节点时，nextNode ()返回null。previousNode ()方法 的工作机制类似。当遍历到DOM子树的最后一个节点，且previousNode ()返冋根节点之后，再次调 用它就会返回null。</p>

<p>以下面的HTML片段为例。</p>

<div id="divl">

<pxb>Hello</b> worldi</p>

<ul>

<li>List item l</li>

<li>List item 2</li>

<li>List item 3</li>

</ul>

</div>

<p>NodelteratorExamplel. htm</p>

<p>假设我们想要遍历<div>元素中的所有元素，那么可以使用下列代码。</p>

<p>var div = document.getElementById(&ldquo;divl&rdquo;);</p>

<p>var iterator = document.createNodelterator(div, NodeFilter.SHOW_ELEMENT, null, false)；</p>

<p>var node = iterator.nextNode();</p>

<p>while (node !== null) {</p>

<p>alert (node. tagNeirae) ；    //檢出标签名</p>

<p>node = iterator.nextNode()；</p>

<p>NodeIteratorExamplel.htm</p>

<p>在这个例？中，第一次调用nextNodeO返间＜p＞元素。因为在到达DOM子树末端时nextNodeO 返冋null,所以这里使用了 while语句在每次循环时检査对nextNodet)的调用是否返问了 null。 执行上面的代码会显示如卜_标签名：</p>

<p>DIV</p>

<p>P</p>

<p>B</p>

<p>UL</p>

<p>LI</p>

<p>LI</p>

<p>LI</p>

<p>也许用不着显示那么多信息，你只想返M遍历屮遇到的＜ii＞元素=很简单，只要使用一个过滤器 即可，如下面的例子所示。</p>

<p>var div = document.getElementById(&ldquo;divl&rdquo;);</p>

<p>var filter = function(node){</p>

<p>return node.tagName.toLowerCase() == &ldquo;li&rdquo; ?</p>

<p>NodeFiIter.FILTER_ACCEPT :</p>

<p>NodeFilter.FILTER^SKIP;</p>

<p>var iterator ■ document.createNodelterator(div, NodePiltor.SHOW_ELEMENT# filter, false};</p>

<p>var node = iterator.nextNode(): while (node !== null) {</p>

<p>alert (node. tagName) ；    //倫出标签名</p>

<p>node = iterator.nextNode{)；</p>

<p>}</p>

<p>NodeIteratorExample2. htm</p>

<p>在这个例子中，迭代器只会返回＜li＞元索。</p>

<p>由于nextNode(》和previousNode (＞方法都基于Nodeiterator在DOM结构中的内部指针工 作，所以DOM结构的变化会反映在遍历的结果中。</p>

<p>Firefox 3.5之前的版本没有实现createNodelterator ()方法，但却支持下一 节要讨论的createTreeWalker ()方法o</p>

<p>12.3.2 TreeWalker</p>

<p>TreeWalker 是 Modelterator 的一个更髙级的版本。除了包括 nextNode ()和 previousNode () 在内的相同的功能之外，这个类型还提供了下列用于在不同方向上遍历DOM结构的方法。</p>

<p>□    parentNodeO：遍历到当前节点的父节点；</p>

<p>□    firstChildO：遍历到当前节点的第-个子节点；</p>

<p>□    lastChildO：遍历到当前节点的最后一个子节点；</p>

<p>□    nextSiblingO :適历到当前节点的下一个同辈节点；</p>

<p>□    previousSibling ():遍历到当前节成的上个同辈节点。</p>

<p>创建TreeWalker对象要使用document. createTreeWalker ()方法，这个方法接受的4个参数</p>

<p>与document .createNodelterator ＜)方法相同：作为遍历起点的根节点、要显示的节点类型、过滤</p>

<p>器和一个表东是否扩展实体引用的布尔值。由于这两个创建方法很相似，所以很容易用TreeWalker</p>

<p>来代替Nodeiterator,如下面的例子所示o</p>

<p>var div = document.getElementById(&ldquo;divl&rdquo;); var filter = function(node){</p>

<p>return node.tagName.toLowerCase() == •li&rdquo;?</p>

<p>NodeFilter. FILTER_JkCCEPT :</p>

<p>NodeFilter.F工LTER_SKIP;</p>

<p>}；</p>

<p>var walker= document.createTreeWalker(div, NodeFiIter.SHOW ELEMENT, filter, false);</p>

<p>var node = i terator.nextNode()；</p>

<p>while (node 1== null) {</p>

<p>alert (node.tagName);    //输出标签名</p>

<p>node = iterator.nextNode();</p>

<p>Tree WalkerExamplel.htm</p>

<p>在这里，filter可以返冋的值有所不同。除了 NodeFilter.FILTER_ACCEPT和NodeFilter. FILTEECSKIP 之外，还可以使用 NodeFiiter.FILTER_REJECT。在使用 Nodeiterator 对象时， NodeFilter.FILTER_SKIP与NodeFilter.FILTER_REJECT的作用相同：跳过指定的节点。但在使 用TreeWalker对象时，NodeFi Iter. FILTER_SKIP会跳过相成节点继续前进到子树中的下一个节点， 而NodeFilter.FlLTER_REJECT则会跳过相应节点及该节点的整个子树。例如，将前面例子中的 NodeFilter. FILTER_SKIP修改成NodeFi Iter .FILTER_REJECT，结果就是不会访问任何节点。这是 因为第一个返回的节点是＜div＞,它的标签名不是”li”，于是就会返回NodeFilter.FILTER_REJECT, 这意味着遍历会跳过整个子树。在这个例子中，＜＜5:^＞元素是遍历的根节点，于是结果就会停止遍历。</p>

<p>当然，TreeWalker真正强大的地方在于能够在DOM结构中沿任何方向移动。使用TreeWalker 遍历DOM树，即使不定义过滤器，也可以取得所有＜li＞元索，如下面的代码所示。</p>

<p>var div = document.getElementByld(&ldquo;divl&rdquo;)；</p>

<p>var walker = document.createTreeWalker(div, NodeFilter.SHOW_ELEMENTZ null, false);</p>

<p>walker. £ir8tChild() t    //传到＜P＞</p>

<p>walker.nextSibling() j    ✓/传剌＜ul＞</p>

<p>var nod© - walker. f iretChild();    &ldquo;传到第一个＜li＞</p>

<p>while (node !== null) { alert(node.tagName);</p>

<p>node = walker.nextSibling();</p>

<p>}</p>

<p>TreeWalkerExamp!e2. him</p>

<p>因为我们知道＜li＞元素在文挡结构中的位置，所以可以立接定位到那里，即使用firstChildO 转到＜p＞元素，使nextSibling()转到＜ul＞元索，然后再使用f irstChild U转到第一个＜li＞元素。 注意，此处TreeWalker只返间元索(由传人到createTreeWalker ()的第二个参数决定)。因此，可 以放心地使用nextSibling ()访问毎一个＜li＞元素，直至这个方法最后返回null。</p>

<p>TreeWalker类型还有一个属性，名叫currentNode,表示任何遍历方法在上次遍历中返回的 节点。通过设置这个屈性也可以修改遍历继续进行的起点，如下面的例子所示。</p>

<p>var node = walker.nextNode();</p>

<p>alert(node === walker.currentNode)；    //true</p>

<p>walker. currentNode = document. body;    &ldquo;修改起点</p>

<p>与Nodeiterator相比，TreeWalker类型在遍历DOM时拥有更大的灵活性。由于IE中没有对 应的类型和方法，所以使用遍历的跨浏览器解决方案非常少见。</p>

<p>12.4范围</p>

<p>为了让开发人员更方便地控制页面，“D0M2级遍历和范围”模块定义了 &ldquo;范围”(range)接口。通 过范围可以选择文档中的-个K域，而不必考虑节点的界限(选择在后台完成，对用户是不可见的)。 在常规的DOM操作不能更有效地修改文档时，使用范围往往可以达到目的。Firefox、Opera、Safari和 Chrome都支持DOM范围。IE以专有方式实现了自己的范围特性。</p>

<p>12.4.1 DOM中的范围</p>

<p>DOM2级在Document类型中定义了 createRange (&gt;方法。在兼容DOM的浏览器中，这个方法 属于document对象。使用hasFeatureO或者直接检测该方法，都吋以确定浏览器是否支持范围。</p>

<p>var supportsRange = document.implementation.hasFeature(&ldquo;Range&rdquo;# &ldquo;2.0&rdquo;)； var alsoSupportsRange = (typeof document.createRange == &ldquo;function&rdquo;)；</p>

<p>如果浏览器支持范围，那么就可以使用createRange ()来创建DOM范围，如下所示： var range = document.createRange();</p>

<p>与节点类似，新创建的范围也直接与创建它的文档关联在一起，不能用于其他文挡。创建了范围之 后，接下来就可以使用它在后台选择文档中的特定部分。而创建范围并设置了其位置之后，还可以针对 范围的内容执行很多种操作，从而实现对底层DOM树的更精细的控制。</p>

<p>每个范围由一个Range类型的实例表示，这个实例拥有很多属性和方法。下列属性提供了当前范 围在文档中的位置信息。</p>

<p>□    startContainer：包含范围起点的节点(即选区中第一个节点的父节点)。</p>

<p>□    startOf£set：泡围在startContainer中起点的偏移量。如果startContainer是文本节 点、注释节点或CDATA节点，那么startOf fset就是范围起点之前跳过的字符数量。否则， startOffset就是范围中第一个子节点的索引。</p>

<p>□    endContainer：包含范围终点的节点(即选区中最后一个节点的父节点)。</p>

<p>口 endOffset:范阐在endContainer中终点的偏移量(与startOffset遵循相同的取值规则)。</p>

<p>□    commonAncestorContainer: startContainer 和 endContainer 共同的祖先Yi点在文相树 中位置最深的那个。</p>

<p>在把范围放到文档中特定的位置时，这些属性都会被賦值。</p>

<p>1.用DOM范围实现简单选择</p>

<p>要使用范围来选择文档中的一部分，最简的方式就是使用selectNode &lt;)或selectNodeContents ()。 这两个方法都接受一个参数，即一个DOM节点，然后使用该节点中的信息来填充范围。其中，</p>

<p>selectNodeU方法选择整个节点，包括其子节点；而selectNodeContents ()方法则只选择节点的 子节点。以下面的HTML代码为例。</p>

<p>&lt;!DOCTYPE html&gt;</p>

<p><html></p>

<p><body></p>

<p id-"pl"><b>Hello</b> world!</p>

<p></body></p>

<p></html></p>

<p>我们可以使用下列代码来创建范m:</p>

<p>var range1 = document.createRange(); range2 = document.createRange(); pi = document.getElementById(&ldquo;pi *)；</p>

<p>rangel，selectNode(pi); range?.,selectNodeContents (pi);</p>

<p>DOMRangeExample.htm</p>

<p>这里创建的两个范岡包含文档中不同的部分：rangl包含^/&gt;元索及其所有子元素，而rang2包 含<1>/&gt;元素、文本节点-Hello•和文本节点-world!* (如图12-6所示)。</p>

<p>rangel</p>

<p>I    I</p>

<p id=Mplw><b>Hello</b> worldK/p>

I___I

range2

图 12-6

在调用 selectNode(｝时，startContainerx endContainer 和 conunonAncestorContainer 都等于传人节点的父节点，也就是这个例子中的document.body。而startOffset属性等于给定节 点在其父节点的childNodes集合中的索引(在这个例子中是I―因为兼容DOM的浏览器将空格算 作--个文本节点)，endOffset等于startOffset加1 (因为只选择了一个节点)。

在调用 selectNodeContents ()时，startContainer、endContainer 和 commonAncestorConta-iner等于传人的节点，即这个例子中的<p>元素3而startOffset属性始终等于0,因为范围从给定节 点的第一个子节点开始。最后，endOffset等于子节点的数量(node. childNodes. length),在这个例 子中是2。

此外，为了更精细地控制将哪些节点包含在范围中，还可以使用下列方法。

□    setStartBefore (refWode):将范M的起点设置在refWode之前，因此refJVode也就是范围 选区中的第一个子节点。同时会将startContainer属性设置为re/Wode.parentAtode，将 startOffset屑性设置为refNode在其父节点的childNodes集合中的索引。

□    set Start Af ter (refAfode):将范围的起点运置在refAZode之后，因此refWode也就不在范 围之内了，其下一个同辈节点才是范闹选区中的第-个子节点。同时会将startContainer屈 性设S为refWbde.parentNbde,将startOffset属性设置为ref Node在其父节点的 childNodes集合中的索引加1。

□ setEndBefore (refNode):将范围的终点设置在refNode之前，因此refWbde也就不在范围 之内了，其上一个同辈节攻才是范围选区中的最后一个子节点。同时会将endContainer属性

设置为 retNode.parenLNode,endOff set 属性设置为 refWdde在其父节点的 childNodes 集合中的索引。

口 setEndAfter (refWode):将范围的终点设置在refWode之后，因此refWdde也就是范围选区 中的最后—t•子节点。同时会将endContainer屈性设置为refMxJe.parentJVode，将 endOff set JS性设置为refWode在其父节点的childNodes集合中的索引加1。

在调用这些方法时，所苻属性都会自动为你设S好。不过，要想创建复杂的范围选区，也可以直接 指定这些属性的值。

2.用DOM范围实现复杂选择

要创建复杂的范围就得使用setStart《〉和setEndO方法。这两个方法都接受两个参数：一个参 照节点和一个偏移it值o对setStart (}来说，参照节点会变成startContainer,而偏移量值会变成 startOf fseto对于setEnd()来说，参照节点会变成endContainer,而偏移最值会变成endOff set 0

可以使用这两个方法来模仿selectNode ()和selectNodeContents ＜)。来看下面的例子：

var range1 = document.createRange{〉； range2 = document.createRange{); pi = document.getElementById("pi");

piIndex = -1;

1/ len;

for (i=0, len＞：pi.parentKode.childNodes.length; i ＜ len； i++)( if (pi.parentKode.childNodes[i] ss pi) {

piIndex s i; break；

}

)

range1.setStart(p1.parentNode, pllndex)/ rangel.setEnd(pi.parentNode# pllndex + 1)t range2.setStart(pi, 0);

range2.aetznd{pi, pi.childModea.length);

DOMRangeExample2. htm

显然，要选择这个节点(使用rangel ),就必须确定当前节点(pi)在其父节点的childNodes 集合中的索引。而要选择这个节点的内容(使用ranges ),也不必计算什么；只要通过setStarcO 和 setEnd ()设置默认值即可。模仿 selectNode ()和 selectNodeContents ()并不是 setStart () 和setEndO的主要用途，它们更胜一筹的地方在于能够选择节点的一部分。

假设你只想选择前面HTML示例代码中从“Hello1，的^llo,•到”world! ”的noB-很容易做到。

第一步是取得所有节点的引用，如下面的例子所示：

var pi = document.getElementById{hpl*); helloNode = pi.firstchild.firstChild; worldNode = pi.lastChild;

DOi\^RangeExamp!e3. htm

实际上，”Hello•’文本节点是＜p＞元素的孙子节点，因为它本身是＜b＞元索的一个子节点。W此， pi. f irstchild 取得的是 ＜b＞，而pi. f irstchild. f irstchild 取得的才是这个文木节点。《world!-文本节点是＜P＞元素的第二个子节点(也是最后一个子节点)，因此可以使用pi. lastChild取得该节

点。然后，必须在创建范围时指定相应的起点和终点，如下面的例子所示。

var range = document.createRange(); range.setStart(helloNode, 2); range.setEnd(worldNode, 3);

D0MRangeExample3. htm

因为这个范围的选区垃该从"Hello■中-e>的后面开始，所以在setStart （>中传人helloNode 的同时，传入了偏移量2 （即-e”的下一个位置；的位置是0）。设置选区的终点时，在setEndO 中传人wor ldNode的同时传入了偏移滅3,表示选区之外的第一个字符的位置，这个字符是”r”，它的 位置足• 3 （位S 0上还有一个空格）。如图12-7所示。

range

I    I

<p id=”Pl"><b>lHlellllbK/b>l lwblrgBin</D>

01234    0123456

图 12-7

由于helloNode和worldNode都是文本节点，因此它们分别变成了新建范围的startContainer 和endContainer。此时startOf fset和endOffset分别用以确定两个节点所包含的文本中的位置， 而不是用以确定子节点的位置（就像传人的参数为元索节点时那样）。此时的coiranonAncestor-Container是<p>元素，也就是同时包含这两个节点的第一个祖先元索。

当然，仅仅是选择了文档中的某--部分用处并不大。何重要的是，选择之后才可以对选区进行操作。

3.操作DOM范围中的内容

在创建范围时，内部会为这个范围创建一个文档片段，范围所属的全部节点都被添加到了这个文档 片段中。为了创建这个文档片段，范围内容的格式必须正确有效。在前面的例子中，我们创建的选区分 别开始和结朿于两个文木节点的内部，因此不能算是格式良好的DOM结构，也就无法通过DOM来表 示。但是，范围知道自身缺少哪些开标签和闭标签，它能够重新构建有效的DOM结构以便我们对其进 行操作。

对于前面的例子而言，范围经过计算知道选区中缺少-个开始的<b>标签，因此就会在后台动态加 人一个该标签，同时还会在前面加人一个表示结束的</1»标签以结束W。于是，修改后的DOM就 变成了如下所示。

<pxb>He</bxb>llo</b> world!</p>

<p>另外，文本节点-world!»也被拆分为两个文本节点，一个包含-wo”，另，-个包含-rid!-。最终的 DOM树如阁12-8所示，右侧是表示范围的文档片段的内容P</p>

<p>像这样创建丫范W之后，就可以使用各种方法对范围的内容进行操作了（注意，表示范围的内部文 档片段中的所有节点，都只是指向文档中相应节点的指针）。</p>

<p>第一个方法，也是最容易理解的方法，就是deleteContents ()。这个方法能够从文档中删除范 所包含的内容。例如：</p>

<p><img src="E:/11.ProgramFiles/Typora/JavaScriptd8a70b8fbea1082c34809-57.jpg" alt="img" /></p>

<p>var pi = document.getElementById(&ldquo;pi■)； helloNode = pi.firstChild.firstChild; worldNode = pi.lastChild；</p>

<p>range = document.createRange();</p>

<p>range.setstart(helloNode, 2)；</p>

<p>range.setEnd{worldNode, 3);</p>

<p>range.deleteContents(&gt; ?</p>

<p>DO MRangeExample4. htm</p>

<p>文档    范围</p>

<p>團 12-8</p>

<p>执行以上代码后，页面中会显示如下HTML代码：</p>

<p><pxb>He<Zb>rld! </p></p>

<p>由于范围选区在修改底层DOM结构时能够保证格式良好，因此即使内容被删除了，最终的DOM 结构依旧是格式良好的。</p>

<p>与deleteContents ()方法相似，extractContents ()也会从文样中移除范围选区。但这两个方</p>

<p>法的区别在于，extractContents(&gt;会返W范围的文杓片段。利用这个返冋的值，可以将范围的内容</p>

<p>插人到文档中的其他地方。如下面的例子所示：</p>

<p>var pi = document. getElementByld (<em>pl &lsquo;</em>); helloNode = pi.firstchild.firstChiId； worldNode - pi-lastChild；</p>

<p>range = document.createRange();</p>

<p>range.setStart(helloNode, 2); range.setEnd(worldNode, 3);</p>

<p>var fragment = range.extractContents()j pi.parentNode.appendChild(fragment)?</p>

<p>在这个例子中，我们将提取出来的文档片段添加到了文档<body>元索的末尾。(记住，在将文档片 段传人appendChildO方法中时，添加到文档中的只是片段的子节点，而非片段本身。)结果得到如下 HTML代码：</p>

<p><pxb>He&lt; /b&gt;rld! &lt; Zp&gt;</p>

<p><b>llo</b> wo</p>

<p>还一种做法，即使用cloneContentsU创建范围对象的一个副本，然后在文档的其他地方插人该 副本。如下面的例子所示：</p>

<p>var pi = document .getElementByld (**plh), helloNode = pi.firstChild.firstChild, worldNode = pi.lastChild,</p>

<p>range = document.createRange();</p>

<p>range.setStart(helloNode, 2); range.setEnd(worldNode, 3);</p>

<p>var fragment ■ range.cloneContents(); pi.parontNode.appendChild(fragment);</p>

<p>DOMRangeExample6. htm</p>

<p>这个方法与extractContentsO非常类似，因为它们都返间文档片段。它们的主要区别在于， cloneContents ()返回的文档片段包含的是范闱中节点的副本，而不是实际的节点。执行上面的操作 后，页面中的HTML代码应该如下所示：</p>

<p><pxb>Hello</b> world!</p></p>

<p><b>llo</b> wo</p>

<p>有一点请读者注意，那就是在调用上面介绍的方法之前，拆分的节点并不会产生格式良好的文挡片 段。换句话说，原始的HTML在DOM被修改之前会始终保持不变。</p>

<p>4.插入DOM范围中的内容</p>

<p>利用范围，可以删除或复制内容，还可以像前面介绍的那样操作范围中的内容。使用insertNodeO 方法可以向范围选区的开始处插人一个节点。假没我们想在前面例子中的HTML前面插人以下HTML 代码:</p>

<p><span style="color： red">Inserted text</span></p>

<p>那么，就可以使用下列代码：</p>

<p>var pi = document.getElementByld(&ldquo;pi&rdquo;); helloNode = pi.firstChild.firstChild; worldNode = pi.lastChild；</p>

<p>range = document.createRange{);</p>

<p>range.setStart(helloNode, 2);</p>

<p>range.setEnd(worldNode, 3);</p>

<p>var apan = document.createElement(&ldquo;span&rdquo;)/</p>

<p>span.style.color = &ldquo;red&rdquo;;</p>

<p>span.appendChiId(document.createTextMode(&ldquo;Inserted text&rdquo;))； range.insertNode(span);</p>

<p>运行以上JavaScript代码，就会得到如下HTML代码：</p>

<p id="pi"><b>He<span styie="color： red">Inserted text</span>llo</b> world</p>

<p>注意，好被插人到了-Hello•中的-llo，’前面，而该位置就是范围选区的开始位置。还要 注意的是，由于这里没有使用上一节介绍的方法，结果原始的HTML并没有添加或删除<b>元索。使用 这种技术可以插人一跌帮助提示信息，例如在打开新窗U的链接旁边插人一幅图像。</p>

<p>除了向范围内部插人内容之外,还可以环绕范围插人内容，此时就要使用surroundContentsO 方法。这个方法接受一个参数，即环绕范围内容的节点。在环绕范围插人内容时，后台会执行下列 步骤。</p>

<p>(1)    提取出范围中的内容(类似执行extractContent ());</p>

<p>(2)    将给定节点插人到文档中原来范围所在的位置上；</p>

<p>(3)    将文相片段的内容添加到给定节点中。</p>

<p>可以使用这种技术來突出显示网页中的某些词句，例如下列代码：</p>

<p>var pi = document.getElementByld{&ldquo;pi&rdquo;); helloNode = pi.firstChiId.firstChiId; worldNode = pi.lastChild;</p>

<p>range = document.createRange();</p>

<p>range.aelectNode(helloNode);</p>

<p>var span = doeument.createBlement(&ldquo;span■); span.style.backgroundColor = &ldquo;yellow&rdquo;; range.surroundContents(span);</p>

<p>DOMRangeExample8.htm</p>

<p>会给范围选区加上一个黄色的背景。得到的HTML代码如下所示：</p>

<p><pxb>He</bxspan style-"background-color：yellow"><b>llo</b> wo</span>rld!</p></p>

<p>为了插A<span>,必须将&lt;*&gt;元素拆分成两个<b>元素，一个包含W ,另一个包含~llo&rdquo;。拆分 之后，就可以稳妥地插人<span>了。</p>

<p>5.折叠DOM范围</p>

<p>所谓折叠范围，就是指范围中未选择文档的任何部分。可以用文本框来描述折叠范围的过程。假设 文本框中有一行文本，你用跃标选择了其中一个完整的单词。然后，你单击鼠标左键，选区消失，而光 标则落在了其中两个字母之间。同样，在折叠范围时，典位置会落在文档中的两个部分之问，可能是范 围选区的开始位置，也可能是结束位置。图12-9展示了折叠范围时发生的情形。</p>

<p>使用collapse()方法来折叠范围，这个方法接受一个参数，一个布尔值，表示要折叠到范围的哪 一端。参数true表示折叠到范围的起点，参数false表示折叠到范围的终点。要确定范围已经折畳完 毕，可以检査collapsed属性，如下所示：</p>

<p>range.collapse(true)； alert(range.collapsed)?</p>

<p>//折叠到起点 &ldquo;鍮出 true</p>

<p id=*,pl"><b>H^llo</b> wcjrld! </p> 原始范围

<p id=hpl"><b>Helllo</b> world! </p> 折香到开始位置

<p id— "pi" ><b> He 1 lo< /b> 折登到结束位置

wcjrld!</p>

<p>图 12-9</p>

<p>检测某个范围是否处于折叠状态，可以帮我们确定范围中的两个节点是否紧密相邻。例如，对于下 面的HTML代码：</p>

<p id= "pi" >Paragraph l</pxp id-"p2">Paragraph 2</p>

<p>如果我们不知道其实际构成(比如说，这行代码是动态生成的)，那么可以像下面这样创建一个范围。</p>

<p>var pi = document.getElementById(&ldquo;pi&rdquo;)f p2 = document.getElementById(&ldquo;p2w), range = document.createRange()；</p>

<p>range.setStartAfter(pi)；</p>

<p>range.setStartBefore(p2);</p>

<p>alert (range, col lapsed) ；    //梭出 true</p>

<p>在这个例子中，新创建的范围是折叠的，因为pi的后面和p2的前面什么也没有。</p>

<p>6.比较DOM范围</p>

<p>在有多个范围的情况下，可以使用compareBoundaiyPoints &lt;)方法来确定这些范围是否有公共 的边界(起点或终点)。这个方法接受两个参数：表示比较方式的常量值和要比较的范围。表示比较方 式的常量值如下所示。</p>

<p>□    Range.START_TO_START(0):比较第一个范围和第二个范围的起点；</p>

<p>□    Range.START_TO_END (1):比较第一个范围的起点和第二个范围的终点；</p>

<p>□    Range. END_TO_END (2)：比较第一个范围和第二个范围的终点；</p>

<p>□    Range. END_TO_START (3):比较第一个范围的终点和第一个范围的起点。 compareBoundaryPoints()方法可能的返回值如下：如果第一个范围中的点位于第二个范围中的</p>

<p>点之前，返回-1;如果两个点相等，返回0;如果第一个范围中的点位于第二个范围中的点之后，返回 1。来看下面的例子。</p>

<p>var rangel = document.createRange{)? var range2 = document.createRange()? var pi = document.getElementByld(&ldquo;pi&rdquo;)；</p>

<p>rangel.selectNodeContents(pi)；</p>

<p>range2.selectNodeContents(pi)；</p>

<p>range2.setEndBefore{pi,lastChild)；</p>

<p>alert(rangel.compareBoundaryPoints(Range.START_TO_START, range2))；    &ldquo;0</p>

<p>alert(rangel.compareBoundaryPoints(Range.END_TO_END, range2))；    &ldquo;1</p>

<p>在这个例子中，两个范围的起点实际上是相同的，因为它们的起点都是由selectNodeContents {) 方法设置的默认值来指定的。因此，第一次比较返回0。但是，range2的终点由于调用setEndBefore {) 已经改变了，结果是rangel的终点位于ranges的终点后面(见图12-10)，因此第二次比较返回1。</p>

<p>rangel</p>

<p>I-1</p>

<p id= ,,pl,,><b>Hello</b> world!</p>

<p>range2 图 12-10</p>

<p>\7.    复制DOM范围</p>

<p>可以使用cloneRangeO方法复制范围。这个方法会创建调用它的范围的一个副本。 var newRange = range.cloneRange();</p>

<p>新创建的范围与原来的范阐包含相同的厲性，而修改它的靖点不会影响原来的范围。</p>

<p>\8.    清理DOM范围</p>

<p>在使用完范围之后，最好是调用detach(&gt;方法，以便从创建范围的文挡中分离出该范围。调用 detach()之后，就可以放心地解除对范围的引用，从而让垃圾回收机制回收其内存了。来看下面的 例子。</p>

<p>range.detach() ；    //从文档中分离</p>

<p>range = null;    //解除引用</p>

<p>在使用范闱的最后再执行这两个步骤是我们推荐的方式。一旦分离范闱，就不能再恢复使用了。</p>

<p>lERangeExamplel .htm</p>

<p>12.4.2旧8及更早版本中的范围</p>

<p>虽然IE9支持DOM范围，但IE8及之前版本不支持DOM范围。不过，IE8及早期版本支持一种类 似的概念，即文本范围(textrange)。文本范ffl是IE专有的特性，其他浏览器都不支持。顾名思义，文 本范围处理的主要是文本(不一定是DOM节点)。通过<body>、<button>、<input>^<textarea> 等这几个元索，可以调用createTextRange()方法来创建文本范围。以下是一个例子：</p>

<p>var range = document.body.createTextRange();</p>

<p>像这样通过document创建的范围可以在页面中的任何地方使用(通过其他元索创建的范围则只能 在相应的元素中使用)。与DOM范围类似，使用ffi文本范围的方式也肴很多种a</p>

<p>1.用IE范围实现简单的选择</p>

<p>选择页面中某一区域的最简单方式，就是使用范围的findTextU方法。这个方法会找到第一次出 现的给定文本，并将范闱移过来以环绕该文本。如果没有找到文本，这个方法返回false;否则返回 true。同样，仍然以下面的HTML代码为例。</p>

<p id-"pi"><b>Hello<Zb> world!</p>

<p>要选择-Hello•‘，可以使用下列代码。</p>

<p>var range = document.body.createTextRange()； var found = range.findText{KHello&rdquo;)；</p>

<p>在执行完第二行代科之后，文本”Hello•就被包围在范M之内了。为此，可以检杏范闱的text属 性来确认(这个性返回范围中包含的文本)，或者也可以检查findText()的返回值——在找到了文 本的情况下返回值为Crue。例如：</p>

<p>alert(found)；    //true</p>

<p>alert(range.text);    //&ldquo;Hello&rdquo;</p>

<p>还可以为findTextO传人另一个参数，即一个表示向哪个方向继续搜索的数值。负值表示应该从 当前位置向后搜索，而正值表示应该从当前位置向前搜索。因此，要査找文档巾前两个，Hello。的实例， 应该使用下列代码。</p>

<p>var found = range.findText(&ldquo;Hello&rdquo;);</p>

<p>var foundAgain = range.f i ndText(&ldquo;Hello&rdquo;# 1)；</p>

<p>IE中与DOM中的selectNode ()方法最接近的方法是moveToElementText (),这个方法接受一 个DOM元素，并选择该元素的所有文本，包括HTML标签。下面是一个例子。</p>

<p>var range = document.body.createTextRange()； var pi = document.getElementById(&ldquo;pi&rdquo;)； range.moveToElementText(pi);</p>

<p>IERangeExample2. htm</p>

<p>在文本范围巾包含HTML的悄况下，可以使用htmlTexc属性取得范围的全部内容，包括HTML 和文本，如下面的例子所示。</p>

<p>alert(range.htralText)；</p>

<p>IE的范围没有任何属性可以随着范围选区的变化而动态吏新。不过，其parentElementO方法倒 是与 DOM 的 commonAncestorContainer 属性类似。</p>

<p>var ancestor = range.parentElement()；</p>

<p>这样得到的父元素始终都可以反映文本选区的父节点。</p>

<p>2.使用IE范围实现复杂的选择</p>

<p>在E中创建复杂范围的方法，就是以特定的增量向四周移动范闱。为此，IE提供了 4个方法： move(), moveStart()、moveEndG和expand()。这些方法都接受两个参数：移动单位和移动单位 的数量。其中，移动单位是下列一种字符串值。</p>

<p>□    &ldquo;character&rdquo;:逐个字符地移动</p>

<p>□    &ldquo;word-:逐个单同(一系列非空格字符)地移动。</p>

<p>□    &ldquo;sentence&rdquo;:逐个句子(一系列以句号、问号或叹号结尾的字符)地移动。</p>

<p>□    -textedit&rdquo;：移动到当前范围选区的开始或结束位置。</p>

<p>通过moveStarCO方法可以移动范围的起点，通过moveEndO方法可以移动范围的终点，移动&rsquo;的</p>

<p>幅度由单位数量指定，如下面的例子所示。</p>

<p>range.moveStart (&ldquo;word*, 2) ;    //起点移动 2 个单词</p>

<p>range.moveEnd( &ldquo;character&rdquo;, 1);    //终点移动 1 个+符</p>

<p>使用expand (＞方法可以将范围规范化。换句话说，expand ()方法的作用是将任何部分选择的文 本全部选中。例如，当前选择的是一个.单词中间的两个字符，调用expand (-word。)可以将整个单词都 包含在范围之内。</p>

<p>而move ()方法则首先会折叠3前范国(U:起点和终点相等)，然后再将范围移动指定的单位数量， 如下面的例子所示。</p>

<p>range.move {&ldquo;character&rdquo; , 5);    //移动 5 个字符</p>

<p>调用move ()之后，范围的起点和终点相同，因此必须再使用moveStart U或moveEnd()创建新 的选区。</p>

<p>3.操作IE范围中的内容</p>

<p>在IE中操作范围中的内容可以使用text厲性或pasteHTML ()方法。如前所述，通过text厲性 可以取得范围中的内容文本；但是，也可以通过这个属性设置范围中的内容文本。来看一个例子。</p>

<p>var range = document.body.createTextRange(); range.findText(&ldquo;Hello&rdquo;)； range.text = &ldquo;Howdy *;</p>

<p>如果仍以前面的Hello World代码为例，执行以上代码后的HTML代码如下。</p>

<p id="pi"><b>Howdy</b> worldl</p>

<p>注意，在设置cext属性的情况下，HTML标签保持不变。</p>

<p>要向范围中插人HTML代码，就得使用pasteHTML (&gt;方法，如下面的例子所示。</p>

<p>var range = document.body.createTextRange{)? range.findText(■Hello*):</p>

<p>range.pasteHTML(n<em>Howdy</em>R);</p>

<p>IERangeExample3. htm</p>

<p>执行这些代码后，会得到如下HTML。</p>

<p id= "pi• ><bxem>Howdy</em></b> world!</p>

<p>不过，在范围中包含HTML代码时，不应该使用pasteHTML&lt;&gt;,因为这样很容易导致不可预料的 结果一很可能是格式不正确的HTML。</p>

<p>\4.    折旧范围</p>

<p>IE为范围提供的col lapse ()方法与相应的DOM方法用法一样：传人true把范围折番到起点， 传人false把范围折叠到终点。例如：</p>

<p>range, col lapse (true) ；    //折 4 到起点</p>

<p>可惜的是，没有对应的collapsed属性让我们知道范围是否已经折叠完毕。为此，必须使用 boundingWidth属性，该属性返回范围的宽度(以像素为单位)。如果boundingWidth属性等于0, 就说明范围已经折番了：</p>

<p>var isCollapsed = (range.boundingWidth == 0);</p>

<p>此外，还有bouridingHeight、boundingLeft和boundingTop等属性，虽然它们都不像 boundingWidth那么有用，但也可以提供一些有关范围位置的信息。</p>

<p>\5.    比较IE范围</p>

<p>IE 中的 compareEndPoints ()方法与 DOM 范阐的 compareBoundaryPoints ()方法类似。这个 方法接受两个参数：比较的类型和要比较的范围。比较类型的取值范围是下列几个字符串值：</p>

<p>&ldquo;StartToStart&rdquo;、-StartToEnd&rdquo;、-EndToEnd”和&rdquo;EndToStart&rdquo;。这几种比较类型与比较 DOM 范 围时使用的几个值是相同的。</p>

<p>同样与DOM类似的是，compareEndPoints (＞方法也会按照相同的规则返回值，即如果第一个范 围的边界位于第二个范围的边界前面，返回-1;如果二者边界相同，返回0;如果第一个范围的边界位 于第二个范m的边界后面，返回1。仍以前面的Hello World代码为例，下列代码将创建两个范围，一个 选择&rdquo;Hello world!&ldquo;(包括＜b＞标签)，另个选择&rdquo;Hello&rdquo;。</p>

<p>var range1 = document.body.createTextRange(); var range2 = document.body.createTextRange();</p>

<p>rangel.findText(&ldquo;Hello world!■); range2.findText(&ldquo;Hello&rdquo;);</p>

<p>alert(rangel.compareEndPoints(&ldquo;StartToStart&rdquo;, range2));    //0</p>

<p>alert(range1.compareEndPoints(■EndToEnd&rdquo;, range2))；    &ldquo;1</p>

<p>IERangeExample5. htm</p>

<p>由于这两个范围共享同一个起点，所以使用compareEndPoints ()比较起点返间0。而rangel 的终点在range2的终点后面，所以compareEndPoints ()返问1。</p>

<p>IE中还冇两个方法，也是用于比较范闱的：isEqual()用于确定两个范围是否相等，inRangeO</p>

<p>用于确定一个范围是否包含另一个范ffl。下面是相应的示例。</p>

<p>var rangel = document.body-createTextRange(); var range2 = document.body.createTextRange{)； rangel.findText{&ldquo;Hello World&rdquo;};</p>

<p>range2.findText{&ldquo;Hello&rdquo;);</p>

<p>alert(&ldquo;range1.isEqual(ronge2): &ldquo; + rangel.isBqual(range2));    //false</p>

<p>alert(&ldquo;rangel.inRange(range2)s&rdquo; + rangel.inRange(range2));    //true</p>

<p>IERa”geExample6. htm</p>

<p>这个例子使用了与前面相同的范围来示范这两个方法。由于这两个范围的终点不同，所以它们不相 等，调用isP；qual(＞返回false。由于range2实际位于rangel内部，它的终点位于后者的终点之 前、起点之后，所以range2被包含在rangel内部，调用inRange (＞返回true。</p>

<p>6.复制旧范围</p>

<p>在［E中使用duplicated方法可以复制文木范围，结果会创建原范围的-个副本，如下面的例子 所示。</p>

<p>var newRange = range.duplicate();</p>

<p>新创建的范围会带有与原范围完全相同的属性。</p>

<p>12.5小结</p>

<p>DOM2级规范定义了一些模块，用于增强DOMIS。“DOM2级核心”为不同的DOM类型引人了 一些与XML命名空间有关的方法。这些变化只在使用XML或XHTML文档时才有用；对于HTML文 档没有实际意义。除7•与XML命名空间有关的方法外，“DOM2级核心”还定义了以编程方式创建 Document变例的方法，也支持了创建Document Type对象u</p>

<p>“D0M2级样式”模块主要针对操作元素的样式信息而开发，其特性简要总结如下■:</p>

<p>□每个元素都杳一个关联的style对象，可以用来确定和修改行内的样式。</p>

<p>□要确定某个元素的计算样式(包括应用给它的所有CSS规则)，可以使用getcomputedstyle () 方法。</p>

<p>□    EE不支持getcomputedstyle ()方法，但为所有元索都提供了能够返回相同信息current Style 属性。</p>

<p>□可以通过document .styleSheets集合访问样式表。</p>

<p>□除IE之外的所有浏览器都支持针对样式表的这个接口，也为几乎所冇相应的DOM功能提供 了自己的&ndash;套属性和方法。</p>

<p>“D0M2级遍历和范模块提供丫与DOM结构交年的不同方式，简要总结如下。</p>

<p>□遍历即使用Nodeiterator或TreeWalker对DOM执行深度优先的遍历c</p>

<p>□    Nodeiterator是一个简单的接U，只允许以一个节点的步幅前后移动。而TreeWalker在提 供相同功能的同时，还支持在DOM结构的各个方向上移动，包括父节点、同辈节点和子节点等 方向=</p>

<p>口范围是选择DOM结构中特定部分，然后再执行相应操作的一种手段。</p>

<p>□使用范围选区可以在删除文档巾某些部分的同时，保持文档结构的格式良好，或者复制文档中 的相应部分。</p>

<p>□    IE8及更早版本不支持“DOM2级遍历和范围”模块，但它提供了一个专有的文本范围对象，可 以用来完成简单的基于文本的范围操作。IE9完全支持DOM遍历。</p>

    </div>

    
    

    
    

    <footer class="post-footer">
      

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/02-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/01-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%90%86%E8%AE%BA/02-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/04-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/15-%E6%A8%A1%E5%9E%8B%E8%9E%8D%E5%90%88/04-/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">4</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/05-%E5%9F%BA%E7%A1%80%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/03-%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/js/js13-%E4%BA%8B%E4%BB%B6/">
            <span class="next-text nav-default">JS13 事件</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="iteratelyd@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="http://github.com/iterateself" class="iconfont icon-github" title="github"></a>
      <a href="https://www.zhihu.com/people/thebegin/activities" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="https://www.douban.com/people/68028070/" class="iconfont icon-douban" title="douban"></a>
  <a href="http://iterate.site/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> site pv: <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
    <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> site uv: <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2018
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">iterateself</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>


<script type="text/javascript" src="/dist/even.min.js?v=3.2.0"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>








</body>
</html>
