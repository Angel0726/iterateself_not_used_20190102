<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>JS18 JavaScript与XML - 迭代自己</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="iterateself" />
  <meta name="description" content="第18* JavaScript 与 XML 本章内容 □检测浏览器对XML DOM的支持 □理解 JavaScript 中的 XPath □使用XSLT处理器 几何时，XML—度成为存储和通过因特网传输结构化数据" />

  <meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.47.1" />


<link rel="canonical" href="http://iterate.site/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/05-%E5%9F%BA%E7%A1%80%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/12-%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/js/js18-javascript%E4%B8%8Exml-/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">




<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<link href="/dist/even.min.css?v=3.2.0" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">




<meta property="og:title" content="JS18 JavaScript与XML" />
<meta property="og:description" content="第18* JavaScript 与 XML 本章内容 □检测浏览器对XML DOM的支持 □理解 JavaScript 中的 XPath □使用XSLT处理器 几何时，XML—度成为存储和通过因特网传输结构化数据" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://iterate.site/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/05-%E5%9F%BA%E7%A1%80%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/12-%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/js/js18-javascript%E4%B8%8Exml-/" /><meta property="article:published_time" content="2018-06-12T20:26:49&#43;00:00"/>
<meta property="article:modified_time" content="2018-06-12T20:26:49&#43;00:00"/>
<meta itemprop="name" content="JS18 JavaScript与XML">
<meta itemprop="description" content="第18* JavaScript 与 XML 本章内容 □检测浏览器对XML DOM的支持 □理解 JavaScript 中的 XPath □使用XSLT处理器 几何时，XML—度成为存储和通过因特网传输结构化数据">


<meta itemprop="datePublished" content="2018-06-12T20:26:49&#43;00:00" />
<meta itemprop="dateModified" content="2018-06-12T20:26:49&#43;00:00" />
<meta itemprop="wordCount" content="21028">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="JS18 JavaScript与XML"/>
<meta name="twitter:description" content="第18* JavaScript 与 XML 本章内容 □检测浏览器对XML DOM的支持 □理解 JavaScript 中的 XPath □使用XSLT处理器 几何时，XML—度成为存储和通过因特网传输结构化数据"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">迭代自己</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">最新</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a><a href="/catalog/">
        <li class="mobile-menu-item">完整目录</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">迭代自己</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">最新</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/catalog/">完整目录</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">JS18 JavaScript与XML</h1>

      <div class="post-meta">
        <span class="post-time"> 2018-06-12 </span>
        
        <span class="more-meta"> 21028 words </span>
        <span class="more-meta"> 42 mins read </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> times read </span>
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  
  <div class="post-toc-content">
    <nav id="TableOfContents">
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li><a href="#第18">第18*</a></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</nav>
  </div>
</div>

    
    

    
    <div class="post-content">
      

<h5 id="第18">第18*</h5>

<p>JavaScript 与 XML</p>

<p>本章内容</p>

<p>□检测浏览器对XML DOM的支持 □理解 JavaScript 中的 XPath □使用XSLT处理器</p>

<p>几何时，XML—度成为存储和通过因特网传输结构化数据的标准„透过XML的发展，能够 清晰地看到Web技术发展的轨迹。DOM规范的制定，不仅是为了方便在Web浏览器中使用</p>

<p>18</p>

<p>XML,也是为了在桌面及服务器应用程序中处理XML数据。此前，由于浏览器无法解析XML数据,</p>

<p>很多开发人员都要动手编写自己的XML解析器。而自从DOM出现后，所有浏览器都内置了对XML的 原生支持(XMLDOM),同时也提供了一系列相关的技术支持。</p>

<p>18.1浏览器对XML DOM的支持</p>

<p>在正式的规范诞生以前，浏览器提供商实现的XML解决方案不仅对XML的支持程度参差不齐， 而且对同一特性的支持也各不相同。DOM2级是第一个提到动态创建XML DOM概念的规范。D0M3 级进一步增强了 XML DOM,新增了解析和序列化等特性。然而，当DOM3级规范的各项条款尘埃落 定之后，大多数浏览器也都实现了各自不同的解决方案。</p>

<p>18.1.1 D0M2 级核心</p>

<p>我们在第 12章曾经提到过,DOM2级在 document. implementation 中引人了 createDocument () 方法。IE9+、Firefox、Opera、Chrome和Safari都支持这个方法。想一想，或许你还记得可以在支持DOM2 级的浏览器中使用以下语法来创建一个空白的XML文档：</p>

<p>var xmldom = document.implementation.createDocument(namespaceUri, root, doctype)；</p>

<p>在通过JavaScript处理XML时，通常只使用参数root,因为这个参数指定的是XMLDOM文档元 索的标签名。而namespaceUri参数则很少用到，原因是在JavaScrip中管理命名空间比较困难。最后， doctype参数用得就更少了。</p>

<p>因此，要想创建一个新的、文档元素为＜root;JXML文档，可以使用如下代码：</p>

<p>var xmldom = document.implementation.createDocument(*&ldquo;r &ldquo;root&rdquo;, null};</p>

<p>alert(xmldom.documentElement.tagName)；    //-root&rdquo;</p>

<p>var child = xmldom.createElement(&ldquo;child*)； xmldom.documentElement.appendChiId(child)；</p>

<p>DOMLevel2CoreExampleO 1. htm</p>

<p>这个例子创建了一个XML DOM文档，没存默认的命名空间，也没有文档类型。但要注意的是，尽 管不需要指定命名空间和文档类型，也必须传人相应的参数。具体来说，给命名空间URI传入一个空字 符串，就意味若未指定命名空间，而给文档类型传人null,就意味着不指定文梏类型。变量xmldom 中保存着一个DOM2级Document类型的实例，带有第12章讨论过的所有DOM方法和属性。我们这 个例子显示了文档元索的标签名，然后又创建并给文档元素添加了一个新的子元素。</p>

<p>要检测浏览器是否支持DOM2级XML,可以使用下面这行代码：</p>

<p>var hasXmlDom = document.implementation.hasFeature(&ldquo;XML&rdquo;, B2.0&rdquo;);</p>

<p>在实际开发中，很少需要从头开始创建-个XML文档，然后再使用DOM文档为其添加元素。更 常见的情况往往是将某个XML文档解析为DOM结构，或者反之。由于DOM2级规范没有提供这种功 能，因此就出现f 一些事实^；•准。</p>

<p>18.1.2 DOMParser 类型</p>

<p>为了将XML解析为DOM文档，Firefox引入了 DOMParser类型；后来，IE9、Safari、Chrome和 Opera也支持了这个类型。在解析XML之前，首先必须创建一个DOMParser的实例，然后再调用 parseFromStringO方法。这个方法接受两个参数：要解析的XML字符串和内容类型(内容类型始 终都应该是&rdquo;text/xml&rdquo;)。返回的值是一个Document的丈例。来看下面的例子。</p>

<p>var parser = new DOMParser()；</p>

<p>var xmldom = parser .parseFromString(•<rootxchild/></root>&rdquo;, ■ text/xml■) ?</p>

<p>alert(xmldom.documentElement.tagName);    Z/■root&rdquo;</p>

<p>alert(xmldom.documentElement.firstChiId.tagName)；    //&ldquo;child&rdquo;</p>

<p>var anotherChild = xmldom.createElement{&ldquo;child&rdquo;); xmldom.documentElement.appendChild(anotherChild};</p>

<p>var children = xmldom.getElementsByTagName(&ldquo;child&rdquo;}； alert(children.length);    //2</p>

<p>DOMParserExampleOl. htm</p>

<p>在这个例子中，我们把一个简单的XML字符申解析成了一个DOM文档。解析得到的DOM结构以 <root>作为其文档元索，该元素还有一个《:1111<1>子元素。此后，就可以使用DOM方法对返回的这个 文档进行操作了。</p>

<p>DOMParser只能解析格式良好的XML，因而不能把HTML解析为HTML文档。在发生解析错误 时，仍然会从parseFromStringU中返回一个Document对象，但这个对象的文档元素是 <parsererror>,而文档元素的内容是对解析错误的描述。下面是一个例子。</p>

<p><parsererror xmlns="http： "[www.mozilla.org/newlayout/xml/parsererror.xml">XML](<a href="http://www.mozilla.org/newlayout/xml/parsererror.xml%22%3eXML">http://www.mozilla.org/newlayout/xml/parsererror.xml%22%3eXML</a>)</p>

<p>Parsing Error： no element found Location： <a href="file:///I:/My%20Writing/My%20BooksZ">file:///I:/My%20Writing/My%20BooksZ</a></p>

<p>Professional%20JavaScript/Second%2 0Edition/Exaniples/Chl5/DOMParserExainple2.htm Line</p>

<p>Number L, Column 7： <sourcetext> &amp; It;root &amp; gt;&mdash;&mdash;^</sourcetext > &lt; /parsererror&gt;</p>

<p>Firefox和Opera都会返回这种格式的文档。Saferi和Chrome返回的文档也包含<parsererror>元素， 但该元素会出现在发生解析错误的地方。E9会在调用parseFromString &lt;)的地方抛出一MS析错误。 由于存在这些差别，因此确定是否发生解析错误的最佳方式就是，使用一个try catch语句块，如果没</p>

<p>有错误，则通过getElementsByTagName ()来査找文档中是否存在<parsererror>元素，如下面的例 子所示。</p>

<p>var parser = new DOMParser(), xmldom&rsquo; errors;</p>

<p>try {</p>

<p>xmldom = parser.parseFromString(&rdquo;<root>&rdquo;, *text/xml&rdquo;); errors = xmldom.getElementsByTagName(&ldquo;parsererror&rdquo;)； if (errors.length &gt; 0){</p>

<p>throw new Error{&ldquo;Parsing error!&rdquo;};</p>

<p>}</p>

<p>} catch (ex) {</p>

<p>alert (* Parsing error!”：</p>

<p>)</p>

<p>DOMParserExample02. htm</p>

<p>18</p>

<p>这例子显示，要解析的字符串中缺少了闭标签</root>,而这会导致解析错误。在IE9+中，此时会 抛出错误。在Firefox和Opera中，文格元素将是<parsererror>,而在Safari和Chrome中， <parsererror>JS<root>(iO第一个子元索o 调用 getElementsByTagName (&ldquo;parsererror&rdquo;)能够 应对这两种情况。如果这个方法返回了元素，就说明有错误发生，继而通过一个瞀告框显示出来。当 然，你还可以更进一步，从错误元素中提取出错误信息。</p>

<p>18.1.3 XMLSerializer 类型</p>

<p>在引入DOMParser的同时，F4refox还引人了 XMLSerializer类型，提供了相反的功能：将DOM 文椅序列化为XML字符串。后来，IE9+、Opera、Chrome和Safari都支持了 XMLSerializer。</p>

<p>要序列化DOM文档，首先必须创建XMLSerializer的实例，然后将文档传入其serializeTo-String ()方法，如下面的例子所东。    •</p>

<p>var serializer = new XMLSerializer():</p>

<p>var xml = serializer.serializeToString(xmldom)； alert(xml);</p>

<p>XMLSerializerExampleO 1 .htm</p>

<p>但是，serializeToStringU方法返PI的字符串并不适合打印，因此看起来会显得乱糟糟的。 XMLSerializer可以序列化任何冇效的DOM对象，不仅包括个别的节点，也包括HTML文档。</p>

<p>将HTML文档传人serializeToStringO以后，HTML文档将被视为XML文档，因此得到的代码也 将是格式良好的。</p>

<p>如果将非DOM对象传入serializeToString(),会寺致错谋发生。</p>

<p>18.1.4旧8及之前版本中的XML</p>

<p>事实上，IE是第一个原生支持XML的浏览器，而这一支持是通过ActiveX对象实现的。为了便于 桌面应用程序开发人员处理XML,微软创建了 MSXML库；但微软并没有针对JavaScript创建不同的对</p>

<p>象，而只是让Web开发人员能够通过浏览器访问相同的对象。</p>

<p>第8章啓经介绍过ActiveXObject类型，通过这个类型可以在JavaScript中创建ActiveX对象的</p>

<p>实例。同样，要创建一个XML文档的实例，也要使用ActiveXObject构造函数并为其传人一个表示 XML文档版本的字符申。有6种不同的XML文档版本可以供选择。</p>

<p>□    Microsoft .XmlDom：最初随同发布；不建议使用。</p>

<p>□    MSXML2.D0MDocument：为方便脚本处理而更新的版本，建议仅在特殊悄况下作为后备版本 使用。</p>

<p>□    MSXML2 . DOKDocument .3.0：为了在JavaScript中使用，这是嚴低的建议版本。</p>

<p>□    MSXML2 .DOMDocument .4.0:在通过脚本处理时并不可靠，使用这个版本可能导致安全警告。</p>

<p>□    MSXML2 .DOMDocument .5.0：在通过脚本处理时并不可靠，使用这个版本同样可能导致安全</p>

<p>警吿。</p>

<p>□    MSXML2 . DOMDocument .6.0：通过脚木能够可靠处理的最新版本。</p>

<p>在这 6 个版本中，微软只推荐使用 MSXML2 .DOMDocument.6.0 或 MSXML2.DOMDocument.3.0; 前者是最新最可靠的版本，而后者则是大多数Windows操作系统都支持的版本。可以作为后备版本的 MSXML2.DOMDocument,仅在针对IE5.5之前的浏览器开发时才有必要使用。</p>

<p>通过尝试创建每个版本的实例并观察是否有错误发生，可以确定哪个版本可用。例如： function createDocument(){</p>

<p>if (typeof arguments.callee.activeXString != &ldquo;string&rdquo;){</p>

<p>var versions = [&ldquo;MSXML2.DOMDocument.6.0•f &ldquo;MSXML2.DOMDocument.3.0&rdquo;,</p>

<p>•MSXML2.DOMDocument■],</p>

<p>i, len;</p>

<p>for (i=0,len=versions.length; i &lt; len; i++&gt;{ try {</p>

<p>new ActiveXObject(versions(i]);</p>

<p>arguments.callee.activeXString = versions[i]；</p>

<p>break；</p>

<p>} catch (ex){</p>

<p>&ldquo;跳过</p>

<p>}</p>

<p>}</p>

<p>}</p>

<p>return new ActiveXObject(arguments.callee.activeXString)；</p>

<p>IEXmlDomExampleO 1. htm</p>

<p>这个闲数中使用for循环迭代了毎个4能的ActiveX版本。如果版本无效，则创建新 ActiveXObject的调用就会抛出错误；此时，catch语句会捕获错误，循环继续。如果没有发生错误, 则可用的版本将被保存在这个函数的activeXString属性中。这样，就不必在每次调用这个函数时都 重复检査可用版本了一直接创建并返回对象即可。</p>

<p>要解析XML字符串，首先必须创建一个DOM文档，然后调用loadXMLO方法。新创建的XML 文档完全是一个空文档，因而不能对其执行任何操作。为loadXKLf)方法传人的XML字符串经解析之 后会被填充到DOM文档中。来看下面的例子。</p>

<p>var xmldom = createDocument{)；</p>

<p>xmldom. loadXML {&rdquo;<root><child/></root>&rdquo;) &lsquo;•</p>

<p>alert(xmldom.documentElement.tagName)?    //&ldquo;root”</p>

<p>alert(xmldom.documentElement.firstChild.LagName)；    //&ldquo;child&rdquo;</p>

<p>var anotherChild = xmldom.createElement(■child*);</p>

<p>xmldom.documentElement.appendChild(anotherChild);</p>

<p>var children = xmldom.getElementsByTagName(&ldquo;child&rdquo;)；</p>

<p>alert(children.length);    //2</p>

<p>fEXmlDomExampleOl .him</p>

<p>在新DOM文档中填充了 XML内容之后，就可以像操作其他DOM文档一样操作它了（可以使用任 何方法和属性）。</p>

<p>如果解析过程中出错，可以在parseError属性中找到错误消息。这个属性本身是_个包含多个属 性的对象，每个属性都保存着有关解析错误的某一方面信息。</p>

<p>18</p>

<p>□    errorCode：错误类型的数值编码；在没有发生错误时值为0。</p>

<p>□    filePos：文件中导致错误发生的位置。</p>

<p>□    line:发生错误的行。</p>

<p>□    linepos：发生错误的行中的字符。</p>

<p>□    reason：对错误的文本解释。</p>

<p>□    srcText：导致错误的代码。</p>

<p>□    url：导致错误的文件的URL （如果有这个文件的话）。</p>

<p>另夕卜，parseError的valueOf （）方法返回errorCode的值，因此可以通过下列代码检测是否发 生了解析错误。</p>

<p>if (xmldom.parseError != 0)(</p>

<p>alert(&ldquo;Parsing error occurred.&rdquo;};</p>

<p>}</p>

<p>错误类型的数值编码可能是正值，也可能是负值，因此我们只需检测它是不是等于0。要取得有关 解析错误的详细信息也很容易，而且可以将这些信息组合起来给出更有价值的解释。来看下面的例子。</p>

<p>if (xmldom.parseError != 0){</p>

<p>Alert(&ldquo;An error occurred:\nZrror Code:&rdquo;</p>

<p>+ xmldom.parseError.ezxorCode + &ldquo;\n&rdquo;</p>

<p>♦ &ldquo;Line: &ldquo; + xmldom.parseError.line -i- &ldquo;\n*</p>

<p>+ &ldquo;Line Pob： &rdquo; 4 xaildOTi.parseError.linepos * &ldquo;\n&rdquo;</p>

<p>+ &ldquo;Reason: • + xmldom.parseError.reason);</p>

<p>IEXmlDomExample02. htm</p>

<p>应该在调用loadXMLO之后、査询XML文档之前，检査是否发生了解析错误。</p>

<p>1.序列化XML</p>

<p>IE将序列化XML的能力内置在了 DOM文档中。每个DOM节点都有一个xml属性，其中保存着 表示该节点的XML字符串。例如：</p>

<p>alert (xmldom.xml)；</p>

<p>文档屮的毎个节点都支持这个简单的序列化机制，无论是序列化整个文档还是某个子文档树，都非 常方便。</p>

<p>2.加载XML文件</p>

<p>IE中的XML文档对象也可以加载来自服务器的文件。与DOM3级中的功能类似，要加载的XML 文档必须与页面中运行的JavaScript代码来自同一台服务器。同样与D0M3级规范类似，加载文档的方 式也可以分为同步和异步两种。要指定加载文档的方式，可以设S async属性，true表示异步，false 表示同步(默认值为true )。来看下面的例子。</p>

<p>var xmldom = creaceDocument(J; xmldom.async = false；</p>

<p>在确定了加载XML文档的方式后，调用load()可以启动F载过程。这个方法接受一个参数，即 要加载的XML文件的URL„在同步方式下，调用load (＞后可以立即检测解析错误并执行相关的XML 处理，例如：</p>

<p>var xmldom createDocumenc(); xmldom.async = false；</p>

<p>xznldom.load( &ldquo;example.xml&rdquo;) /</p>

<p>if (xmldom.parseError 1= 0)(</p>

<p>//处理嫌误</p>

<p>} else {</p>

<p>alert (xmldom. documentBlement. tagName) ; //&ldquo;root&rdquo;</p>

<p>alert(xmldom.documentSleaent.firatChild.tagName); //&ldquo;child&rdquo;</p>

<p>var auotherChild s xmldom.createBlement(&ldquo;child&rdquo;);</p>

<p>xioldom. documentBlement .appendChiId(onotherChiId);</p>

<p>var children = xmldom.getSlemezxtsByTagNane (&ldquo;child&rdquo;); alert(children.length);    //2</p>

<p>alert (xzaldom.xml)；</p>

<p>IEXmlDomExample03. htm</p>

<p>由于是以同步方式处理XML文件，因此在解析完成之前，代码不会继续执行，这样的编程丄作要 简单一点。虽然同步方式比较方便，何如果下载时间太长，会导致程序反应很慢。因此，在加载XML 文档时，通常都使用异步方式。</p>

<p>在异步加载XML文件的情况下，：要为XML DOM文样的onreadystatechange事件指定处理 程序。有4个就绪状态(ready state )。</p>

<p>□    1: DOM正在加载数据。</p>

<p>□    2: DOME经加载完数据。</p>

<p>□    3： DOM已经可以使用，供某些部分对能还无法访问。</p>

<p>□    4： DOM已经完全可以使用。</p>

<p>在实际开发中，要关注的只有一个就绪状态：4。这个状态表示XML文件已经全部加载完毕，而且 已经全部解析为DOM文档。通过XML文档的readyState属性可以取得其就绪状态。以异步方式加 载XML文件的典型模式如下。</p>

<p>var xmldom = createDocument();</p>

<p>xmldom.async = true;</p>

<p>xmldaa.onreadystatechange » function(){ if (xmldcnn.readyState e= 4) {</p>

<p>if (zmldom.parseError 1= 0){</p>

<p>alert(&ldquo;An error occurred:\nSrror Code: n</p>

<p>+ xnldom.parseError.errorCode ♦ &ldquo;\n&rdquo;</p>

<p>+ &ldquo;Line： &rdquo; + xmldom.paraeError.line    &ldquo;\n&rdquo;</p>

<p>+ ”Line Poe: &ldquo; + xzoldom.parseError.linepos 4- w\n&rdquo; ♦ &ldquo;Reason： ■ + xmldom.parseError.reason);</p>

<p>} else {</p>

<p>alert (xznldom. document Element. tagNsune) / //&ldquo;root&rdquo;</p>

<p>alert(xmldom.documentElement.firstChild.tagName)； //&ldquo;child&rdquo;</p>

<p>var anotherChild s xmldom.createBlement (**childR)；</p>

<p>xmldom.docunentElement.appendChild(anotherChild);</p>

<p>18</p>

<p>var children = xmldom.getElementsByTagName (&ldquo;child**); alert(children.length)/    //2 alert (xmldom.xml)；</p>

<p>}</p>

<p>)</p>

<p>}t</p>

<p>xmldom.load( &ldquo;example.xml”&gt; ;</p>

<p>IEXmlDomExample04. htm</p>

<p>要注意的是，为onreadystatechange事件指定处理程序的语句，必须放在调用load＜）方法的 语句之前；这样，才能确保在就绪状态变化时调用该事件处理程序。另外，在事件处理程序内部，还必 须注意要使用XML文档变量的名称（xmldom ）,不能使用this对象。原因是ActiveX控件为预防安全 问题不允许使用this对象。当文裆的就绪状态变化为4时，就可以放心地检测是否发生了解析错误， 并在未发生错误的情况下处理XML 了。</p>

<p>虽然可以通过XML DOM文档对象加载XML文件,但公认的还是使用XMLHttp-Request对象比较好。有关XMLHttpRequest对象及Ajax的相关内容，将在第21 章讨论。</p>

<p>18.1.5跨浏览器处理XML</p>

<p>很少有开发人员能够有福气专门针对一款浏览器做开发=因此，编写能够跨浏览器处理XML的函 数就成为了常见的需求。对解析XML而言，下面这个函数可以在所有四种主要浏览器中使用。</p>

<p>function parseXml（xml）｛ var xmldom = null；</p>

<p>if (typeof DOMParser != &ldquo;undefined&rdquo;){</p>

<p>xmldom = (new DOMParser()).parseFromString(xml, &ldquo;text/xml&rdquo;)；</p>

<p>var errors s xroldom.getElementsByTagName(&ldquo;parsererror&rdquo;)； if (errors.length){</p>

<p>throw new Error(&ldquo;XML parsing error:&rdquo; + errors[0].textContent);</p>

<p>}</p>

<p>} else if (typeof ActiveXObject    *undefined&rdquo;){</p>

<p>xinldom = createDocument () ? xmlaom.loadXKL(xml)； if (xmldom.parseError 1= 0){</p>

<p>throw new Error(&ldquo;XML parsing error: &ldquo; + xmldom.parseError.reason);</p>

<p>}</p>

<p>} else {</p>

<p>throw new Error(&ldquo;No XML parser available.&rdquo;)；</p>

<p>}</p>

<p>return xmldom;</p>

<p>CmssBrowserXmlExampleOl .htm</p>

<p>这个parseXmlO函数只接收一个参数，即可解析的XML字符串。在函数内部，我们通过能力检 测來确定要使用的XML解析方式。DOMParser类型是受支持最多的解决方案，因此首先检测该类型是 否有效。如果是，则创建一个新的DOMParser对象，并将解析XML字符串的结果保存在变量xrnldom 中。由于DOMParser对象在发生解析错误时不抛出错误(除IE94■之外)，因此还要检测返问的文档以 确定解析过程是否顺利。如果发现了解析错误，则根据错误消息拋出一个错误。</p>

<p>函数的最后一部分代码检测了对ActiveX的支持，并使用前面定义的createDocument ()函数来创 建适当版本的XML文档。与使用DOMParser时一样，这里也需要检测结果，以防有错误发生。如果 确实有错误发生，同样也需要抛出一个包含错误原W的错误。</p>

<p>如果上述XML解析器都不nJ用，函数就会抛出一个错误，表示无法解析广。</p>

<p>在使用这个函数解析XML字符串时，应该将它放在try-catch语句当中，以防发生错误。来看 下面的例子</p>

<p>var xmldom = null;</p>

<p>try {</p>

<p>xmldom = parseXml (&rdquo;<root><child/x/root>&rdquo;)； } catch (ex){</p>

<p>alert(ex.message);</p>

<p>}</p>

<p>//进一步处理</p>

<p>CrossBrowserXmlExampleOJ.ktm</p>

<p>对序列化XML而言，也可以按照同样的方式编写一个能够在四大浏览器中运行的函数。例如：</p>

<p>function serializeXml(xmldom){</p>

<p>if (typeof XMLSerializer != &ldquo;undefined&rdquo;){</p>

<p>return (new XMLSerializer()).serializeToString(xmldom);</p>

<p>} else if (typeof xmldom.xml !- &ldquo;undefined&rdquo;){</p>

<p>return xmldom.xml;</p>

<p>} else (</p>

<p>throw new Error(&ldquo;Could not serialize XML DOM.&rdquo;};</p>

<p>}</p>

<p>CrossBrowserXmlExample02. htm</p>

<p>这个serializeXml ()函数接收一个参数，即要序列化的XML DOM文约。与parseXml ()函数 —样，这个函数旨先也是检测受到最广泛支持的特性，即XMLSerializero如果这个类型有效，则使 用它来生成并返回文裆的XML字符串。由于ActiveX方案比较简单，只使用丫一个xml属性，因此这 个函数直接检测了该属性。如果上述两方面尝试都失败f，函数就会抛出一个错误，说明序列化不能进 行。一般来说，只要针对浏览器使用了适当的XMLDOM对象，就不会出现无法序列化的情况，因而也 就没有必要在try-catch语句中调用serializeXml () „结果，就只需如下一行代码即对：</p>

<p>var xml = serializeXml;</p>

<p>18</p>

<p>只不过由于序列化过程的差异，相同的DOM对象在不同的浏览器下，有可能会得到不同的XML 字符串。</p>

<p>18.2浏览器对XPath的支持</p>

<p>XPath是设计用来在DOM文档中査找节点的一种手段，因而对XML处理也很重要。但是，D0M3 级以前的标准并没有就XPath的API作出规定；XPath是在DOM3级XPath模块中首次跻身推荐榇准行 列的。很多浏览器都实现了这个推荐标准，但IE则以自己的方式实现了 XPath。</p>

<p>18.2.1 DOM3 级 XPath</p>

<p>DOM3级XPath规范定义了在DOM中对XPath表达式求值的接口。要确定某浏览器是否支持DOM3 级XPath，可以使用以下JavaScript代码：</p>

<p>var supportsXPath = document.implejnentation.hasFeature(&ldquo;XPath&rsquo;, &ldquo;3.0&rdquo;);</p>

<p>在D0M3级XPath规范定义的类型中，最重要的两个类型是XPathEvaluator和XPathResult。 XPathEvaluator用于在特定的上下文中对XPath表达式求值。这个类型有下列3个方法。</p>

<p>□    creat eExpr ess ion (expression, nsresol ver):将 XPath 表达式及相应的命名空间信息转 换成一个XPathExpression,这是丧询的编译版。在多次使用同一个查询时很有用。</p>

<p>□    createNSResolver (node):根据node的命名空间信息创建一个新的XPathNSResolver对 象。在基丁-使用命名空间的XML文档求值时，需要使用XPathNSResolver对象。</p>

<p>□    evaluate (expression, context, nsresolver, type, result):在给定的上下文中， 基于特定的命名空间信息来对XPath表达式求值。剩下的‘参数指定如何返回结果。</p>

<p>在 Firefox、Safari、Chrome和 Opera 中，Document 类型通常都是与 XPathEvaluator 接口一起实 现的。换句话说，在这®浏览器屮，既可以创建XPathEvaluator的新实例，也可以使用Document 实例中的方法(XML或HTML文档均是如此)。</p>

<p>在上面这三个方法中，evaluate(＞是最常川的。这个方法接收5个参数：XPath表达式、上下文 节点、命名空间求解器、返回结果的类型和保存结果的XPathResult对象（通常是null,因为結果 也会以函数值的形式返回）。其中，第三个参数（命名空间求解器）只在XML代码中使用了 XML命名 空间时有必要指定；如果XML代码中没有使用命名空间，则这个参数应该指定为null。第四个参数（返 回结果的类型）的取值范围是下列常fl之一。</p>

<p>口 XPathResult. ANY_TYPE:返回与XPath表达式匹配的数据类型。</p>

<p>□    XPathResult.NUMBER_TY?E:返回数值。</p>

<p>□    XPathResult . STRING_TYPE:返回字符串值。</p>

<p>口 XPathResult. BOOLEAN_TYPE:返回布尔值0</p>

<p>□    XPathResult.UNORDERED_NODE_ITERATOR_TYPE:返回匹配的资点集合，但集合中节点的次 序不一定与它们在文档中的次序一致。</p>

<p>□    XPathResult.ORDERED_NODE_ITERATOR_TYPE:返LBJ匹配的节点集合，集合中节点的次序与 它们在文档中的次序一致。这是最常用的结果类型。</p>

<p>□    XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE:返回节点集合的快照，由于是在文档外部 捕获节点，因此对文档的后续操作不会影响到这个节点集合。集合中节点的次序不一定与它们 在文档中的次序••致。</p>

<p>□    XPathResult.ORDERED_NODE_SNAPSHOT_TYPE：返回节点集合的快照，由于是在文档外部捕 获节点，因此对文档的后续操作不会影响到这个节点集合。集合中节点的次序与它们在文挡中 的次序一致。</p>

<p>□    XPathResult .ANY_UNORDERED_NODE_TYPE:返回匹配的节点集合，但集合中节点的次序不 一定与它们在文档中的次序一致</p>

<p>□    XPathResult.FIRST_ORDERED_NODE_TYPE:返回只包含一个节点的节点集合，包含的这个 节点就是文档中第一个匹配的节点。</p>

<p>指定的结果类型决定了如何取得结果的值。下面来看一个典型的例子。</p>

<p>var result - xmldom.evaluate（&rdquo;employee/name&rdquo;, xmldom.documentElement, null,</p>

<p>XPathResult.ORDERED_NODE_ITERATOR_TYPE, null）;</p>

<p>if (result    null) {</p>

<p>var node = result.iterateNext(); while(node) {</p>

<p>alert(node.tagName); node = node.iterateNext{)?</p>

<p>}</p>

<p>}</p>

<p>DomXPatkExampleO 1. htm</p>

<p>这个例+中为返回结果指定的是XPathResult. ORDERED_NODE_ITERATOR_TYPE,也是最常用的 结果类型。如果没有节点匹配XPath表达式，evaluate （）返回null;否则,它会返回一个XPathResult 对象。这个XPathResult对象带有的属性和方法，可以用来取得特定类型的结果。如果节点是一个节 点迭代器，无论是次序一致还是次序不一致的，都必须要使用iterateNext （）方法从节点中取得匹配 的节点。在没有更多的匹配节点时，RerateNextO返回null。</p>

<p>如果指定的是快照结果类型（不管是次序•-致还是次序不一致的），就必须使用snapshotltemO 方法和snapshotLength属性，例如：</p>

<p>var result = xmldom.evaluate(<em>employee/name</em>, xmldom.documentElement# null,</p>

<p>XPathResult.ORDERED_NODE_SNAPSHOT_TYPE/ null)i</p>

<p>if (result !== null) {</p>

<p>for (var i»0, len=result.snapshotLength; i &lt; len; i++) { alert(result.snapshotltem(i).tagName)j</p>

<p>}</p>

<p>DomXPathExample02. htm</p>

<p>这里，snapshotLength返回的是快照中节点的数量，而snapshotltem()则返回快照中给定位 置的节点(与NodeList中的length和item ()相似)o</p>

<p>1.单节点结果</p>

<p>指定常量XPathResult. FIRST_ORDERED_NODE_TYPS会返回第-、个匹配的节点，可以通过结果 的singleNodeValue属性来访问该节点。例如：</p>

<p>var result = xmldom.evaluate(&lsquo;employee/name&rdquo;, xmldom.documentElement, null,</p>

<p>18</p>

<p>XPathResult.PIRST_ORDERED_NODE_TYPE, null)/</p>

<p>if (result !== null) {</p>

<p>alert(result•singleNodeValue.tagName)/</p>

<p>}</p>

<p>f)omXPathExamp!e03. htm</p>

<p>与前面的査询一样，在没有匹配节点的情况下，evaluate{)返回null。如果有节点返回，那么就 可以通过singleNodeValue属性来访问它。</p>

<p>2简单类型结果</p>

<p>通过XPath也可以取得简单的非节点数据类型，这时候就要使用XPathResult的布尔值、数值和 字符串类型了。这几个结果类型分别会通过booleanValue、numberValue和stringValue属性返 回一个值。对于布尔值类型，如果至少有一个节点与XPath表达式匹配，则求值结果返回true,否则 返回false。来看下面的例子。</p>

<p>var result = xmldom.evaluate(&ldquo;employee/name&rdquo;, xmldom.documentElement, null, XPathResult .BOOLEAN_TYPE, null&rdquo;</p>

<p>alert(result.booleanValue);</p>

<p>DomXPathExample04. htm</p>

<p>在这个例子中，如果有节点K配&rdquo;employee/name&rdquo;,则booleanValue属性的值就是true。</p>

<p>对于数值类型，必须在XPath表达式参数的位置上指定一个能够返回数值的XPath函数，例如计算</p>

<p>与给定模式匹配的所有节点数量的count ()o来看下面的例子。</p>

<p>var result = xmldom.evaluate(&ldquo;count(employee/name)■, xmldom.documentElement, null, XPathResult.NUMBER_TYPE, null};</p>

<p>alert(result.numberValue);</p>

<p>DomXPathExample05. htm</p>

<p>以上代码会输出与1*employee/naine”PQ配的节点数虽(即2 )。如果使用这个方法的时候没有指定 与前例类似的XPath函数，那么numberValue的值将等于NaNo</p>

<p>对于字符串类型，evaluate (&gt;方法会查找与XPath表达式匹配的第一个节点，然后返网其第一个 子节点的值(实际上是假设第一个子节点为文本节点)。如果没有匹配的节点，结果就是个空字符串。 来看一个例子。</p>

<p>t var result = xmldom.evaluate(-employee/name&rdquo;r xmldom.documentElement, null, XPathResult.STRING__TYPE# null);</p>

<p>alert(result.stringValue);</p>

<p>DomXPathExample06. htm</p>

<p>这个例子的输出结果中包含着与•element/name-K配的第一个元索的第&ndash;个子节点中包含的字 符串。</p>

<p>3.默认类型结果</p>

<p>所有XPath表达式都会ft动映射到特定的结果类塑。像前面那样设置特定的结果类型，可以限制表 达式的输出。而使用XPathResult.ANY_TYPE常量可以自动确定返回结果的类型。一般来说，fl动选 择的结果类型吋能是布尔值、数值、字符串值或一个次序不一致的节点迭代器。要确定返回的是什么结 果类型，可以检测结果的resultType属性，如下面的例子所示。</p>

<p>var result = xmldom.evaluate(■employee/name&rdquo;, xmldom.documentElement, null,</p>

<p>XPathResult .ANY_TYI&gt;E, null) j</p>

<p>if (result !== null) {</p>

<p>switch(result.resultType) {</p>

<p>case XPathResult.STRING_TYPE:</p>

<p>//处茂乎符争类炎 break;</p>

<p>case XPathResult.NUKBKR_TYPE: //处茂数值类塑 break;</p>

<p>case XPathResult.BOOLBAN_TYPE: //处殖布尔值类型 break；</p>

<p>case ZPathResuit.DKORDBRBD_NODE_ITKRATOR_TYPK: &ldquo;处殖次序不一致的节点遑代器美负 break;</p>

<p>default:</p>

<p>//处攻其他可能的結果类《</p>

<p>)</p>

<p>逋然，XPathResult.ANY_TYPE可以让我们更灵活地使用XPath,但是却要求有更多的处理代码 来处理返回的结果。</p>

<p>4.命名空间支持</p>

<p>对于利用了命名空间的XML文档，XPathEvaluator必须知道命名空间信息，然后才能正确地进 行求值。处理命名空间的方法也不止一种。我们以下面的XML代码为例。</p>

<p>&lt;?xml version=&ldquo;l.0&rdquo; ?&gt;</p>

<p><wrox:books xmlns:wrox="<http://www.wrox.com/>&rdquo;&gt; <wxox：book></p>

<p><wrox：title>Professional <a href="wrox:author">wrox:author</a>Nicholas C.</p>

<p>JavaScript for Web Developers</wrox:t i 11e> Zakas</wrox：author></p>

<p>Ajax</wrox：title> Zakas<a href="/wrox:author">/wrox:author</a></p>

<p><a href="/wrox:book">/wrox:book</a></p>

<p><wrox：book></p>

<p><wrox：title>Professional <wrox：author>Nicholas C.</p>

<p><a href="wrox:author">wrox:author</a>Jeremy KcPeak</wrox：author> <a href="wrox:author">wrox:author</a>Joe Fawcett</wrox：author></p>

<p></wrox：book></p>

<p><a href="/wrox:books">/wrox:books</a></p>

<p>在这个XML文档中，所有元索定义都来自http: //www.wrox.com/命名空间，以前缀wrox标识。 如果要对这个文档使用XPath,就需要定义要使用的命名空间；否则求值将会失败。</p>

<p>处理命名空间的第一种方法是通过createNSResolver ()来创建XPathNSResolver对象。这个 方法接受一个参数，即文档中包含命名空间定义的节点。对于前面的XML文构来说，这个节点就是文 档元素＜wrox:books＞，它的xmlns特性定义了命名空间。可以把这个节点传递给createNS-ResolverO ,然后可以像下面这样在evaluate ()屮使用返问的结果。</p>

<p>18</p>

<p>var nsresolver =： xmldora.createNSResolver(xmldom.documentElement)?</p>

<p>var result = xmldom.evaluate(&ldquo;wrox:book/wrox:author0,</p>

<p>xmldom.documentElement, nsresolver,</p>

<p>XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);</p>

<p>alert(result.snapshotLength)?</p>

<p>DomXPathExampleO 7. htm</p>

<p>在将nsresolver对象传人到evaluate ()之后，就可以确保它能够理解XPath表达式中使用的 wrox前缀。读者可以试一试使用相同的表达式，如果不使用XPathNSResolver的话，就会导致错误s</p>

<p>处理命名空间的第二种方法就是定义一个函数，让它接收&ndash;个命名空间前缀，返回关联的URI, 例如：</p>

<p>var nsresolver - function(prefix){ switch(prefix){</p>

<p>case &ldquo;wrox&rdquo;: return &ldquo;<a href="http://www.wrox.com/">http://www.wrox.com/</a>&rdquo;;</p>

<p>//其他前级</p>

<p>}</p>

<p>var result = xmldom.evaluate(&ldquo;count(wrox:book/wrox：author)&ldquo;,</p>

<p>xmldom.documentElement, nsresolver, XPathResult.NUMBER—TYPE, null);</p>

<p>alert(result.numberValue);</p>

<p>DomXPathExample08. htm</p>

<p>在不确定文档中的哪个货点包含命名空间定义的情况下，这个命名空间解析函数就可以派上用场 了。只要你知道前缀和URI,就可以定义一个返回该信息的函数，然后将它作为第H个参数传递给 evaluate ()即可o</p>

<p>18.2.2 IE 中的 XPath</p>

<p>IE对XPath的支持是内置在基于ActiveX的XML DOM文档对象中的，没有使用DOMParser返回 的DOM对象。因此，为了在IE9及之前的版本中使用XPath,必须使用基于ActiveX的实现。这个接 口在每个节点上额外定义了两个的方法：selectSingleNode&lt;)和selectNodes() o其巾， selectSingleNodeO方法接受一个XPath模式，在找到配节点时返回第一个匹配的节点，如果没有 找到匹配的节点就返凹null。例如：</p>

<p>var element = xmldom.dociinientElement. selectSingleNode (&ldquo;employee/name&rdquo;) ?</p>

<p>if (element 1== null){ alert(element.xml)；</p>

<p>}</p>

<p>IEXPathExampleO 1. htm</p>

<p>这里，会返回匹配&rdquo;employ ee/name&rdquo;的第-个节点。上下文节点是xmldom. document Element, 因此就调用了该节点上的selectSingleNodeO。由于调用这个方法可能会返回null值，因而有必 要在使用返回的节点之前，先检査确定它不是null。</p>

<p>另一个方法selectNodes ()也接收一个XPath模式作为参数，但它返回与模式匹配的所有节点的 NodeList (如果没有匹配的节点，则返回一个包含零项的NodeList )。来看下面的例子。</p>

<p>var elements = xmldom.documentElement.selectNodes(&ldquo;employee/name&rdquo;)； alert{elements.length)；</p>

<p>IEXPathExampleO2. htm</p>

<p>对这个例子而言，PU配&rdquo;employee/name&rdquo;的所有元索都会通过NodeList返回。由T不可能返问 null值，因此可以放心地使用返间的结果。但要记住，既然结果是NodeList,而其包含的元素可能 会动态变化，所以每次访问它都有可能得到不同的结果。</p>

<p>IE对XPath的支持非常简单。除了能够取得一个节点或一个NodeList外，不可能取得其他结果 类型。</p>

<p>IE对命名空间的支持</p>

<p>要在IE中处理包含命名空间的XPath表达式，你必须知道A己使用的命名空间，并按照下列格式 创建一个字符串：</p>

<p>&ldquo;xmlns：prefixl=&lsquo;uril&rsquo; xmlns:prefix2=&lsquo;uri2&rsquo; xmlns:prefix3=*uri3 *&rdquo;</p>

<p>然后，必须将这个字符串传入到XMLDOM文档对象的特殊方法set Property (&gt;中，这个方法接 收两个参数：耍没置的厲性名和属性值。在这坦，属性名应该是-SelectionNamespaces，，属性值就 是按照前面格式创建的字符串。下面来看一个在DOM XPath命名空间中对XML文档求值的例子。</p>

<p>xmldom.set Property(•SelectionNamespaces&rdquo;, &ldquo;xmlns:wrox= * <a href="http://www.wrox.com/'*%7d">http://www.wrox.com/&rsquo;*}</a>;</p>

<p>var result = xmldom.documentElement.selectNodes(&ldquo;wrox：book/wrox：author&rdquo;); alert(result.length);</p>

<p>IEXPathExampleO3. htm</p>

<p>对于这个DOMXPath的例子来说，如果不提供命名空间解析信息，就会在对表达式求值时导致-个错误，</p>

<p>18.2.3跨浏览器使用XPath</p>

<p>鉴丁- IE对XPath功能的支持有限，因此枠浏览器XPath只能保证达到IE支持的功能。换句话说， 也就是要在其他使用DOM3级XPath对象的浏览器中，重新创建selectSingleNodeU和 selectNodes&lt;)方法。第一•个困数是selectSingleNode (),它接收三个参数：上下文节点、XPath 表达式和可选的命名空间对象。命名空间对象应该是下面这种字面量的形式。</p>

<p>{</p>

<p>prefixl: *uril”， prefix2: &ldquo;uri2&rdquo;, prefix3: *uri3&rdquo;</p>

<p>}</p>

<p>以这种方式提供的命名空间信息，可以方便地转换为针对特定浏览器的命名空间解析格式。下面给 出了 selectSingleNode ()函数的完整代码。</p>

<p>18</p>

<p>function selectSingleNode{context, expression, namespaces){</p>

<p>var doc = (context.nodeType != 9 ? context.ownerDocuroent : context)；</p>

<p>if (typeof doc.evaluate != &ldquo;undefined&rdquo;){ var nsresolver = null; if (namespaces instanceof Object}{</p>

<p>nsresolver = function (pref ixH return namespaces[prefix];</p>

<p>}；</p>

<p>}</p>

<p>var result = doc.evaluate(expression, context, nsresolver,</p>

<p>XPathResult.FIRST_ORDERED_NODE_TYPE# nul1);</p>

<p>return (result J == null ? result.singleNodeValue : null);</p>

<p>} else if (typeof context.selectSingleNode i= &ldquo;undefined&rdquo;){</p>

<p>//创建命名空间字符亊</p>

<p>if (namespaces instanceof Object){ var ns =&ldquo;&ldquo;；</p>

<p>for (var prefix in namespaces){</p>

<p>if (namespaces.hasOwnProperty(prefix)}{</p>

<p>ns += &ldquo;xmlns：■ + prefix + &ldquo;=&lsquo;&rdquo; + namespaces tprefix] + *&rsquo;</p>

<p>}</p>

<p>}</p>

<p>doc.setProperty{•SelectionNamespaces*, ns)；</p>

<p>}</p>

<p>return context.selectSingleNode(expression)；</p>

<p>} else {</p>

<p>throw new Error(&ldquo;No XPath engine found.&rdquo;);</p>

<p>}</p>

<p>CrossBrowserXPathExampleOJ .htm</p>

<p>这个函数首先要确定XML文档，以便基于该文档对表达式求值。由于上下文节点可能是文档，所 以必须要检测nodeiype属性。此后，变量doc中就会保存对XML文档的引用。然后，可以检测文档 中是否存在evaluate ()方法，即是否支持DOM3级XPath。如果支持，接下来就是检测传人的 namespaces对象。在这里使用instanceof操作符而不是typeof,是因为后者对null也返回 &ldquo;object-。然后将nsresolver变量初始化为null,如来提供了命名空间信息的话，就将其改为一 个函数。这个函数是一个闭包，它使用传人的namespaces对象来返回命名空间的URI。此后，调用 evaluated方法，并对其结果进行检测，在确定是节点之后再返冋该结果。</p>

<p>在这个函数针对DE的分支中，需要检査context节点中是否存在selectSingleNode()方法：，与UOM 分支一样，这里的第一步是有选择地构建命名空间信息。如果传人了 namespaces对象，则迭代其属性并以 适冉格式创建一^字符串。注意，这里使用了 hasOwnProperty。方法来确保对Object .prototype的任何 修改都不会影晌到当前函数。最后，调用原生的selectSingleNodeO方法并返回结果。</p>

<p>如果前面两种方法都没有得到支持，这个函数就会抛出一个错误，表示找不到XPath处理引擎。下 面是使用selecCSingleNode ()涵数的示例。</p>

<p>var result = selectSingleNode(xmldom.documentElement, &ldquo;wrox:book/wrox：author&rdquo;,</p>

<p>{ wrox: &ldquo;<a href="http://www.wrox.com/">http://www.wrox.com/</a>&rdquo; });</p>

<p>alert(seriali2eXml(result))；</p>

<p>CrossBrowserXPathExampleOl .htm</p>

<p>类似地，也町以创建一个跨浏览器的selectNodes ()函数。这个两数接收与selectSingle-Node()相同的三个参数，而且大部分逻辑都相似。为了便于看清楚，我们用加粗字体突出了这两个函 数的差别所在。    &lsquo;</p>

<p>function selectNodes(context, expression, namespaces}{</p>

<p>var doc = (context.nodeType 9 ? context.ownerDocument : context);</p>

<p>if (typeof doc.evaluate [= ■undefined&rdquo;){ var nsresolver = null； if (namespaces instanceof Object){</p>

<p>nsresolver = function(prefix){ return namespaces[prefix]；</p>

<p>};</p>

<p>}</p>

<p>var result = doc.evaluate(expresBion, context, nsresolver,</p>

<p>XPathReault.ORDERED_NODE_SNAPSHOT_TYPE, null);</p>

<p>var nodes ■ new Array()j</p>

<p>if (result 1== null){</p>

<p>for (var i=0, len-reault.snapshotLezigtb.; i &lt; lezx; i++) { nodes.push(result.snapshotItem(i))t</p>

<p>}</p>

<p>}</p>

<p>return nodes;</p>

<p>} else if {typeof context.selectNodes i= ■undefined-){</p>

<p>//创建命名空间字符串</p>

<p>if (namespaces instanceof Object){ var ns = &ldquo;■；</p>

<p>for (var prefix in namespaces){</p>

<p>if (namespaces.hasOwnProperty(prefix)){</p>

<p>ns ♦= &ldquo;xmlns:&rdquo; + prefix + ■=•■ + namespaces[prefix] +</p>

<p>)</p>

<p>}</p>

<p>doc.setProperty(&ldquo;SelectionNamespaces&rdquo;, ns);</p>

<p>}</p>

<p>var result 里 context.selectNodes(expression)j var nodes = new Array();</p>

<p>for (var i*0,len-result.length; i &lt; len； i++){ nodes.push(result[i】&gt;;</p>

<p>)</p>

<p>return nodes；</p>

<p>} else {</p>

<p>throw new Error(&ldquo;No XPath engine found.&rdquo;};</p>

<p>}</p>

<p>I—MW— 18</p>

<p>CrossBro\vserXPathExample02. htm</p>

<p>很明显，其中有很多逻辑都与selectSingleNodeO方法相同。在函数针对DOM的部分，使用 了有序快照结果类型，然后将结果保存在了一个数组中。为了与IE的实现看齐，这个函数应该在没找 到匹配项的情况下也返回一个数组，因而最终都要返回数组nodes。在函数针对IE的分支中，调用了 selectNodes 0方法并将结果复制到_T一个数组中。因为IE返回的是一个NodeList,所以最好将节 点都复制到一个数组中，这样就可以确保在不同浏览器下，函数都能返回相同的数据类型。使用这个函 数的示例如下：</p>

<p>var result = selectNodes(xmldom.documentElement, *wrox:book/wrox:author■, { wrox： •<a href="http://www.wrox.com/&quot;">http://www.wrox.com/&quot;</a> });</p>

<p>alert(result.length);</p>

<p>CrossBrawserXPathExample02. htm</p>

<p>为了求得最佳的浏览器廉容性，我们建议在JavaScript中使用XPath时，只考虑使用这两个方法。</p>

<p>18.3浏览器对XSLT的支持</p>

<p>XSLT是与XML相关的一种技术，它利用XPath将文档从一种表现形式转换成另一种表现形式。与 XML和XPath不同，XSLT没有正式的API,在正式的DOM规范中也没有它的位置。结果，只能依靠 浏览器开发商以自己的方式来实现它。IE是第一个支持通过JavaScript处理XSLT的浏览器。18.3.1 IE 中的 XSLT</p>

<p>与IE对其他XML功能的支持一样，它对XSLT的支持也是通过ActiveX对象实现的。从MSXML3.0 （即圧6.0 ）时代起，IE就支持通过JavaScript实现完整的XSLT 1.0操作。IE9中通过DOMParser创建 的DOM文档不能使用XSLT。</p>

<p>1.简单的XSLT转換</p>

<p>使用XSLT样式表转换XML文档的最简单方式，就是将它们分别加到一个D0M文档中，然后再 使用transformNodeO方法。这个方法存在于文档的所有节点中，它接受一个参数，即包含XSLT样 式表的文档。调用transformNode ()方法会返回一个包含转换信息的字符串。來看一个例子。</p>

<p>//加载XML和XSLT (仅限于IE) xmldom.load(&ldquo;employees.xml&rdquo;); xsltdom.load{&ldquo;employees.xslt&rdquo;)；</p>

<p>//转换</p>

<p>var result = xmldom.transformNode(xsltdom};</p>

<p>IEXsltExampleO 1. htm</p>

<p>这个例子加载了一个XML的DOM文档和一个XSLT样式表的DOM文档。然后，在XML文档节 点上调用了 transformNodeO方法，并传人XSLT。变盘result中最后就会保存一个转换之后得到 的字符串。需要注意的是，由于是在文档节点级别上调川的transformNodeO,因此转换是从文档节 点开始的。实际上，XSLT转换可以在文档的任何级别上进行，只要在想要开始转换的节点上调用 transfortnNode 0方法即可。下面我们來看一个例子。</p>

<p>result = xmldom.documentElement.transformNode{xsltdom}; result = xmldom.documentElement.childNodes[1].transformNode(xsltdom)； result = xmldom.getElementsRyTagName(&ldquo;name&rdquo;)[0].transformNode(xsltdom)； result = xmldom.documentElement.firstChild.lastChild.transformNode(xsltdom);</p>

<p>如果不是在文档元素上调用transformNodeO,那么转换就会从调用节点上面开始。不过，XSLT 样式表则始终都可以针对调用节点所在的整个XML文档，而无需更换。</p>

<p>2.复杂的XSLT转换</p>

<p>虽然transformNodeO方法提供了基本的XSLT转换能力，但还有使用这种语言的更复杂的方式。</p>

<p>为此，必须要使用XSL模板和XSL处理器。第一步是要把XSLT样式表加载到一个线程安全的XML</p>

<p>文申当中。而这可以通过使用ActiveX对象MSXML2 . FreeThreadedDOMDocument来做到。这个ActiveX</p>

<p>对象与IE中常规的DOM支持相同的接口。此外，创建这个对象时应该尽可能使用最新的版本。例如：</p>

<p>function createThreadSafeDocument(){</p>

<p>if (typeof arguments.callee.activeXString != &ldquo;string&rdquo;){</p>

<p>var versions - [nMSXML2.FreeThreadedDOMDocument.6^0&rdquo;z &ldquo;MSXML2.FreeThreadedDOMDocument.3.0*,</p>

<p>&ldquo;MSXML2.FreeThreadedDOMDocument,</p>

<p>i, len；</p>

<p>for (i=0,len=versicms.length; i &lt; len； i++){ try {</p>

<p>new ActiveXObject(versions[i]); arguments.callee.activeXString = versions[i]; break;</p>

<p>} catch (ex){</p>

<p>//跳过</p>

<p>}</p>

<p>}</p>

<p>}</p>

<p>return new ActiveXObject{arguments.callee.activeXString)；</p>

<p>IEXsltExampleO2. htm</p>

<p>除了签名不同之外，线程安全的XMLDOM文梢与常规XMLDOM文档的使用仍然是一样的，如 下所示：</p>

<p>var xsltdom = createThreadSafeDocument()? xsltdom.async = false; xsltdom.load(&ldquo;employees.xslt&rdquo;)；</p>

<p>在创建并加载f自由线程的DOM文档之后，必须将它指定给一个XSL模板，这也是一个ActiveX 对象。而这个模板是用来创建XSL处理器对象的，后者则是用来转换XML文料的。同样，也需要使用 最新版本来创建这个对象，如下所示：</p>

<p>function createXSLTemplate(){</p>

<p>if (typeof arguments.callee.acLiveXString 1= &ldquo;string&rdquo;){</p>

<p>var versions = [&ldquo;MSXML2.XSLTemplate.6.0*,</p>

<p>-MSXML2.XSLTemplate.3.C&rdquo;,</p>

<p>&ldquo;MSXML2.XSLTemplate&rdquo;1#</p>

<p>i, len；</p>

<p>18</p>

<p>for (i=0#len=versions.length； i &lt; len； i++){ try {</p>

<p>new ActiveXObject(versions[i])；</p>

<p>arguments.callee.activeXString = versions[i];</p>

<p>break;</p>

<p>} catch (ex){</p>

<p>//跳过</p>

<p>}</p>

<p>}</p>

<p>return new AcLiveXObject(arguments.callee.activeXString);</p>

<p>}</p>

<p>IEXsltExampleO2. htm</p>

<p>使用这个createXSLTemplate ()函数可以创建这个对象最新版本的实例，用法如下：</p>

<p>var template = createXSLTemplate()； template.stylesheet = xsltdom；</p>

<p>var processor = template.createProcessor(); processor.input = xmldom； processor.transform(); var result = processor.output；</p>

<p>IEXsltExampleO2. htm</p>

<p>在创建了 XSL处理器之后，必须将要转换的节点指定给input屈性。这个值可以是一个文档，也 可以是文档中的任何节点。然后，调用tranSform()方法即可执行转换并将结果作为字符串保存在 output属性中。这些代码实现了与transformNode()相同的功能。</p>

<p>XSL模板对象的3.0和6.0版本存在显著的差别。在3.0版本中，必须给input 属性指定一个完整的文档；如果指定的是节点，就会导致钳谈。而在6.0版本中，则 可以为input展性指定文桂中的任何节点。</p>

<p>使用XSL处理器可以对转换进行更多的控制，同时也支持更髙级的XSLT特性。例如，XSLT样式 表可以接受传人的参数，并将其用作局部变量。以下面的样式表为例：</p>

<p>&lt;?xml version=&ldquo;1.0*?&gt;</p>

<p><xsl:stylesheet version="1.0" xmlns:xsl = *http: "[www.w3.org/1999/XSL/Transform](http://www.w3.org/1999/XSL/Transform)"></p>

<p><xsl：output method=•html"/></p>

<p><xsl: parajn name="message"/></p>

<p><xsl：template match="/"></p>

<ul>

<xsl:apply-templates selects**•/>

</ul>

<p>Message: <xsl: value-of select = -$message''/></p>

<p><a href="/xsl:template">/xsl:template</a></p>

<p><xsl:template match="employee"></p>

<p><lixxsl ： value-of select = "name" />,</p>

<p><emxxsl: value-of select=w@title"/></em></li></p>

<p><a href="/xsl:template">/xsl:template</a></p>

<p><a href="/xsl:stylesheet">/xsl:stylesheet</a></p>

<p>employees.xslt</p>

<p>这个样式表定义了一个名为message的参数，然后将该参数输出到转换结果中。要设置message 的值，可以在调用transform{）之前使用addParameterG方法。addParameter（）方法接收两个参 数：要设置的参数名称（与在<xsl :%^1（1>的name特性中指定的一样）和要指定的值（多数情况下是 字符串，但也可以是数值或布尔值）。下面就是这样•、个例子。</p>

<p>processor.input = xmldom.document E1emen t; processor.addParameter（&rdquo;message&rdquo;, &ldquo;Hello World!&rdquo;}; processor.transform（）;</p>

<p>IEXsltExampleO3. htm</p>

<p>通过设置参数的值，这个值就可以在输出中反映出来。</p>

<p>XSL处理器的另一个髙级特性，就是能够设置一种操作模式。在XSLT中，可以使用mode特性为 模板定义一种模式。在定义了模式后，如果没有将&lt;xsl:apply-templates:^匹配的mode特性一起 使用，就不会运行该模板。下面来看一个例子。</p>

<p><xsl:stylesheet version='l.0” xmlns：xsl="http：//www,w3.org/1999/XSL/Transform"></p>

<p><xsl:output method="html"/></p>

<p><xsl:param name="message"/></p>

<p><xsl:template match="/"></p>

<ul>

<xsl:apply-templates select=B*■/>

</ul>

<p>Message: <xsl：value-of select=*$message"/></p>

<p>&lt;/xsl:template〉</p>

<p><xsl：template match= * employee"></p>

<p><lixxsl：value-of select:"name”/>,</p>

<p><emxxsl: value-of select-■ itlew/x/emx/li> &lt;/xsl:template〉</p>

<p><xsl:template match="employee" mode="title-first"> <lixemxxsl:value-of select="@title"/x/em>#</p>

<p><xsl:value-of select:"name"/></li></p>

<p>&lt;/xsl:template〉</p>

<p><a href="/xsl:stylesheet">/xsl:stylesheet</a></p>

<p>employees 3.xs It</p>

<p>这个样式表定义了一个模板，并将其mode特性设置为“title-first-(即“先显示职位”)。在这 个模板中，首先会输出员工的职位，其次才输出员工的名字。为了使用这个模板，必须也要将 <a href="xsl:apply-templates">xsl:apply-templates</a>元素的模式设置为&rdquo;title-first&rdquo;。在使用送个样式表时，默认情况下其 输出结果与前面一样，先显示员工的名字，再显示员工的职位。但是，如果在使用这个样式表时，使用 JavaScript将模式设置为&rdquo;title-first&rdquo;，那么结果就会先输出员工的职位。在JavaScript中使用 setStartMode {)方法设置模式的例f如下。</p>

<p>18</p>

<p>processor.input = xmldom；</p>

<p>processor .addParameter {&ldquo;message&rdquo;, &ldquo;Hello World!”； processor.setStartMode{&ldquo;title-first&rdquo;); processor.transform()?</p>

<p>!EXsltExampleO5. htm</p>

<p>setStartMode^方法只接受一个参数，即要为处理器设置的模式。与addParameter (&gt;—样，设 置模式也必须在调用transform!)之前进行。</p>

<p>如果你打算使用同一个样式表进行多次转换，可以在每次转换之后重置处理器。调用reset (&gt;方法 后，就会清除原先的输人和输出属性、启动模式及其他指定的参数。调用reset ()方法的例子如下：</p>

<p>processor.reset ();    //准备下一次转换</p>

<p>因为处理器已经编译了 XSLT样式表，所以与使用transformNodeU相比，这样进行重复转换的 速度会更快一些。</p>

<p>MSXML只支持XSLT 1.0。由于微软的战略重点转移到了 .NETFramework,因而 fMSXML的开发被停止了。我们希望在不久的将来，能够通过JavaScript访问XML和 XSLT .NET 对象</p>

<p>18.3.2 XSLTProcessor 类型</p>

<p>Mozilla通过在Firefox中创建新的类型，实现了 JavaScript对XSLT的支持。开发人员可以通过 XSLTProcessox•类型使用XSLT转换XML文格，其方式与在IE中使用XSL处理器类似。因为这个类 型是申•先出现的，所以Chrome、Safari和Opera都借鉴丫相同的变现，最终使XSLTProcessor成为了 通过JavaScript进行XSLT转换的事实标准。</p>

<p>与IE的实现类似，第一步也是加载两个DOM文裆，一个基于XML,另一个基于XSLT。然后， 创建•个新XSLTProcessor对象，并使用importstylesheet ()方法为其指定一个XSLT，如下面 的例子所示。</p>

<p>var processor = new XSLTProcessor{) processor.importStylesheet(xaltdom);</p>

<p>XsltProcessorExampleOl. him</p>

<p>最后一步就是执行转换。这■&rsquo;步有两种不同的方式，如果想返问~个完整的DOM文档，可以调用 transf ormToDocument () a而通过调用transf ormToFragment ()则可以得到一个文相片段对象。一 般来说，便用transformToFragmentO的唯一理由，就是你还想把返回的结果添加到另一个DOM文 档中。</p>

<p>在使川transformToDocument (＞时，只要传入XML DOM,就可以将结果作为一个完全不同的 DOM文档来便用。来看下面的例子。</p>

<p>var result = processor.transformToDocument(xmldom)； alert{serializeXml(result));</p>

<p>XsltProcessorExampleO 1 .htm</p>

<p>而transf ormToFragment ()方法接收两个参数：要转换的XML DOM和应该拥有结果片段的文 档。换句话说，如果你想将返M的片段插人到页面中，只要将document作为第二个参数即可。下面来 看一个例子。</p>

<p>var fragment = processor.transformToDocument(xmldom, document)； var c.iv = document .getElementById( &ldquo;divResult&rdquo;)； div.appendChiId(fragment)；</p>

<p>XsltProcessorExample02、htm</p>

<p>这S,处理器创建T-个由document对象拥有的片段。这样，就可以将返回的片段添加到页面中 已有的《3iV；•元索中了。</p>

<p>在XSLT样式表的输出格式为‘•3^1»或41；11＞1 •的情况下，创建文档或文档片段会非常有用。不过， 在输出格式为“text。时，我们通常只希望得到转换的文本结果。时惜的是，没有方法能够直接返回文 本。当输出格式为&rdquo;text&rdquo;时调用transformToDocument (),仍然会返回一个完整的XML文档，但 这个文档的内容在不同浏览器中却不一样。例如，Safari会返回一个完整的HTML文档，而Opera和 Firefox则会返回~个只包含一个元索的文档.这个元素巾包含着输出的文本。</p>

<p>使用transf ormToFragment (＞方法可以解决这个问题，这个方法返回的是只包含一个子节点的文 档片段，而子节点中包含着结果文本。然后，使用下列代码就可以取得其中的文本。</p>

<p>var fragment = processor.transformToFragment(xmldom, document); var text = fragment.firstchild.nodeValue； alert(text):</p>

<p>以上代码能够在支持的浏览器中一致地运行，而且能够恰好返问转换得到的输出文本。</p>

<p>1.使用参数</p>

<p>XSLTProcessor也支持使JH setParameterU来设置XSLT的参数，这个方法接收三个参数：命名空间</p>

<p>URI、参数的内部名称和要没置的值。通常，命名空间URI都是null，而内部名称就是参数的名称。另外， 必须在凋用transfonnToDocuinerJ: (｝或transformToFragrnent ()之前调用这个方法。下面来看例子。</p>

<p>var processor = new XSLTProcessor() processor.importStylesheet(xsltaom);</p>

<p>processor.setParameter(nullf &ldquo;message&rdquo;, &ldquo;Hello World!&rdquo;); var result = processor.transformToDocument(xmldom)；</p>

<p>XsltProcessorExamp!e03 .htm</p>

<p>还々W个与参数有关的方法，getParameter ()和remove Parameter (),分别用于取得和移除.当 前参数的值。这两个方法都要接受命名空间参数(同样，通常是null)和参数的内部名称。例如：</p>

<p>var processor = new XSLTProcessor() processor.importStylesheet(xsltdom);</p>

<p>processor. setParameter (null, &ldquo;message&rdquo;, -Hello World! ;</p>

<p>alert (processor .getParameter (null, &ldquo;message&rdquo;)) ;    //檢出&rdquo;Hello World!&rdquo;</p>

<p>18</p>

<p>processor.removeParameter(null, *message&rdquo;};</p>

<p>var result = processor.transformToDocument(xmldom)；</p>

<p>这两个方法并不常用，提供它们只是为了方便起见。</p>

<p>2.重置处理器</p>

<p>每个XSLTProcessor的实例都可以重用，以便使川不同的XSLT样式表执行不同的转换。重置处 理器时耍调用reset ()方法，这个方法会从处理器中移除所有参数和样式表。然后，你就可以再次调用 importStylesheet (),以加载不同的XSLT样式表，如下面的例子所示。</p>

<p>var processor = new XSLTProcessor() processor.importStylesheet(xsltdom)；</p>

<p>//执行转换</p>

<p>processor.reset();</p>

<p>processor.importStylesheet(xsltdom2)；</p>

<p>//再执行转换</p>

<p>在滞要基于多个样式表进行转换时，重用一个XSLTProcessor可以节省内存。</p>

<p>18.3.3跨浏览器使用XSLT</p>

<p>IE对XSLT转换的支持与XSLTProcessor的IX别实在太大，闽此要想重新实现二者所有这方面的 功能并不现实。因此，跨浏览器兼容性最好的XSLT转换技术，只能是返冋结果字符串。为此在IE中只 需在上下文节点上调用transformNodeU即可，而在其他浏览器中则雷要序列化transformTo-Document {)操作的结果。下&rsquo;面这个函数町以在IE、Fircfox、Chrome、Safari和Opera中使用。</p>

<p>function transform(context, xslt){</p>

<p>if (typeof XSLTProcessor != &ldquo;undefined&rdquo;){</p>

<p>var processor = new XSLTProcessor(}; processor.importStylesheet(xslt);</p>

<p>var result = processor.transformToDocument(context); return (new XMLSerializer()).serializeToString(result);</p>

<p>} else if (typeof context.transformNode i = &ldquo;undefined&rdquo;)    {</p>

<p>return context.trans formNode(xslt);</p>

<p>&gt; else {</p>

<p>throw new Error(&ldquo;No XSLT processor available.*);</p>

<p>}</p>

<p>CrossBrawserXsltExampleOl. htm</p>

<p>这个transform()函数接收两个参数：要执行转换的上下文节点和XSLT文档对象。首先，它检 测是否有XSLTProcessor类型的定义，如果有则使用该类型来进行转换。在调用transformTo-Document ()方法之后，将返冋的结果序列化为字符串。如果上下文节点中有trans formNode ()方法， 则调用该方法并返回结果。与本章中其他的跨浏览器函数一样，transform)也会在XSLT处理器无效 的情况下抛出错误。下面是使用这个函数的示例。</p>

<p>var result = cransform(xmldom, xsltdom);</p>

<p>使用IE的transformNodeO方法，可以确保不必使用线程安全的DOM文待进行转换。</p>

<p>注意，由于不同浏览器的XSLT引擎不一样，因此转换得到的结果在不同浏览器</p>

<p>&lsquo;C(/间可能会稍有不同，也可能会差别很大。因此，不能绝对依箱在JavaScript中使用XSLT 进行转换的结果。</p>

<p>18.4小结</p>

<p>JavaScript对XML及其相关技术有相当大的支持。然而，由于缺乏规范，共同的功能却存在一些不 同的实现。D0M2级提供了创建空XML文档的API,但没有涉及解析和序列化。既然规范没有对这些 功能作出规定，浏览器提供商就各行其是，拿出了自己的实现方案。IE采取了下列方式。</p>

<p>□通过ActiveX对象来支持处理XML,而相同的对象也可以用来构建桌面应用程序。</p>

<p>□    Windows携带了 MSXML库，JavaScript能够访问这个库。</p>

<p>□这个库中包含对基本XML解析和序列化的支持，同时也支持XPath和XSLT等技术。</p>

<p>Fircfox为处理XML的解析和序列化，实现丫两个新类型，简介如下。</p>

<p>□    DOMParser类型比较简单，其对象可以将XML字符串解析为DOM文档。</p>

<p>□    XMLSerializer类型执行相反的操作，即将DOM文裆序列化为XML字符串。</p>

<p>由于Firefox中的类型比较简单，用户众多，1E9、Opera、Chrome和Safari都相继实现了相同的类 型。因此，这些类型也就成为了 Web开发中的事实标准。</p>

<p>D0M3级引人了一^t&rdquo;针对XPath API的规范，该规范已经由Firefox、Safari、Chrome和Opera实现。 这些API可以让JavaScript基于DOM文档运行任何XPath査询，并且能够返冋任何数据的结果。IE以 自己的方式实现了对XPath的支持；具体来说，就是两个方法：selectSingleNodeO和 selectNodesOo虽然与DOM3级API相比还存在诸多限制，但使用这两个方法仍然能够执行基本的 XPath功能，即在DOM文档中査找节点或节点集合。</p>

<p>与XML相关的最后一种技术是XSLT,没有公开发布的标准针对这种技术的功能定义相应的API。 Firefox为通过JavaScript处理转换创建了 XSLTProcessor类渤；此后不久，Safari、Chrome、和Opera 也都实现了同样的类塑。IE则针对XSLT提供了自己的方案，一个是简卑的transformNodeO方法， 另一个是较为复杂的模板/处理器手段。</p>

<p>目前，IE、Firefox、Chrome和Opera都能够较好地支持XML。虽然IE的实现与其他浏览器相比差 异比较大，但仍然还是宥较多的公共功能可供我们实现跨浏览器的方案。</p>

    </div>

    
    

    
    

    <footer class="post-footer">
      

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/05-%E5%9F%BA%E7%A1%80%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/12-%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/js/js19-e4x/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">JS19 E4X</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/05-%E5%9F%BA%E7%A1%80%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/12-%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/js/js17-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E8%B0%83%E8%AF%95/">
            <span class="next-text nav-default">JS17 错误处理与调试</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="iteratelyd@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="http://github.com/iterateself" class="iconfont icon-github" title="github"></a>
      <a href="https://www.zhihu.com/people/thebegin/activities" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="https://www.douban.com/people/68028070/" class="iconfont icon-douban" title="douban"></a>
  <a href="http://iterate.site/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> site pv: <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
    <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> site uv: <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2018
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">iterateself</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>


<script type="text/javascript" src="/dist/even.min.js?v=3.2.0"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>








</body>
</html>
