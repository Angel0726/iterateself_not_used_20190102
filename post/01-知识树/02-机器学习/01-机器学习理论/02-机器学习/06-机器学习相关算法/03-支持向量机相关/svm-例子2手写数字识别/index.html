<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>SVM 例子2：手写数字识别 - 迭代自己</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="iterateself" />
  <meta name="description" content="author: evo comments: true date: 2018-05-10 13:16:01&#43;00:00 layout: post link: http://106.15.37.116/2018/05/10/svm-sample2/ slug: svm-sample2 title: wordpress_id: 5514 categories: - 随想与反思 [mathjax] 注：非原创，推荐直接看原文 ORIGINAL 1. [第6章 支持向量机](http://ml.apachecn.o" />

  <meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.47.1" />


<link rel="canonical" href="http://iterate.site/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/02-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/01-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%90%86%E8%AE%BA/02-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/06-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/03-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%E7%9B%B8%E5%85%B3/svm-%E4%BE%8B%E5%AD%902%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">




<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<link href="/dist/even.min.css?v=3.2.0" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">




<meta property="og:title" content="SVM 例子2：手写数字识别" />
<meta property="og:description" content="author: evo comments: true date: 2018-05-10 13:16:01&#43;00:00 layout: post link: http://106.15.37.116/2018/05/10/svm-sample2/ slug: svm-sample2 title: wordpress_id: 5514 categories: - 随想与反思 [mathjax] 注：非原创，推荐直接看原文 ORIGINAL 1. [第6章 支持向量机](http://ml.apachecn.o" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://iterate.site/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/02-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/01-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%90%86%E8%AE%BA/02-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/06-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/03-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%E7%9B%B8%E5%85%B3/svm-%E4%BE%8B%E5%AD%902%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/" /><meta property="article:published_time" content="2018-08-03T12:24:52&#43;00:00"/>
<meta property="article:modified_time" content="2018-08-03T12:24:52&#43;00:00"/>
<meta itemprop="name" content="SVM 例子2：手写数字识别">
<meta itemprop="description" content="author: evo comments: true date: 2018-05-10 13:16:01&#43;00:00 layout: post link: http://106.15.37.116/2018/05/10/svm-sample2/ slug: svm-sample2 title: wordpress_id: 5514 categories: - 随想与反思 [mathjax] 注：非原创，推荐直接看原文 ORIGINAL 1. [第6章 支持向量机](http://ml.apachecn.o">


<meta itemprop="datePublished" content="2018-08-03T12:24:52&#43;00:00" />
<meta itemprop="dateModified" content="2018-08-03T12:24:52&#43;00:00" />
<meta itemprop="wordCount" content="1969">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="SVM 例子2：手写数字识别"/>
<meta name="twitter:description" content="author: evo comments: true date: 2018-05-10 13:16:01&#43;00:00 layout: post link: http://106.15.37.116/2018/05/10/svm-sample2/ slug: svm-sample2 title: wordpress_id: 5514 categories: - 随想与反思 [mathjax] 注：非原创，推荐直接看原文 ORIGINAL 1. [第6章 支持向量机](http://ml.apachecn.o"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">迭代自己</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">主页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a><a href="/catalog/">
        <li class="mobile-menu-item">目录</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">迭代自己</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">主页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/catalog/">目录</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">SVM 例子2：手写数字识别</h1>

      <div class="post-meta">
        <span class="post-time"> 2018-08-03 </span>
        
        <span class="more-meta"> 1969 words </span>
        <span class="more-meta"> 4 mins read </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> times read </span>
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  
  <div class="post-toc-content">
    <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#随想与反思">- 随想与反思</a></li>
</ul></li>
<li><a href="#original">ORIGINAL</a>
<ul>
<li><a href="#需要补充的">需要补充的</a></li>
</ul></li>
<li><a href="#motive">MOTIVE</a></li>
<li><a href="#项目要求">项目要求</a></li>
<li><a href="#项目数据">项目数据</a></li>
<li><a href="#完整代码">完整代码</a></li>
<li><a href="#comment">COMMENT</a></li>
</ul>
</nav>
  </div>
</div>

    
    

    
    <div class="post-content">
      

<hr />

<p>author: evo
comments: true
date: 2018-05-10 13:16:01+00:00
layout: post
link: <a href="http://106.15.37.116/2018/05/10/svm-sample2/">http://106.15.37.116/2018/05/10/svm-sample2/</a>
slug: svm-sample2
title:
wordpress_id: 5514
categories:</p>

<h2 id="随想与反思">- 随想与反思</h2>

<!-- more -->

<p>[mathjax]</p>

<p><strong>注：非原创，推荐直接看原文</strong></p>

<h1 id="original">ORIGINAL</h1>

<pre><code>1. [第6章 支持向量机](http://ml.apachecn.org/mlia/svm/)
</code></pre>

<p>2.</p>

<h2 id="需要补充的">需要补充的</h2>

<ul>
<li><p><strong>同样也是SMO的，没有怎么明白，而且关于RBF的使用，理论还是要弄明白的。</strong></p></li>

<li><p><strong>对照《机器学习实战》书看一下，仔细理解一下。</strong></p></li>
</ul>

<h1 id="motive">MOTIVE</h1>

<ul>
<li>aaa</li>
</ul>

<hr />

<h1 id="项目要求">项目要求</h1>

<p>之前我们使用 knn 的方法，可以根据已经有的一些digits数据来判断一个新的手写数字 digits 到底是多少，其实精度还是很高的，但是呢，有个缺点：knn需要保留所有的向量，因此它的模型占用的内存很大，如果给别人用的话，别人下载就不是很方便。</p>

<p>而如果用SVM来做这件事情，那么我们最后的模型只需要保存SVM的支持向量就行。</p>

<h1 id="项目数据">项目数据</h1>

<p>仍然是之前的digits项目的数据 ：</p>

<p>链接：<a href="https://pan.baidu.com/s/1wc1ooDPns0Ciy4CiMkmcmQ">https://pan.baidu.com/s/1wc1ooDPns0Ciy4CiMkmcmQ</a> 密码：uz3c</p>

<p>里面每个txt文档都是32*32 的，内容类似：</p>

<pre><code>00000000000000001111000000000000
00000000000000011111111000000000
00000000000000011111111100000000
00000000000000011111111110000000
00000000000000011111111110000000
00000000000000111111111100000000
00000000000000111111111100000000
00000000000001111111111100000000
00000000000000111111111100000000
00000000000000111111111100000000
00000000000000111111111000000000
00000000000001111111111000000000
00000000000011111111111000000000
00000000000111111111110000000000
00000000001111111111111000000000
00000001111111111111111000000000
00000011111111111111110000000000
00000111111111111111110000000000
00000111111111111111110000000000
00000001111111111111110000000000
00000001111111011111110000000000
00000000111100011111110000000000
00000000000000011111110000000000
00000000000000011111100000000000
00000000000000111111110000000000
00000000000000011111110000000000
00000000000000011111110000000000
00000000000000011111111000000000
00000000000000011111111000000000
00000000000000011111111000000000
00000000000000000111111110000000
00000000000000000111111100000000
</code></pre>

<h1 id="完整代码">完整代码</h1>

<pre><code>import numpy as np
from time import sleep
</code></pre>

<p>​
    def calc_Ws(alphas, data_arr, class_labels):
        X = np.mat(data_arr);
        labelMat = np.mat(class_labels).transpose()
        m, n = np.shape(X)
        w = np.zeros((n, 1))
        for i in range(m):
            w += np.multiply(alphas[i] * labelMat[i], X[i, :].T)
        return w</p>

<p>​
    def get_img_data(file_name):
        img_data = np.zeros((1, 1024))
        fr = open(file_name)
        for i in range(32):
            lineStr = fr.readline()
            for j in range(32):
                img_data[0, 32 * i + j] = int(lineStr[j])
        return img_data</p>

<p>​
    def load_images(dir_name):
        from os import listdir
        file_list = listdir(dir_name)  # load the training set
        file_num = len(file_list)
        data_mats = np.zeros((file_num, 1024))
        labels = []
        for i in range(file_num):
            file_full_name = file_list[i]
            file_name = file_full_name.split(&lsquo;.&rsquo;)[0]  # take off .txt
            label = int(file<em>name.split(&rsquo;</em>&rsquo;)[0])
            if label == 9:
                labels.append(-1)
            else:
                labels.append(1)
            data_mats[i, :] = get_img_data(&lsquo;%s/%s&rsquo; % (dir_name, file_full_name))
        return data_mats, labels</p>

<p>​
    class opt_struct:
        def <strong>init</strong>(self, data_mat_in, class_labels, C, toler, kTup):  # Initialize the structure with the parameters
            self.X = data_mat_in
            self.labelMat = class_labels
            self.C = C
            self.tol = toler
            self.m = np.shape(data_mat_in)[0]
            self.alphas = np.mat(np.zeros((self.m, 1)))
            self.b = 0
            self.eCache = np.mat(np.zeros((self.m, 2)))  # first column is valid flag
            self.K = np.mat(np.zeros((self.m, self.m)))
            for i in range(self.m):
                self.K[:, i] = kernel_trans(self.X, self.X[i, :], kTup)</p>

<p>​
    # data_mat 数据集
    # row_mat data_mat数据集的第i行的数据
    # kTup  核函数的信息
    def kernel_trans(data_mat, row_mat, kTup):  # calc the kernel or transform data to a higher dimensional space
        row_num, column_num = np.shape(data_mat)
        K = np.mat(np.zeros((row_num, 1)))
        if kTup[0] == &lsquo;lin&rsquo;:
            K = data_mat * row_mat.T  # linear kernel
        elif kTup[0] == &lsquo;rbf&rsquo;:
            for j in range(row_num):
                delta_row = data_mat[j, :] - row_mat
                K[j] = delta_row * delta_row.T
            # 径向基函数的高斯版本
            K = np.exp(K / (-1 * kTup[1] ** 2))  # divide in NumPy is element-wise not matrix like Matlab
        else:
            raise NameError(&lsquo;Kernel is not recognized&rsquo;)
        return K</p>

<p>​
    def calc_Ek(oS, k):
        fXk = float(np.multiply(oS.alphas, oS.labelMat).T * oS.K[:, k] + oS.b)
        Ek = fXk - float(oS.labelMat[k])
        return Ek</p>

<p>​
    def select_j_rand(i, m):
        j = i  # we want to select any J not equal to i
        while (j == i):
            j = int(np.random.uniform(0, m))
        return j</p>

<p>​
    def clip_alpha(aj, H, L):
        if aj &gt; H:
            aj = H
        if L &gt; aj:
            aj = L
        return aj</p>

<p>​
    def selectJ(i, oS, Ei):  # this is the second choice -heurstic, and calcs Ej
        max_k = -1;
        max_delta_e = 0;
        Ej = 0
        oS.eCache[i] = [1, Ei]  # set valid #choose the alpha that gives the maximum delta E
        valid_ecache_list = np.nonzero(oS.eCache[:, 0].A)[0]
        if (len(valid_ecache_list)) &gt; 1:
            for k in valid_ecache_list:  # loop through valid Ecache values and find the one that maximizes delta E
                if k == i: continue  # don&rsquo;t calc for i, waste of time
                Ek = calc_Ek(oS, k)
                delta_e = abs(Ei - Ek)
                if (delta_e &gt; max_delta_e):
                    max_k = k;
                    max_delta_e = delta_e;
                    Ej = Ek
            return max_k, Ej
        else:  # in this case (first time around) we don&rsquo;t have any valid eCache values
            j = select_j_rand(i, oS.m)
            Ej = calc_Ek(oS, j)
        return j, Ej</p>

<p>​
    def update_Ek(oS, k):  # after any alpha has changed update the new value in the cache
        Ek = calc_Ek(oS, k)
        oS.eCache[k] = [1, Ek]</p>

<p>​
    def innerL(i, oS):
        Ei = calc_Ek(oS, i)
        if ((oS.labelMat[i] * Ei &lt; -oS.tol) and (oS.alphas[i] &lt; oS.C)) <br />
                or ((oS.labelMat[i] * Ei &gt; oS.tol) and (oS.alphas[i] &gt; 0)):
            j, Ej = selectJ(i, oS, Ei)  # this has been changed from selectJrand
            alpha_iold = oS.alphas[i].copy();
            alpha_jold = oS.alphas[j].copy();
            if (oS.labelMat[i] != oS.labelMat[j]):
                L = max(0, oS.alphas[j] - oS.alphas[i])
                H = min(oS.C, oS.C + oS.alphas[j] - oS.alphas[i])
            else:
                L = max(0, oS.alphas[j] + oS.alphas[i] - oS.C)
                H = min(oS.C, oS.alphas[j] + oS.alphas[i])
            if L == H:
                print(&ldquo;L==H&rdquo;)
                return 0
            eta = 2.0 * oS.K[i, j] - oS.K[i, i] - oS.K[j, j]  # changed for kernel
            if eta &gt;= 0:
                print(&ldquo;eta&gt;=0&rdquo;)
                return 0
            oS.alphas[j] -= oS.labelMat[j] * (Ei - Ej) / eta
            oS.alphas[j] = clip_alpha(oS.alphas[j], H, L)
            update_Ek(oS, j)  # added this for the Ecache
            if (abs(oS.alphas[j] - alpha_jold) &lt; 0.00001):
                print(&ldquo;j not moving enough&rdquo;)
                return 0
            oS.alphas[i] += oS.labelMat[j] * oS.labelMat[i] * (
                alpha_jold - oS.alphas[j])  # update i by the same amount as j
            update_Ek(oS, i)  # added this for the Ecache                    #the update is in the oppostie direction
            b1 = oS.b - Ei - oS.labelMat[i] * (oS.alphas[i] - alpha_iold) * oS.K[i, i] <br />
                 - oS.labelMat[j] * (oS.alphas[j] - alpha_jold) * oS.K[i, j]
            b2 = oS.b - Ej - oS.labelMat[i] * (oS.alphas[i] - alpha_iold) * oS.K[i, j] <br />
                 - oS.labelMat[j] * (oS.alphas[j] - alpha_jold) * oS.K[j, j]
            if (0 &lt; oS.alphas[i]) and (oS.C &gt; oS.alphas[i]):
                oS.b = b1
            elif (0 &lt; oS.alphas[j]) and (oS.C &gt; oS.alphas[j]):
                oS.b = b2
            else:
                oS.b = (b1 + b2) / 2.0
            return 1
        else:
            return 0</p>

<p>​
    # 完整SMO算法外循环，与smoSimple有些类似，但这里的循环退出条件更多一些
    def smoP(data_mat_in, class_labels, C, toler, max_iter, kTup=(&lsquo;lin&rsquo;, 0)):  # full Platt SMO
        oS = opt_struct(np.mat(data_mat_in),
                        np.mat(class_labels).transpose(),
                        C, toler, kTup)
        iter = 0
        entire_set = True;
        alpha_pairs_changed = 0
        # 循环遍历：循环maxIter次 并且 （alphaPairsChanged存在可以改变 or 所有行遍历一遍）
        while (iter &lt; max_iter) and ((alpha_pairs_changed &gt; 0) or (entire_set)):
            alpha_pairs_changed = 0
            #  当 entireSet=true or 非边界alpha对没有了；就开始寻找 alpha对，然后决定是否要进行else。
            if entire_set:
                # 在数据集上遍历所有可能的alpha
                for i in range(oS.m):
                    # 是否存在alpha对，存在就+1
                    alpha_pairs_changed += innerL(i, oS)
                    print(&ldquo;fullSet, iter: %d i:%d, pairs changed %d&rdquo; % (iter, i, alpha_pairs_changed))
                iter += 1
            # 对已存在 alpha对，选出非边界的alpha值，进行优化。
            else:
                # 遍历所有的非边界alpha值，也就是不在边界0或C上的值。
                non_bound_is = np.nonzero((oS.alphas.A &gt; 0) * (oS.alphas.A &lt; C))[0]
                for i in non_bound_is:
                    alpha_pairs_changed += innerL(i, oS)
                    print(&ldquo;non-bound, iter: %d i:%d, pairs changed %d&rdquo; % (iter, i, alpha_pairs_changed))
                iter += 1
            # 如果找到alpha对，就优化非边界alpha值，否则，就重新进行寻找，如果寻找一遍 遍历所有的行还是没找到，就退出循环。
            if entire_set:
                entire_set = False  # toggle entire set loop
            elif (alpha_pairs_changed == 0):
                entire_set = True
            print(&ldquo;iteration number: %d&rdquo; % iter)
        return oS.b, oS.alphas</p>

<p>​
    def try_digits(kTup=(&lsquo;rbf&rsquo;, 10)):
        data_arr, label_arr = load_images(&lsquo;digits/trainingDigits&rsquo;)
        b, alphas = smoP(data_arr, label_arr, 200, 0.0001, 10000, kTup)
        dat_mat = np.mat(data_arr);
        label_mat = np.mat(label_arr).transpose()
        sv_ind = np.nonzero(alphas.A &gt; 0)[0]
        sVs = dat_mat[sv_ind]
        label_s_v = label_mat[sv_ind];
        print(&ldquo;there are %d Support Vectors&rdquo; % np.shape(sVs)[0])
        m, n = np.shape(dat_mat)
        error_count = 0
        for i in range(m):
            kernel_eval = kernel_trans(sVs, dat_mat[i, :], kTup)
            predict = kernel_eval.T * np.multiply(label_s_v, alphas[sv_ind]) + b
            if np.sign(predict) != np.sign(label_arr[i]):
                error_count += 1
        print(&ldquo;the training error rate is: %f&rdquo; % (float(error_count) / m))
        data_arr, label_arr = load_images(&lsquo;digits/testDigits&rsquo;)
        error_count = 0
        dat_mat = np.mat(data_arr)
        label_mat = np.mat(label_arr).transpose()
        m, n = np.shape(dat_mat)
        for i in range(m):
            kernel_eval = kernel_trans(sVs, dat_mat[i, :], kTup)
            # 1*m * m*1 = 1*1 单个预测结果
            predict = kernel_eval.T * np.multiply(label_s_v, alphas[sv_ind]) + b
            if np.sign(predict) != np.sign(label_arr[i]):
                error_count += 1
        print(&ldquo;the test error rate is: %f&rdquo; % (float(error_count) / m))</p>

<p>​
    if <strong>name</strong> == &ldquo;<strong>main</strong>&ldquo;:
        try_digits()</p>

<p>输出如下：</p>

<pre><code>L==H
fullSet, iter: 0 i:0, pairs changed 0
fullSet, iter: 0 i:1, pairs changed 1
fullSet, iter: 0 i:2, pairs changed 2
fullSet, iter: 0 i:3, pairs changed 3
fullSet, iter: 0 i:4, pairs changed 4
fullSet, iter: 0 i:5, pairs changed 5
...略去
fullSet, iter: 3 i:396, pairs changed 0
fullSet, iter: 3 i:397, pairs changed 0
L==H
fullSet, iter: 3 i:398, pairs changed 0
fullSet, iter: 3 i:399, pairs changed 0
fullSet, iter: 3 i:400, pairs changed 0
L==H
fullSet, iter: 3 i:401, pairs changed 0
iteration number: 4
there are 112 Support Vectors
the training error rate is: 0.000000
the test error rate is: 0.010753
</code></pre>

<p><strong>同样也是SMO的，没有怎么明白，而且关于RBF的使用，理论还是要弄明白的。</strong></p>

<hr />

<h1 id="comment">COMMENT</h1>

    </div>

    
    

    
    

    <footer class="post-footer">
      

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/02-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/01-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%90%86%E8%AE%BA/02-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%89%8D%E5%90%91%E9%80%90%E6%AD%A5%E5%9B%9E%E5%BD%92-%E4%BE%8B%E5%AD%901%E6%A0%B9%E6%8D%AE%E9%B2%8D%E9%B1%BC%E5%A3%B3%E7%9A%84%E5%B1%82%E6%95%B0%E6%8E%A8%E7%AE%97%E9%B2%8D%E9%B1%BC%E5%B9%B4%E9%BE%84/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">前向逐步回归 例子1：根据鲍鱼壳的层数推算鲍鱼年龄</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/02-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/01-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%90%86%E8%AE%BA/02-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/06-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/01-%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%96%B9%E6%B3%95/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92-%E4%BE%8B%E5%AD%902%E6%A0%B9%E6%8D%AE%E9%B2%8D%E9%B1%BC%E5%A3%B3%E7%9A%84%E5%B1%82%E6%95%B0%E6%8E%A8%E7%AE%97%E9%B2%8D%E9%B1%BC%E5%B9%B4%E9%BE%84/">
            <span class="next-text nav-default">线性回归 例子2：根据鲍鱼壳的层数推算鲍鱼年龄</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="iteratelyd@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="http://github.com/iterateself" class="iconfont icon-github" title="github"></a>
      <a href="https://www.zhihu.com/people/thebegin/activities" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="https://www.douban.com/people/68028070/" class="iconfont icon-douban" title="douban"></a>
  <a href="http://iterate.site/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> site pv: <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
    <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> site uv: <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2018
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">iterateself</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>


<script type="text/javascript" src="/dist/even.min.js?v=3.2.0"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>








</body>
</html>
