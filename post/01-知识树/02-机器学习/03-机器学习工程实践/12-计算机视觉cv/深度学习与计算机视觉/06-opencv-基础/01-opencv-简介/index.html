<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>01 OpenCV 简介 - 迭代自己</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="iterateself" />
  <meta name="description" content="6章 OpenCV基础 在深度学习大行其道之前，提到计算机视觉的工具和框架，大多数人一定会最先想到 OpenCV。因为其丰富的接口，优秀的性能，商" />

  <meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.47.1" />


<link rel="canonical" href="http://iterate.site/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/02-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/03-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/12-%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89cv/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/06-opencv-%E5%9F%BA%E7%A1%80/01-opencv-%E7%AE%80%E4%BB%8B/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">




<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<link href="/dist/even.min.css?v=3.2.0" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">




<meta property="og:title" content="01 OpenCV 简介" />
<meta property="og:description" content="6章 OpenCV基础 在深度学习大行其道之前，提到计算机视觉的工具和框架，大多数人一定会最先想到 OpenCV。因为其丰富的接口，优秀的性能，商" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://iterate.site/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/02-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/03-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/12-%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89cv/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/06-opencv-%E5%9F%BA%E7%A1%80/01-opencv-%E7%AE%80%E4%BB%8B/" /><meta property="article:published_time" content="2018-08-29T00:00:00&#43;00:00"/>
<meta property="article:modified_time" content="2018-08-29T00:00:00&#43;00:00"/>
<meta itemprop="name" content="01 OpenCV 简介">
<meta itemprop="description" content="6章 OpenCV基础 在深度学习大行其道之前，提到计算机视觉的工具和框架，大多数人一定会最先想到 OpenCV。因为其丰富的接口，优秀的性能，商">


<meta itemprop="datePublished" content="2018-08-29T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2018-08-29T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="17488">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="01 OpenCV 简介"/>
<meta name="twitter:description" content="6章 OpenCV基础 在深度学习大行其道之前，提到计算机视觉的工具和框架，大多数人一定会最先想到 OpenCV。因为其丰富的接口，优秀的性能，商"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">迭代自己</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">主页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a><a href="/catalog/">
        <li class="mobile-menu-item">完整目录</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">迭代自己</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">主页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/catalog/">完整目录</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">01 OpenCV 简介</h1>

      <div class="post-meta">
        <span class="post-time"> 2018-08-29 </span>
        
        <span class="more-meta"> 17488 words </span>
        <span class="more-meta"> 35 mins read </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> times read </span>
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  
  <div class="post-toc-content">
    <nav id="TableOfContents">
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li><a href="#6章-opencv基础">6章 OpenCV基础</a>
<ul>
<li>
<ul>
<li><a href="#于是对于0到7t-2之间的0-有">于是对于0到7T/2之间的0，有:</a></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</nav>
  </div>
</div>

    
    

    
    <div class="post-content">
      

<h4 id="6章-opencv基础">6章 OpenCV基础</h4>

<p>在深度学习大行其道之前，提到计算机视觉的工具和框架，大多数人一定会最先想到 OpenCV。因为其丰富的接口，优秀的性能，商业友好的属性，OpenCV至今仍然是最流行 的计算机视觉库，并在各个计算机视觉领域发挥着巨大的作用。</p>

<p>本章将介绍OpenCV的基本知识，以及Python下OpenCV的基础使用，并完成4个有 趣且实用的小例子。</p>

<p>□延时摄影小程序。</p>

<p>□视频中截屏采样的小程序。</p>

<p>口图片数据增加（dataaugmentation）的小工具。</p>

<p>□物体检测框标注小工具。</p>

<p>其中，后两个例子的代码可以在 <a href="https://github.com/frombeijingwithlove/dlcv_for_">https://github.com/frombeijingwithlove/dlcv_for_</a> beginners上直接下载。</p>

<p>6.1 OpenCV 简介</p>

<p>OpenCV的起源和发展历史已经在第1章中介绍过了，本节主要介绍OpenCV的常见 模块和结构。</p>

<p>6.1.1 OpenCV 的结构</p>

<p>和Python—样，当前的OpenCV也有两个大版本，即OpenCV 2和OpenCV 3。相比 OpenCV 2, OpenCV 3提供了更强的功能和更多方便的特性。不过考虑到和深度学习框架 的兼容性，以及上手安装的难度，本节先以OpenCV 2为主进行介绍。</p>

<p>根据功能和需求的不同，OpenCV中的函数接口大体可以分为如下几部分。</p>

<p>□    core：核心模块，主要包含了 OpenCV中最基本的结构（矩阵、点线和形状等）， 以及相关的基础运算/操作。</p>

<p>□    imgproc：图像处理模块，包含和图像相关的基础功能（滤波、梯度、改变大小等）， 以及一些衍生的高级功能（图像分割、直方图、形态分析和边缘/直线提取等）。</p>

<p>□    highgui：提供了用户界面和文件读取的基本函数，比如图像显示窗口的生成和控 制，图像/视频文件的IO等。</p>

<p>如果不考虑视频应用，以上3部分就是最核心和常用的模块了。针对视频和一些特别 的视觉应用，OpenCV也提供了如下强劲的支持。</p>

<p>□    video：用于视频分析的常用功能，比如光流法（Optical Flow）和目标跟踪等。</p>

<p>□    calib3d：三维重建、立体视觉和相机标定等相关功能。</p>

<p>□    features2d：二维特征相关的功能，主要是一些不受专利保护的、商业友好的特征 点检测和匹配等功能，比如ORB特征。</p>

<p>□    object：目标检测模块，包含级联分类和Latent SVM。</p>

<p>□    ml：机器学习算法模块，包含一些视觉中最常用的传统机器学习算法。</p>

<p>口 flann：最近邻算法库，Fast Library for Approximate Nearest Neighbors,用于在多维 空间进行聚类和检索，经常和关键点匹配搭配使用。</p>

<p>□    gpu:包含了一些gpu加速的接口，底层的加速是CUDA实现。</p>

<p>□    photo：计算摄像学(Computational Photography)相关的接口，当然这只是个名字， 其实只有图像修复和降噪而已。</p>

<p>□    stitching：图像拼接模块，有了它可以自己生成全景照片。</p>

<p>□    nonfree：受到专利保护的一些算法，其实就是SIFT和SURF。</p>

<p>□    contrib： 一些实验性质的算法，考虑在未来版本中加入。</p>

<p>□    legacy：字面是遗产，意思就是废弃的一些接口，将其保留下来是考虑到向下兼容。</p>

<p>□    ocl:利用OpenCL并行加速的一些接口。</p>

<p>□    superres:超分辨率模块，其实就是 BTV-L1 (Biliteral Total Variation - LI regularization)算法。</p>

<p>□    viz:基础的3D渲染模块，其实底层就是著名的3D工具包VTK (Visualization Toolkit)。</p>

<p>从使用的角度来看，和OpenCV2相比，OpenCV 3的主要变化是更多的功能和更细化 的模块划分。</p>

<p>6.1.2安装和使用OpenCV</p>

<p>作为最流行的视觉包，在Linux中安装OpenCV是非常方便的，大多数Linux的发行 版都支持包管理器的安装，比如在Ubuntu 16.04 LTS中，只需要在终端中输入：</p>

<p>» sudo apt install libopencv-dev python-opencv</p>

<p>当然也可以通过官网下载源码编译安装，首先安装各种依赖。</p>

<p>» sudo apt install build-essential</p>

<p>»    sudo apt install cmake    git libgtk2.0-dev    pkg-config</p>

<p>libavcodec-dev libavformat-dev libswscale-dev</p>

<p>»    sudo apt-get    install    python-dev    python-numpy libtbb2    libtbb-dev</p>

<p>libjpeg-dev libpng-dev libtiff-dev libj asper-dev libdcl3 94-22-dev</p>

<p>然后找一个clone压缩包的文件夹，将源码下载下来。</p>

<p>&gt;&gt; git clone <a href="https://github.com/opencv/opencv.git">https://github.com/opencv/opencv.git</a></p>

<p>然后进入OpenCV文件夹。</p>

<p>» mkdir release » cd release</p>

<p>» cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREF工X=/usr/local.. 准备完毕，直接make并安装。</p>

<p>&gt;&gt; make</p>

<p>» sudo make install</p>

<p>Windows 下的安装也很简单，直接去 OpenCV 官网 <a href="http://opencv.org/downloads.html">http://opencv.org/downloads.html</a> 下 载即可。</p>

<p>执行exe文件安装后，会在＜安装目录〉\build\python/2.7下发现一个cv2.pyd的文件， 把该文件复制到＜?外11011目录〉\Lib\site-packages下就可以了。Windows下如果只想在Python 中体验OpenCV,有个更简单的方法是加州大学尔湾分校(University of California，Irvine) 的Christoph Gohlke制作的Windows下的Python科学计算包网页，下载对应版本的wheel 文件，然后通过 pip 安装即可，下载地址为 <a href="http://www.lfd.uci.edu/~gohlke/pythonlibs/%23opencvo">http://www.lfd.uci.edU/~gohlke/pythonlibs/#opencvo</a></p>

<p>本节只讲Python下的OpenCV基本用法，Python中导入OpenCV非常简单： import cv2 这样就导入成功了。</p>

<p>6.2 Python-OpenCV 基础</p>

<p>本节主要讲解在Python中利用OpenCV的图像存取，以及与深度学习中图像预处理阶 段相关的最基本使用。</p>

<p>6.2.1图像的表示</p>

<p>前面章节已经提到过了单通道的灰度图像在计算机中的表示，就是一个8位无符号整 形的矩阵。在OpenCV的C++代码中，表示图像有个专门的结构cv::Mat,不过在 Python-OpenCV中^因为已经有了 NumPy这种强大的基础工具，所以这个矩阵就用NumPy 的array表示。如果是多通道情况，最常见的就是红绿蓝(RGB)三通道，则第一个维度 是高度，第二个维度是高度，第三个维度是通道，如图6-la所示为一幅3x3图像在计算机 中表示的例子。</p>

<p>分通道表示</p>

<p>◄-</p>

<p>RBG表示</p>

<table>
<thead>
<tr>
<th>255,0,0</th>
<th>0,255,0</th>
<th>0,0,255</th>
</tr>
</thead>

<tbody>
<tr>
<td>255,255,0</td>
<td>255,0,255</td>
<td>0,255,255</td>
</tr>

<tr>
<td>255,255,255</td>
<td>128,128,128</td>
<td>0,0,0</td>
</tr>
</tbody>
</table>

<p>| BGR表示</p>

<p>a)</p>

<p>b)</p>

<p>图6-1 RGB图像在计算机中表示的例子</p>

<p>在图6-1中，右上角的矩阵里每个元素都是一个三维数组，分别代表这个像素上的三</p>

<p>个通道的值。最常见的RGB通道中，第一个元素就是红色(Red)的值，第二个元素是绿</p>

<p>色(Green)的值，第三个元素是蓝色(Blue)，最终得到的图像如图6-la所示。RGB是</p>

<p>最常见的情况，然而在OpenCV中，默认的图像表示却是反过来的，也就是BGR，得到的</p>

<p>图像如图6-lb所示。可以看到，前两行的颜色顺序都交换了，最后一行是三个通道等值的</p>

<p>灰度图，所以没有影响。至于OpenCV为什么不是大家喜闻乐见的RGB,则是历史遗留问</p>

<p>题。在OpenCV刚开始研发的年代，BGR是相机设备厂商的主流表示方法，虽然后来RGB</p>

<p>成了主流和默认，但是这个底层的顺序却保留了下来，事实上Windows下的最常见格式之</p>

<p>一 bmp的底层字节的存储顺序还是BGR。OpenCV的这个特殊之处还是需要注意的，比如</p>

<p>在Python中，图像都是用NumPy的array表示，但是同样的array在OpenCV中的显示</p>

<p>效果和matplotlib中的显示效果就会不一样。下面的简单代码就可以生成两种表示方式下</p>

<p>图6-1中矩阵对应的图像，生成图像后，放大看就能体会到二者的区别。</p>

<p>import numpy as np import cv2</p>

<p>import matplotlib.pyplot as pit</p>

<p>#图6-1中的矩阵 img = np.array ([</p>

<p>[[255, 0, 0],队 255, 0], [0, 0, 255]],</p>

<p>[[255,    255,    0],    [255, 0r 255],    [0,    255,    255]],</p>

<p>[[255, 255, 255], [128, 128, 128], [0, 0, 0/j &lt;</p>

<p>], dtype=np.uint8)</p>

<p># 用 matplotlib 存储</p>

<p>pit.imsave(* img_pyplot.jpg *, img)</p>

<p>#用OpenCV存储</p>

<p>cv2 . imwrite (&rsquo; img_cv2 .jpg&rsquo;, img)</p>

<p>不管是RGB还是BGR,都是高度x宽度x通道数，HxWxC的表达方式，而在深度学 习中，因为要对不同通道应用卷积，所以用的是另一种方式：CxHxW,就是把每个通道都 单独表达成一个二维矩阵，如图6-lc所示。</p>

<p>6.2.2基本图像处理</p>

<p>1.存取图像</p>

<p>读图像用CV2.imread()函数，可以按照不同模式读取，一般最常用到的是读取单通道灰 度图，或者直接默认读取多通道。保存图像用cv2.imwrite()函数，注意保存的时候是没有 单通道这一说的，根据保存文件名的后缀和当前的array维度，OpenCV自动判断存储的通 道。另外，压缩格式还可以指定存储质量，下面来看代码例子。</p>

<p>import cv2</p>

<p>#读取一张400x600分辨率的图像</p>

<p>color_img = cv2.imread(* test_400x600.jpg *)</p>

<p>print(color_img.shape)</p>

<p>#直接读取单i道</p>

<p>gray_img = cv2.imread(* test_4 00x600.jpg&rsquo;, cv2.工MREAD—GRAYSCALE) print(gray_img.shape)</p>

<p>#把单通道菌片保存后，再读取，仍然是3通道，相当于把单通道值复制到3个通道保存 cv2.imwrite(&lsquo;test_grayscale.jpg&rsquo;, gray_img)</p>

<p>reload_grayscale = cv2.imread(* test_grayscale.jpg *) print(reload—grayscale.shape)</p>

<p>#    cv2.IMWRITE_JPEG_QUALITY指定jpg质量，范围为0〜100,默认95,越高画质越好，文</p>

<p>件越大</p>

<p>cv2.imwrite(&lsquo;test_imwrite.jpg&rsquo;, color_img,    (cv2.工MWRITE一JPEG_QUALITY,</p>

<p>80))</p>

<p>#    cv2.IMWRITE_PNG_COMPRESSION指定png质量，范围为0〜9:默认3，越高文件越小，画</p>

<p>质越差</p>

<p>cv2 . imwrite (* test_imwrite .png *, color_img, (cv2 .工MWR工TE—PNG—COMPRESS工ON, 5))</p>

<p>\2.    缩放、裁剪和补边</p>

<p>缩放通过cv2.resize()函数实现，裁剪则是利用array自身的下标截取实现，此外OpenCV 还可以给图像补边，这样能对一幅图像的形状和感兴趣区域实现各种操作。下例中读取一 幅400x600分辨率的图片，并执行一些基础的操作。</p>

<p>import cv2</p>

<p>#读取一张四川大录古藏寨的照片</p>

<p>img = cv2.imread(* tiger_tibet_village.jpg&rsquo;)</p>

<p>#缩放成200x200的方形图像</p>

<p>img_200x200    = cv2.resize(imgz (200,    200))</p>

<p>#示直接指定缩放后大小，通过fx和fy指定缩放比例，0.5则长宽都为原来一半</p>

<p>#等效于img_200x300    = cv2 .resize (img, (300,    200))，注意指定大小的格式是(宽</p>

<p>度，局度)</p>

<p>#插值方法默认是cv2.INTER_LINEAR，这里指定为最近邻插值 img_200x300    = cv2.resize(img, (0,    0), fx=0.5, fy=0.5Z</p>

<p>interpolation=cv2.工NTER_NEAREST)</p>

<p>#在上张图片的基础上，上下吝贴50像素的黑边，生成300x300的图像 img_300x300    = cv2.copyMakeBorder(imgf 50,    50,    0,    0,</p>

<p>cv2 .BORDER_C(^NSTANT,</p>

<p>value=(0,    0,    0))</p>

<p>#对照片中树的部分进行剪裁</p>

<p>patch_tree = img[20:150,    -180:-50]</p>

<p>cv2.imwrite(&lsquo;cropped_tree.jpg *, patch_tree)</p>

<p>cv2.imwrite(&lsquo;resized_200x200.jpg&rsquo;, img_200x200)</p>

<p>cv2.imwrite(* resized_200x300.jpg&rsquo;, img_200x300)</p>

<p>cv2.imwrite(*bordered_300x300.jpg *,    img_300x300)</p>

<p>处理的效果如图6-2所示。</p>

<p>\3.    色调、明暗、直方图和Gamma曲线</p>

<p>除了区域，图像本身的属性操作也非常多，比如可以通过HSV空间对色调和明暗进行</p>

<p>调节。HSV空间是由美国的图形学专家A. R. Smith提出的一种颜色空间，HSV分别是色</p>

<p>调(Hue),饱和度(Saturation)和明度(Value)。在HSV空间中进行调节就避免了直</p>

<p>接在RGB空间中调节时还需要考虑3个通道的相关性。OpenCV中H的取值是[0, 180),</p>

<p>其他两个通道的取值都是[0,256),下面接着上例代码，通过HSV空间对图像进行调整。</p>

<p>#通过cv2 . cvtColor把图像从BGR转换到HSV img_hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)</p>

<p>#    tF空间中，绿色比黄色的值高一点，所以给每个像壽+15,黄色的树叶就会变绿 turn_green_hsv = img_hsv.copy()</p>

<p>turn_green_hsv [:,    :,    0]    =    (turn_green_hsv [:,    :,    0] +15)    %    180</p>

<p>turn_green_img = cv2 . cvtColor (turn_green_hsv/. cv2 . COLOR—HSV2BGR)</p>

<p>cv2.imwrite(1turn_green.jpg’， turn_green_img)</p>

<p>#减小饱和度会让图损失鲜艳变得更灰</p>

<p>colorless_hsv = img_hsv.copy()</p>

<p>colorless_hsv [:,    :,    1]    =    0.5    * colorless_hsv [:,    :,    1 ]</p>

<p>coloriess_img = cv2.cvtColor(colorless_hsv, cv2.COLOR_HSV2BGR) cv2.imwrite(1 colorless.jpg1, colorless_img)</p>

<p>#减小明度为原来一半 darker_hsv = img_hsv.copy()</p>

<p>darker_hsv [:,    :,    2]    =    0.5    * darker_hsv [:,    :,    2]</p>

<p>darker_img = cv2.cvtColor(darker_hsvf cv2.COLOR_HSV2BGR) cv2.imwrite(’ darker.jpg’， darker_img)</p>

<p>无论是HSV还是RGB,都较难一眼就对像素中值的分布有细致的了解，这时候就需 要直方图。如果直方图中的成分过于靠近0或者255,可能就出现了暗部细节不足或者亮 部细节丢失的情况。比如图6-2中，背景里的暗部细节是非常弱的，这个时候，一个常用 方法是考虑用Gamma变换来提升暗部细节。Gamma变换是矫正相机直接成像和人眼感受 图像差别的一种常用手段，简单来说就是通过非线性变换，让图像从对曝光强度的线性响 应变得更接近人眼感受到的响应。具体的定义和实现还是接着上面代码中读取的图片，执 行计算直方图和Gamma变换的代码如下：</p>

<p>import numpy as np</p>

<p>#分通道计算每个通道的直方图</p>

<table>
<thead>
<tr>
<th>hist_b =</th>
<th>cv2.calcHist([img],</th>
<th>[0],</th>
<th>None,</th>
<th>[256],</th>
<th>[o,</th>
<th>256])</th>
</tr>
</thead>

<tbody>
<tr>
<td>hist_g =</td>
<td>cv2.calcHist([img],</td>
<td>[1],</td>
<td>None,</td>
<td>[256],</td>
<td>[0,</td>
<td>&lt;256])</td>
</tr>

<tr>
<td>hist r =</td>
<td>cv2.calcHist([img],</td>
<td>[2],</td>
<td>None,</td>
<td>[256],</td>
<td>[0,</td>
<td>256])</td>
</tr>
</tbody>
</table>

<p>#定义Gamma矫正的函数</p>

<p>def gamma_trans(img, gamma):</p>

<p>#真体做法是先归一化到1,然后gamma作为指数值求出新的像素值再还原 gamma_table = [np.power(x/255.0z gamma)*255.0 for x in</p>

<p>range (256)]</p>

<p>gamma_table = np.round(np.array(gamma_table)).astype(np.uint8)</p>

<p>#实现映射用的是OpenCV的查表函数 return cv2.LUT(img, gamma_table)</p>

<p>#执行Gamma矫正，小于1的值让暗部细&lt;大量提升，同时亮部细节少量提升</p>

<p>img_corrected = gamma_trans(img, 0.5)</p>

<p>cv2.imwrite(&lsquo;gamma_corrected.jpg&rsquo; , img_corrected)</p>

<p>#分通道计算Gamma f正后的直方图</p>

<table>
<thead>
<tr>
<th>hist b corrected =</th>
<th>cv2.calcHist([img_corrected],</th>
<th>[0],</th>
<th>None,</th>
<th>[256],</th>
</tr>
</thead>

<tbody>
<tr>
<td>[0, _256])hist g corrected =</td>
<td>cv2.calcHist([img corrected],</td>
<td>[1],</td>
<td>None,</td>
<td>[256],</td>
</tr>

<tr>
<td>[0, _256])hist r corrected =</td>
<td>cv2.calcHist([img_corrected],</td>
<td>[2],</td>
<td>None,</td>
<td>[256],</td>
</tr>

<tr>
<td>[0, _256])</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

<p>#将直方图进行可视化</p>

<p>import matplotlib.pyplot as pit</p>

<p>from mpl_toolkits.mplot3d import Axes3D</p>

<p>fig = pit.figure()</p>

<p>pix_hists =    [</p>

<p>[hist_b, hist_g, hist_r],</p>

<p>[hist_b_corrected, hist_g_corrected, hist_r_corrected]</p>

<p>]</p>

<p>pix_vals = range(256)</p>

<p>for sub_plt, pix_hist in zip([121,    122], pix_hists):</p>

<p>ax = fig.add_subplot(sub_pltz projection^3d*)</p>

<p>for c, z, channel_hist in zip([1b1,    1g&rsquo;z &lsquo;r&rsquo;],    [20,    10,</p>

<p>0] , pix_hist):</p>

<p>cs =    [c]    *    256</p>

<p>color=csz</p>

<p>ax.bar(pix_vals, channel一hist, zs=z, zdir=1y*, alpha=0.618, edgecolor=&lsquo;none *, lw=0)</p>

<p>ax.set_xlabel(* Pixel Values *) ax.set_xlim([0z 256]) ax.set_ylabel(丨 Counts’) ax.set_zlabel(&lsquo;Channels&rsquo;)</p>

<p>pit.show()</p>

<p>上面三段代码的结果统•放在图6-2中。</p>

<p>缩放-&gt;200x300</p>

<p><img src="file:///E:/00.Ebook/__Recent__html__/00_深度学习与计算机视觉%20%20算法原理、框架应用与代码实现_14279998(1)/00_深度学习与计算机视觉%20%20算法原理、框架应用与代码实现_14279998(1)_files/00_f1a666600ea1973ac6c9%20%2097d59f060146b694280ee3019eb0_14279998(1)-240.jpg" alt="img" /></p>

<p><img src="file:///E:/00.Ebook/__Recent__html__/00_深度学习与计算机视觉%20%20算法原理、框架应用与代码实现_14279998(1)/00_深度学习与计算机视觉%20%20算法原理、框架应用与代码实现_14279998(1)_files/00_f1a666600ea1973ac6c9%20%2097d59f060146b694280ee3019eb0_14279998(1)-241.jpg" alt="img" /></p>

<p><img src="file:///E:/00.Ebook/__Recent__html__/00_深度学习与计算机视觉%20%20算法原理、框架应用与代码实现_14279998(1)/00_深度学习与计算机视觉%20%20算法原理、框架应用与代码实现_14279998(1)_files/00_f1a666600ea1973ac6c9%20%2097d59f060146b694280ee3019eb0_14279998(1)-242.jpg" alt="img" /></p>

<p>缩放 ^200x200</p>

<p>缩放并补边一＞300x300区域剪裁</p>

<p>原图:400x600</p>

<p><img src="file:///E:/00.Ebook/__Recent__html__/00_深度学习与计算机视觉%20%20算法原理、框架应用与代码实现_14279998(1)/00_深度学习与计算机视觉%20%20算法原理、框架应用与代码实现_14279998(1)_files/00_f1a666600ea1973ac6c9%20%2097d59f060146b694280ee3019eb0_14279998(1)-245.jpg" alt="img" /></p>

<p><img src="file:///E:/00.Ebook/__Recent__html__/00_深度学习与计算机视觉%20%20算法原理、框架应用与代码实现_14279998(1)/00_深度学习与计算机视觉%20%20算法原理、框架应用与代码实现_14279998(1)_files/00_f1a666600ea1973ac6c9%20%2097d59f060146b694280ee3019eb0_14279998(1)-246.jpg" alt="img" /></p>

<p>色调变绿    饱和度降低    明暗度降低</p>

<p>通过Gamma变换提升暗部细节</p>

<p>图6-2</p>

<p><img src="file:///E:/00.Ebook/__Recent__html__/00_深度学习与计算机视觉%20%20算法原理、框架应用与代码实现_14279998(1)/00_深度学习与计算机视觉%20%20算法原理、框架应用与代码实现_14279998(1)_files/00_f1a666600ea1973ac6c9%20%2097d59f060146b694280ee3019eb0_14279998(1)-249.jpg" alt="img" /></p>

<p>Jwooo</p>

<p>1, J</p>

<p>对应的各通道直方图 左为原图，右为Gamma变换后</p>

<p>图像基本处理的例子</p>

<p>可以看到，Gamma变换后的暗部细节比原图清楚了很多，并且从直方图来看，像素值 也从集中在0附近变得散开了一些。</p>

<p>6.2.3图像的仿射变换</p>

<p>图像的仿射变换涉及图像的形状位置角度的变化，是深度学习预处理中常用的功能。 仿射变换的概念前面已经提到，在此简单回顾一下。仿射变换具体到图像中的应用，主要</p>

<dl>
<dt>第6章OpenCV基础</dt>
<dd><p>■■■ ■■ ■. 二.， &hellip;.. &hellip;&hellip;.. =</p></dd>
</dl>

<p>是对图像的缩放、旋转、剪切、翻转和平移的组合。在OpenCV中，仿射变换的矩阵是一 个2x3的矩阵，其中左边的2x2子矩阵是线性变换矩阵，右边的2x1的两项是平移项。</p>

<p>“00 “01 “10 a\</p>

<p>(公式6-1)</p>

<p>Moo</p>

<p>a\Q</p>

<p>aQ\ ^0 a\ ^1</p>

<p>对于图像上的任一位置仿射变换执行的是如下的操作</p>

<p>Taffine</p>

<p>(公式6-2)</p>

<p>需要注意的是，对于图像而言，宽度方向是x,高度方向是y,坐标的顺序和图像像素 对应下标一致。所以原点的位置不是左下角而是右上角，的方向也不是向上而是向下。 在OpenCV中实现仿射变换是通过仿射变换矩阵和cv2. warp Affine函数。下面还是通过代 码来理解一下，例子中图片的分辨率为600x400。    /</p>

<p>import cv2</p>

<p>import numpy as np</p>

<p>#读取一张斯里兰卡拍摄的大象照片</p>

<p>img = cv2.imread(*lanka_safari.jpg *)</p>

<p>#沿着横纵轴放大1.6倍，然后&rdquo;平移(-150,-240)，最后沿原图大小截取，等效于裁剪并放大</p>

<p>M_crop_elephant 一 [1.6, 0,</p>

<p>=np.array([ -150],</p>

<p>-240]</p>

<p>[0, 1.6,</p>

<p>], dtype=np.float32)</p>

<p>cv2.imwrite(&lsquo;lanka_safari_rotated.jpg*, img_rotated)</p>

<p>#某种变换，具体几何S义可以过SVD分解理解</p>

<p>M = np.array([</p>

<p>[1,    1.5,    -400],</p>

<p>[0.5,    2,    -100]</p>

<p>], dtype=np.float32)</p>

<p>img_transformed = cv2.warpAffine(img, M, (400，    600))</p>

<p>cv2•imwrite(&lsquo;lanka_safari_transformed.jpg&rsquo;, img_transformed)</p>

<p>代码实现的操作示意如图6-3所示。</p>

<p>图6-3仿射变换的例子</p>

<p>6.2.4基本绘图</p>

<p>OpenCV癍供各种绘图的函数，可以在画面上绘制线段、圆、矩形和多边形等，还 可以在图像上指定位置打印文字，比如下面例子：</p>

<p>import numpy as np</p>

<p>import cv2</p>

<p>#定义一块宽600、高400的画布，初始化为白色</p>

<table>
<thead>
<tr>
<th>cv2.line(canvas, (300,    149),    (599,</th>
<th>149),</th>
<th>(0, 0,</th>
<th>0),</th>
<th>2)</th>
<th></th>
<th></th>
</tr>
</thead>

<tbody>
<tr>
<td>#左半部分的右下角画个红色的圆</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td>cv2.circle(canvas, (200,    300),    75,</td>
<td>(0, 0,</td>
<td>255),</td>
<td>5)</td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td>#左半部分的左下角画个蓝色的矩形</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td>cv2.rectangle(canvas,    (20,    240),</td>
<td>(100,</td>
<td>360),</td>
<td></td>
<td>(255,</td>
<td>0,</td>
<td>0),</td>
</tr>
</tbody>
</table>

<p>#定义两个三角形，并执行内部绿色填充</p>

<p>(255,    333)],</p>

<p>(100,    237)]])</p>

<p>(0,    255,    0))</p>

<p>rotations =    [[[np.cos (i *</p>

<p>phi), -np.sin (i for i in range (1,</p>

<p>phi)], 5)]</p>

<p><img src="file:///E:/00.Ebook/__Recent__html__/00_深度学习与计算机视觉%20%20算法原理、框架应用与代码实现_14279998(1)/00_深度学习与计算机视觉%20%20算法原理、框架应用与代码实现_14279998(1)_files/00_f1a666600ea1973ac6c9%20%2097d59f060146b694280ee3019eb0_14279998(1)-252.jpg" alt="img" /></p>

<p>np.sin(phi), np.cos (i * phi)]]</p>

<p>pentagram = np.array([[[[ 0,    -1]]    + [np.dot(m,    (0,    -1)) for m in</p>

<p>rotations]]], dtype=np.float)</p>

<p>#定义缩放倍数和平移向量，把五角星画在左半部分画面的上方</p>

<p>pentagram = np.round(pentagram *    80    + np.array([160,    120])).astype</p>

<p>(np.int)</p>

<p>#将5个顶点作为多边形顶点连线，得到五角星</p>

<p>255]]], dtype=np.uint8)</p>

<p>line_color =    [int&copy; for c in cv2.cvtColor(color_pixelz</p>

<p>cv2.COLOR_HSV2BGR)[0][0]]</p>

<p>cv2.line(canvas, (x,    0),    (x,    147), line_color)</p>

<p>#如果定义圆的线宽大于半斤，则等效于画圆点，随机在画面右卞為的框内生成坐标</p>

<p>np.random.seed(42)</p>

<p>n_pts = 30</p>

<p>pts_x = np.random.randint (310, 590, n_pts) pts_y = np.random.randint (160, 390, n_pts) pts = zip (pts_x, pts_y)</p>

<p>#画出每个点，颜色随机</p>

<p>for pt in pts:</p>

<p>pt_color =    [ int&copy; for c in np.random.randint(0,</p>

<p>255,</p>

<p>3)]</p>

<p>cv2.circle(canvas, pt, 3, pt_color, 5)</p>

<p>#在左半部分最上方打印文字    _    /</p>

<p>cv2.putText(canvas,</p>

<p>&lsquo;Python-OpenCV Drawing Example 1,</p>

<p>(5,    15),</p>

<p>cv2.FONT HERSHEY SIMPLEX,</p>

<p>0.5,</p>

<p>(0, 0, 0),</p>

<p>1)</p>

<p>cv2.imshow(1 Example of basic drawing functions *, canvas cv2.waitKey()</p>

<p>执行代码效果如图6-4所示。</p>

<p>图6-4基本绘图的例子</p>

<p>6.2.5视频功能</p>

<p>视频中最常用的就是从视频设备采集图片或者视频，或读取视频文件并从中采样。所 以比较重要的也是两个模块，一个是VideoCapture,用于获取相机设备并捕获图像和视频， 或是从文件中捕获；还有一个是VideoWriter,用于生成视频。下面来看例子理解这两个功</p>

<p>能的用法，首先是一个制作延时摄影视频的小例子。 import cv2 import time</p>

<p>interval = 60    #捕获图像的间隔，单位：秒</p>

<p>num_frames =    500    #捕获图像的总巾贞数</p>

<p>out_fps =    24    #输出文件的巾贞率</p>

<p>林VideoCapture (0)表示打开默认的相机 cap = cv2.VideoCapture (0)</p>

<p>#获取捕获的分辨率</p>

<p>size =(int (cap.get (cv2.CAP_PROP_FRAME一WIDTH)),</p>

<p>int (cap.get (cvSTcapJrOP-FSamE—HEIGHT)))</p>

<p>#设置要保存视频的编码，分辨率和帧率</p>

<p>video = cv2.VideoWriter(</p>

<p>&ldquo;time_lapse.avi&rdquo;,</p>

<p>cv2.VideoWriter_fourcc(&rsquo;M*,&lsquo;P1,&lsquo;4 *,&lsquo;2’)，</p>

<p>out_fps,</p>

<p>size</p>

<p>)</p>

<p>#对于一些低画质的摄像头，前面的帧可能不稳定，略过</p>

<p>for i in range(42):</p>

<p>cap.read()</p>

<p>#开始捕获，通过read函数获取捕获的帧 try:</p>

<p>for i in range(num_frames):</p>

<p>frame = cap.read()</p>

<p>video.write(frame)</p>

<p>#如果希望每一帧也存成文件，比如制作GIF,则取消下面的注释</p>

<p>#    filename =    1{:0&gt;6d}.png1.format(i)</p>

<p>#    cv2.imwrite(filename, frame)</p>

<p>print(&lsquo;Frame {} is captured.1.format(i)) time.sleep(interval)</p>

<p>except Keyboardlnterrupt:</p>

<p>#提前停止捕获</p>

<p>print(* Stopped!    {}/{} frames captured!*.format(i, num_frames))</p>

<p>#释放资源并写入视频文件 video.release() cap.release()</p>

<p>该例实现了延时摄影的功能，把程序打开并将摄像头对准一些缓慢变化的画面，比如 桌上缓慢蒸发的水，或者正在生长的小草，就能制作出有趣的延时摄影作品。</p>

<p>程序的结构非常清晰简单，注释里也写清楚了每一步，所以程序流程就不多解释了。 需要提一下的有两点：一个是VideoWriter中的函数cv2.VideoWriter fourcco该函数指定 了视频编码的格式，比如例子中用的是MP42,也就是MPEG-4,更多编码方式可以在下 面的地址查询 <a href="http://www.fourcc.org/codecs.phpo">http://www.fourcc.org/codecs.phpo</a></p>

<p>还有一个是Keyboardlnterrupt,这是一个常用的异常，用来获取用户Ctrl+C的中止， 捕获这个异常后直接结束循环并释放VideoCapture和VideoWriter的资源，使已经捕获好 的部分视频可以顺利生成。</p>

<p>从视频中截取帧也是处理视频时常见的任务，下面代码实现的是遍历一个指定文件夹 下的所有视频，并按照指定的间隔进行截屏保存。</p>

<p>import cv2 import os import sys</p>

<p>#第一个输入参数是包含视频片段的路径</p>

<p>input_path = sys.argv[1]</p>

<p>#第三个输入参数是设定每隔多少帧截取一帧</p>

<p>frame_interval = int(sys.argv[2])</p>

<p>#列tS文件夹下所有的视频文件 filenames = os . listdir(input_path)</p>

<p>#获取文件夹名称</p>

<p>video_prefix = input_path.split(os.sep) [-1]</p>

<p>#建立一个新的文件夹，名称为原文件夹名称后加上_frames frame一path =    1{}_frames&rsquo;.format(input_path)</p>

<p>if not os.path.exists(frame_path):</p>

<p>os.mkdir(frame_path)</p>

<p># 初始化一个VideoCapture对象 cap = cv2.VideoCapture()</p>

<p>#遍历所有文件</p>

<p>for filename in filenames:    /</p>

<p>filepath = os.sep.join([input_path, filename])</p>

<p># VideoCapture::open函数可以从文件获取视频 cap.open(filepath)</p>

<p>#获取视频帧数</p>

<p>n_frames = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))</p>

<p>同样为了避免视频头几帧质量低下，黑i或者免关等_</p>

<p>for i in range(42): cap.read()</p>

<p>for i in range(n_frames):</p>

<p>ret, frame = cap.read()</p>

<p>#每隔frame_interval巾贞进行一次截屏操作 if i % f rame_interval ==    0:</p>

<p>imagename =    •{}<em>{}</em>{:0&gt;6d}•jpg’•format(video_prefix,</p>

<p>filename.split(1.*) [0]f i)</p>

<p>imagepath = os.sep.join([frame_path, imagename]) print(* exported {}!*.format(imagepath)) cv2.imwrite(imagepath, frame)</p>

<p>#执行结束释放资源</p>

<p>cap.release()</p>

<p>6.3用OpenCV实现数据增加小工具</p>

<p>到目前我们已经熟悉了 NumPy中的随机模块、多进程调用和OpenCV的基本操作， 基于这些基础，本节将从思路到代码一步步实现一个最基本的数据增加小工具。</p>

<p>第3章和第4章都提到过数据增加(data augmentation),作为一种深度学习中的常用</p>

<p>手段，数据增加对模型的泛化性和准确性都有帮助。数据增加的具体使用方式一般有两 种，一种是实时增加，比如在Caffe中加入数据扰动层，每次图像都先经过扰动操作，再 去训练，这样训练经过几代（epoch）之后，就等效于数据增加。还有一种方式是更加直 接简单一些的，就是在训练之前通过图像处理手段对数据样本进行扰动和增加，也是本 节要实现的。</p>

<p>本节的例子中将包含3种基本类型的扰动：随机裁剪、随机旋转和随机颜色/明暗。</p>

<p>6.3.1随机裁剪</p>

<p>在AlexNet中已经讲过了随机裁剪的基本思路，本节的小例子中打算更进一步：在裁 剪的时候考虑图像宽高比的扰动。在绝大多数用于分类的图片中，样本进入网络前都是要 统一大小，所以宽高比扰动相当于对物体的横向和纵向进行了缩放，这样除了物体的位置 扰动，又多出了一项扰动。只要变化范围控制合适，目标物体始终在画面内，这种扰动是 有助于提升泛化性能的。实现这种裁剪的思路如图6-5所示。</p>

<p>图6-5中最左边是一幅需要剪裁的画面，首先根据这幅画面可以算出一个宽高比w/h. 然后设定一个小的扰动范围3和要裁剪的画面占原画面的比例々，从-&lt;5到3之间按均匀采 样，获取一个随机数》作为裁剪后画面的宽高比扰动的比例，则裁剪后画面的宽和高分 别为：</p>

<p>如果先把这个宽为高为A’的区域置于原画面的右下角，则这个区域的左上角和原 画面的左上角框出的小区域，如图6-5b中的虚线框所示，就是裁剪后区域左上角可以取值 的范围。所以在这个区域内随机采一点作为裁剪区域的左上角，就实现了如图6-5c中，位 置随机且宽高比也随机的裁剪。</p>

<p>6.3.2随机旋转</p>

<p>与前面讲到过的旋转比起来，做数据增加时，一般希望旋转是沿着画面的中心。这样</p>

<p>除了要知道旋转角度，还要计算平移的量才能让仿射变换的效果等效于旋转轴在画面中心， 好在OpenCV中有现成的函数cv2.getRotationMatrix2D()可以使用。该函数的第1个参数是 旋转中心，第2个参数是逆时针旋转角度，第3个参数是缩放倍数，对于只是旋转的情况 参数值是1,返回值就是做仿射变换的矩阵。</p>

<p>直接用cv2.getRotationMatrix2D()函数并接着使用 cv2.warpAffine()函数会有一个潜在的问题，就是旋转之后 会出现黑边。如果要旋转后的画面不包含黑边，则需沿着 原来画面的轮廓做内接矩形，该矩形的宽高比和原画面相 同，如图6-6所示。</p>

<table>
<thead>
<tr>
<th>iAP&rsquo;</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>

<tbody>
<tr>
<td>//</td>
<td></td>
<td></td>
<td>、、1///•!/</td>
</tr>

<tr>
<td>丄</td>
<td></td>
<td></td>
<td>:t//1!1/</td>
</tr>
</tbody>
</table>

<p>在图6-6中可以看到，限制内接矩形大小的主要是原 画面更靠近中心的那条边，也就是图6-6中比较长的一条 边因此只要沿着中心O和内接矩形的顶点方向的直 线，求出和」5的交点P，就得到了内接矩形的大小。下 面先来看长边的方程，考虑之前画面和横轴相交的点，经 过角度旋转后，到了图6-5中的0点所在。</p>

<p>图6-6随机旋转，不含黑边裁剪</p>

<p>os（-0） -sin（-0） in（-0） cos （-沒）</p>

<table>
<thead>
<tr>
<th></th>
<th></th>
<th>子OS⑻</th>
</tr>
</thead>

<tbody>
<tr>
<td>2</td>
<td>=</td>
<td></td>
</tr>

<tr>
<td>0 _</td>
<td></td>
<td>|sin ⑻</td>
</tr>
</tbody>
</table>

<p>因为长边所在直线过0点，且斜率为l/tan(0，所以有:</p>

<p>sin</p>

<p>（公式6-4）</p>

<p>x + ^cos（^）</p>

<p>这时候考虑OP这条直线:</p>

<p>（公式6-5）</p>

<p>把公式6-5带入公式6-4,求解可以得到：</p>

<p>w cos(0) + sin (0)tan (0)</p>

<p>（公式6-6）</p>

<p>h</p>

<p>—tan （汐）+ 1</p>

<p>w</p>

<p>注意，在这个问题中，每个象限和相邻象限都是轴对称的，而且旋转角度对剪裁宽度 和长度的影响是周期(7Mr)变化。再加上我们关心的其实并不是4个点的位置，而是旋 转后要截取的矩形的宽W和高A&rsquo;,所以复杂的分区间情况也简化了。首先对于旋转角度， 因为周期为K，所以都可以化到0到7T之间。因为相邻象限的对称性，进一步有：</p>

<p>0，6^k/2 Tl-d,其他</p>

<p>（公式6-7）</p>

<h6 id="于是对于0到7t-2之间的0-有">于是对于0到7T/2之间的0，有:</h6>

<p>9 h&gt;w ，其他</p>

<p>cos （沒）+ sin （汐）tan （汐）</p>

<p>r tan （权）+ 1</p>

<p>（公式6-8）</p>

<p>当然需要注意的是，对于宽高比非常大或者非常小的图片，旋转后如果裁剪往往得到 的画面是非常小的一部分，甚至不包含目标物体。所以是否需要旋转，以及是否需要裁剪， 裁剪角度多少合适，都要视情况而定。</p>

<p>6.3.3随机颜色和明暗</p>

<p>比起AlexNet论文里在PCA之后的主成分上做扰动的方法，本节用来实现随机的颜色 以及明暗的方法相对简单很多，就是给HSV空间的每个通道分别加上一个微小的扰动。其 中对于色调，从到&lt;5之间按均匀采样，获取一个随机数S作为要扰动的值，然后新的像 素值X’为原始像素值;v+J;对于其他两个空间则是新像素值/为原始像素值*的(1 + J)倍， 从而实现色调、饱和度和明暗度的扰动。</p>

<p>因为明暗度并不会对图像的直方图相对分布产生大的影响，所以在HSV扰动基础上， 考虑再加入一个Gamma扰动，方法是设定一个大于1的Gamma值的上限y,因为这个值 通常和1是一个量级，再用均匀采样的近似未必合适，所以从-logy到logy之间均匀采样一 个值a，然后用ea7作为Gamma值进行变换。</p>

<p>6.3.4多进程调用加速处理</p>

<p>做数据增加时如果样本量本身就不小，则处理起来可能会很耗费时间，所以可以考虑 利用多进程并行处理。比如我们的例子中，设定使用场景是输入一个文件夹路径，该文件 夹下包含了所有原始的数据样本。用户指定输出的文件夹和打算增加图片的总量。执行程 序的时候，通过os.listdirO函数获取所有文件的路径，然后按照第5章讲过的多进程平均划 分样本的办法，把文件尽可能均匀地分给不同进程，进行处理。</p>

<p>6.3.5代码：图片数据增加小工具</p>

<p>按照前面4个部分的思路和方法，本节来实现一个图片数据增加小工具，首先对于一 些基础的操作定义在一个image augmentation.py的文件里。</p>

<p>import numpy as np import cv2</p>

<p>定义裁剪函数，四个参数分别是: 左上角横坐标xO 左上角纵坐标yO</p>

<p>裁剪宽度w</p>

<p>裁剪高度h</p>

<p>I »曹</p>

<p>crop_image = lambda img, xO, yO, w, h: img[yO:yO+hz xO:xO+w]</p>

<p>V    I V</p>

<p>随机裁剪</p>

<p>area_ratio为裁剪画面占原画面的比例</p>

<p>hw_vari是扰动占原高宽比的比例范围</p>

<p>V    V I</p>

<p>def random_crop(img, area_ratio, hw_vari): h, w = img.shape[:2]</p>

<p>hw_delta = np.random.uniform(-hw_vari, hw_vari) hw_mult =    1    + hw_delta</p>

<p>#下标进行裁剪，宽高必须是正整数</p>

<p>w_crop = int(round(w*np.sqrt(area_ratio*hw_mult)))</p>

<p>#裁剪宽度不可超过原图可裁剪宽度</p>

<p>if w_crop &gt; w:</p>

<p>w_crop = w</p>

<p>h_crop = int(round(h*np.sqrt(area_ratio/hw_mult))) if h_crop &gt; h:</p>

<p>h_crop = h</p>

<p>#随机生成左上角的位置    &lt;</p>

<p>xO = np.random.randint(0, w-w_crop+l) yO = np.random.randint(0, h-h_crop+l) return crop_image(img, xO, yO, w_crop, h_crop)</p>

<p>V V V</p>

<p>定义旋转函数：</p>

<p>angle是逆时针旋转的角度</p>

<p>crop是个布尔值，表明是否要裁剪去除黑边</p>

<p>I I I</p>

<p>def rotate_image(img, angle, crop): h, w = img.shape[:2]</p>

<p>#旋转角度的周期是360° angle %= 360</p>

<p>#用OpenCV内置函数计算仿射矩阵</p>

<p>M_rotate = cv2•getRotationMatrix2D((w/2,    h/2), angle, 1)</p>

<p>#得到旋转后的图像</p>

<p>img_rotated = cv2.warpAffine(img, M_rotate, (w, h))</p>

<p>#远果需要裁剪去除黑边</p>

<p>if crop:</p>

<p>#计算高宽比</p>

<p>hw_ratio = float(h)    / float(w)</p>

<p>#计算裁剪边长系数的分子项</p>

<p>tan_theta = np.tan(theta)</p>

<p>numerator = np.cos(theta) + np.sin(theta) * tan_theta</p>

<p>#计算分母项中和宽高比相关的项</p>

<p>r = hw_ratio if h &gt; w else 1    / hw_ratio</p>

<p>#计算分母项</p>

<p>denominator = r * tan_theta +    1</p>

<p>#计算最终的边长系数</p>

<p>crop_mult = numerator / denominator</p>

<p>#得到裁剪区域</p>

<p>w_crop = int(round(crop_mult*w)) h_crop = int(round(crop_mult*h)) xO = int((w-w_crop)/2)</p>

<p>yO = int((h-h_crop)/2)</p>

<p>img_rotated = crop_image(img_rotatedz xO, yO, w_crop,</p>

<p>h_crop)</p>

<p>return img_rotated</p>

<p>随机旋转</p>

<p>angle<em>vari是旋转角度的范围[-angle</em> vari, angle_vari)</p>

<p>p_crop是要进行去黑边裁剪的比例</p>

<p>I V I</p>

<p>def random_rotate(img, angle_variz p_crop):</p>

<p>angle = np.random.uniform(-angle一vari, angle_vari) crop = False if np. random. random ()    &gt; p_crop else True</p>

<p>returh rotate_image(img, angle, crop)</p>

<p>定义hsv变换函数： hue_delta是色调变化比例 saCdelta是饱和度变化比例 val^delta是明度变化比例</p>

<p>def hsv transform(img, hue delta, sat mult, val mult):</p>

<p>img hsv</p>

<p>cv2</p>

<p>img_hsv[:, img_hsv[:, img_hsv[:, img_hsv[img_hsv return</p>

<p>COLOR HSV2BGR)</p>

<p>cv2.cvtColor(img, cv2.COLOR BGR2HSV).astype(np.float)</p>

<p>0]    = (img_hsv[:,    :,    0]    +    hue_delta)    %    180</p>

<p>1]    *= sat_mult</p>

<p>2]    ★= val_mult</p>

<p>&gt;    255]    =— 255</p>

<p>cv2.cvtColor(np.round(img_hsv).astype(np.uint8)</p>

<p>随机hsv变换</p>

<p>hue_vari是色调变化比例的范围</p>

<p>sat^vari是饱和度变化比例的范围</p>

<p>val_vari是明度变化比例的范围</p>

<p>V曹V</p>

<p>def random_hsv_transform(img, hue_vari, sat_vari, val_vari): hue_delta = np.random.randint(-hue_vari, hue_vari) sat_inult = 1 + np. random.uniform (-sat_vari, sat_vari) val_mult = 1 + np.random.uniform(-val_vari, val_vari) return hsv_transform(img, hue_delta, sat_mult, val_mult)</p>

<p>定义gamma变换函数： gamma 就是 Gamma</p>

<p>I I I</p>

<p>def gamma_transform(img, gamma):</p>

<p>gamma_table = [np.power(x /    255.0, gamma) *    255.0 for x in</p>

<p>range(256)]</p>

<p>gamma_table = np.round(np.array(gamma_table)).astype(np.uint8) return cv2.LUT(img, gamma_table)</p>

<p>I I I</p>

<p>随机gamma变换</p>

<p>gamma_vari 是 Gamma 变化的范围[l/garmna_vari, gamma_vari)</p>

<p>I V I</p>

<p>def random_garmna_transform(img, gamma_vari): log_gamma_vari = np.log(gamma_vari)</p>

<p>alpha = np.random.uniform(-log_gamma_vari, log_gamma_vari)</p>

<p>gamma = np.exp(alpha)</p>

<p>return gamma_transform(imgz gamma)</p>

<p>调用这些函数需要通过一个主程序。主程序里首先定义3个子模块，定义一个函数</p>

<p>parse_arg()通过Python的argparse模块定义各种输入参数和默认值。需要注意的是这里用</p>

<p>argparse来输入所有参数，是因为参数总量并不是特别多，如果增加了更多的扰动方法，</p>

<p>更合适的参数输入方式可能是通过-•个配置文件。然后定义一个生成待处理图像列表的函</p>

<p>数generatejmageJistO,根据输入屮要增加图片的数量和并行进程的数目，尽可能均匀地</p>

<p>为每个进程生成了需要处理的任务列表。执行随机扰动的代码定义在augmentJmagesO中，</p>

<p>这个函数是每个进程内进行实际处理的函数，执行顺序是镜像一裁剪一旋转一HSV —</p>

<p>Gamma。需要注意的是镜像一裁剪，因为只是个演示例子，因此未必是一个合适的顺序。</p>

<p>最后定义一个mainO函数进行调用，代码如下：</p>

<p>import os import argparse import random import math</p>

<p>from multiprocessing import Process from multiprocessing import cpu_count import cv2</p>

<p># 导入image_augmentation.py为一个可调用模块 import image_augmentation as ia #利用Python的argparse模块读取输入输出和各种扰动参数 def parse_atgs():</p>

<p>parser = argparse.ArgumentParser(</p>

<p>description;&lsquo;A Simple Image Data Augmentation Tool *, formatter_class=argparse.ArgumentDefaultsHelpFormatter)</p>

<p>parser.add_argument(&lsquo;input_dir *,</p>

<p>help:&lsquo;Directory containing images&rsquo;)</p>

<p>parser.add_argument(* output_dir&rsquo;,</p>

<p>help=&lsquo;Directory for augmented</p>

<p>images *)</p>

<p>parser.add_argument(&lsquo;num *,</p>

<p>help=,Number of images to be</p>

<p>augmented*,</p>

<p>type=int)</p>

<p>parser.add_argument(* ——num_procs1,</p>

<p>help=&lsquo;Number of processes for</p>

<p>paralleled augmentation *,</p>

<p>type=int, default=cpu_count())</p>

<p>parser.add_argument(*&ndash;p_mirror&rsquo;,</p>

<p>help=,Ratio to mirror an image&rsquo;,</p>

<p>type=float, default=O.5)</p>

<p>parser.add_argument(* ——p_crop&rsquo;,</p>

<p>help=1 Ratio to randomly crop</p>

<p>an image *,</p>

<p>type=float, default=l.0) parser.add_argument(丨——crop_size *,</p>

<p>help=&lsquo;The ratio of cropped image size to original image size, in area *,</p>

<p>type=float, default=0.8) parser.add_argument(1——crop_hw_vari1,</p>

<p>help=&lsquo;Variation of h/w ratio*, type=float, default=0.1)</p>

<p>parser.add一argument(&lsquo;&ndash;p_rotate&rsquo;,</p>

<p>help=&lsquo;Ratio</p>

<p>an image&rsquo;,</p>

<p>type=float,</p>

<p>parser.add_argument(* ——p_rotate_crop *,</p>

<p>help= * Ratio</p>

<p>empty part in a rotated image *,</p>

<p>type=float, parser.add_argument(&lsquo;&ndash;rotate_angle_vari&rsquo;,</p>

<p>to randomly rotate</p>

<p>default=l.0)</p>

<p>to crop out the</p>

<p>default=l.0)</p>

<p>help:1Variation range of rotate</p>

<p>angle *,</p>

<p>parser.add_argument(* ——p_hsv&rsquo;,</p>

<p>gamma of an image *,</p>

<p>parser.add_argument(1——hue_vari1</p>

<p>parser.add_argument(* ——sat_vari *</p>

<p>7</p>

<p>parser.add_argument(*&ndash;val_vari *</p>

<p>parser.add_argument(&lsquo;——p_gamma ’，</p>

<p>gamma of an image *,</p>

<p>type=float,</p>

<p>help=,Ratio</p>

<p>type=float,</p>

<p>default=10.0)</p>

<p>to randomly change</p>

<p>default=l.0)</p>

<p>help= * Variation of hue&rsquo;, type=int, default=10)</p>

<p>help= * Variation of saturation1, type=float, default=0.1)</p>

<p>help=&lsquo;Variation of value&rsquo;, type=float, default=0.1)</p>

<p>help= * Ratio</p>

<p>to randomly change</p>

<p>default=l.0)</p>

<p>type=float, parser.add_argument(* ——gamma_vari *,</p>

<p>help=&lsquo;Variation of gamma&rsquo;, type=float, default=2.0)</p>

<p>args = parser.parse_args()</p>

<p>args.input_dir = args.input_dir.rstrip(<em>/</em>) args.output_dir = args.output_dir.rstrip(<em>/</em>) return args</p>

<p>根据进程数和要增加的目标图片数，</p>

<p>生成每个进程要处理的文件列表和每个文件要增加的数目</p>

<p>V I I</p>

<p>def generate—image一list(args):</p>

<p>#获取承有文#名和文件总数</p>

<p>filenames = os.listdir(args.input_dir) num_imgs = len(filenames)</p>

<p>#译算平均处理的数目并向下取整</p>

<p>num_ave_aug = int(math.floor(args.num/num_imgs))</p>

<p>#剩下的部分不足平均分配到每一个文件，所以做成一个随机幸运列表</p>

<p>#对于幸运的文件就多增加一个，凑够指定的数目 rem = args.num - num_ave_aug*num_imgs lucky_seq = [True]<em>rem + [False]</em>(num_imgs-rem) random.shuffle(lucky_seq)</p>

<p>林根据平均分配和幸运表桌略</p>

<p>#生成每个文件的全路径和对应要增加的数目并放到一个list里 img_list =    [</p>

<p>(os.sep.join([args.input_dir, filename]),    num_ave_aug十1</p>

<p>if lucky else num_ave_aug)</p>

<p>for filename, lucky in zip(filenames, lucky_seq)</p>

<p>] ,</p>

<p>#文件可能大小不一，处理时间也不一样 #所以随机打乱，尽可能保证处理时间均匀 random.shuffle(img一list)</p>

<p>#生成每个进程的文件列表</p>

<p>#尽可能均匀地划分每个进程要处理的数目</p>

<p>length = float(num_imgs) / float(args.num_procs)</p>

<p>indices = [int(round(i * length)) for i in range</p>

<p>(args.num_procs +    1)]</p>

<p>return [img_list[indices[i]:indices[i +    1]] for i in range</p>

<p>(args.num_procs)]</p>

<p>#每个进程_内调用图像处理函数进行扰动的函数</p>

<p>def augment—images(filelist, args):</p>

<p>#遍岳所有列表内的文件</p>

<p>for filepath, n in filelist:</p>

<p>img = cv2.imread(filepath) filename = filepath.split(os.sep)[-1] dot_pos = filename.rfind(1.1)</p>

<p>#获取文件名和后缀名</p>

<p>imgname = filename[:dot_pos]</p>

<p>ext = filename[dot一pos:]</p>

<p>print(&lsquo;Augmenting { }    &hellip; 1.format(filename))</p>

<p>for i in range (n):</p>

<p>img_varied = img.copy()</p>

<p>#扰动后文件名的前缀</p>

<p>varied<em>imgname =    &lsquo;{}</em>{：0&gt;3d}_*.format(imgname, i)</p>

<p>#按照比例随机对图像进行镜像</p>

<p>if random.random()    &lt; args.p_mirror:</p>

<p># 利用 numpy. fliplr (img_varied)也能实现 img_varied = cv2.flip(img一varied, 1) varied—imgname +=    *m&rsquo;</p>

<p>#按照比例随机对图像进行裁剪</p>

<p>if random.random()    &lt; args.p_crop:</p>

<p>img_varied = ia.random一crop( img_variedf args.crop_size, args.crop_hw_vari)</p>

<p>varied—imgname +=    * c *</p>

<p>#按照比例随机对图像进行旋转</p>

<p>if random.random()    &lt; args.p_rotate:</p>

<p>img_varied = ia.random_rotate( img_varied,</p>

<p>args.rotate_angle_vari,</p>

<p>args.p_rotate_crop) varied_imgname +=    * r *</p>

<p>#按照比例随机对图像进行HSV扰动 if random.random()    &lt; args.p_hsv:</p>

<p>img_varied = ia.random_hsv_transform( img_varied, args.hue_vari, args.sat_vari, args.val_vari)</p>

<p>varied_imgname +=    * h *</p>

<p>#按照比例随机对图像进行Gamma扰动 if random.random()    &lt; args.p_gamma:</p>

<p>img_varied = ia.random_gamma_transform( img_varied, args.gamma_vari)</p>

<p>varied_imgname +=    &lsquo; g&rsquo;</p>

<p>#生成扰动后的文件名并保存在指定的路径</p>

<p>output_filepath = os.sep.j oin([</p>

<p>args.output_dir,</p>

<p>&rsquo;{}{}*•format(varied_imgname, ext)]) cv2.imwrite(output_filepath, img_varied)</p>

<p>#主函数</p>

<p>def main():</p>

<p>#获取输入输出和变换选项 args = parse_args() params_str = str (args) [10:-1]</p>

<p>#如果論出文件夹不存在，则建立文件夹</p>

<p>if not os.path.exists(args.output_dir):</p>

<p>os.mkdir(args.output_dir)</p>

<p>print(7 Starting image data augmentation for {} \n *</p>

<p>&lsquo;with\n{}\n ’.format(args.input_dir, params_str))</p>

<p>#生成每个进程要处理的列表</p>

<p>sublists = generate_image_list(args)</p>

<p>#创建进程</p>

<p>processes = [Process(target=augment_images, args=(x, args, )) for x in sublists]</p>

<p>#并行多进程处理</p>

<p>for p in processes:</p>

<p>p.start ()</p>

<p>for p in processes: p. join ()</p>

<p>print(<em>\nDone!</em>) if <em>name</em> ==    <em><em>main</em></em> :</p>

<p>main ()</p>

<p>注意，程序中除了前面提的3种类型的变化，还增加了镜像变化，但是因为这种变换 太简单了。另外，默认进程数用的是cpu_Cmmt()函数，以获取CPU的核数。把该段代码 保存为run augmentation.py,然后在命令行输入：</p>

<p>» python run_augmentation.py -h</p>

<p>或者</p>

<p>» python run_augmentation.py ——help</p>

<p>就能看到脚本的使用方法、每个参数的含义及默认值。接下来执行一个图片增加任务:</p>

<p>» python run_augmentation.py    imagenet_samples more_samples 1000</p>

<p>——rotate_angle_vari=180 ——p_rotate_crop=0.5</p>

<p>参数的赋值也可以不用等号而是直接用空格接值，这样在参数是文件名的情况下很方 便，但本例中看不出：</p>

<p>&gt;&gt; python run_augmentation.py    imagenet_samples more_samples 1000</p>

<p>&ndash;rotate_angle_vari 180    ——p_rotate_crop 0.5</p>

<p>其中imagenetsamples为一些从imagenet图片url中随机下载的一些图片， -rotate angle vari设为180，方便测试全方向的旋转，-p rotate crop设置为0.5，让旋转 裁剪对一半图片生效。扰动增加后的1000张图片在more_samples文件夹下，得到的部分 结果如图6-7所示。</p>

<p>图6-7扰动增加后的部分样本</p>

<p>6.4用OpenCV实现物体标注小工具</p>

<p>除了对图像的处理，OpenCV的图形用户界面(Graphical User Interface, GUI)和绘 图等相关功能也是很有用的功能，无论是可视化，图像调试还是本节要实现的标注任务， 都可以有所帮助。本节先介绍OpenCV窗口的最基本的使用和交互，然后基于这些基础和 之前的知识实现一个用于物体检测任务标注的小工具。</p>

<p>6.4.1窗口循环</p>

<p>OpenCV显示一幅图片的函数是cv2.imshow(),第一个参数是显示图片的窗口名称， 第二个参数是图片的array。如果直接执行该函数的话，什么都不会发生，因为该函数需配 合cv2.waitKeyO函数一起使用。cv2.waitKey()函数指定当前的窗口显示要持续的毫秒数， 比如cv2.waitKey(1000)就是显示一秒，然后窗口就关闭了。比较特殊的是cv2.waitKey(0)</p>

<p>函数，并不是显示0毫秒的意思，而是一直显示，直到键盘上的按键被按下，或者鼠标单 击了窗口的关闭按钮才关闭。cv2.waitKeyO函数的默认参数就是0,所以对于图像展示的场 景，cv2.waitKey()或者 cv2.waitKey(0)是最常用的。</p>

<p>import cv2</p>

<p>img = cv2.imread(* Aitutaki.png1) cv2.imshow(* Honeymoon Island*, img) cv2.waitKey()</p>

<p>执行代码得到如图6-8所示的窗口。</p>

<p>. 图6-8利用OpenCV进行最基本的图像显示 /</p>

<p>cv2.waitKey()函数的参数不为0的时候可以和循环结合产生动态画面，比如在6.2.4节 的延时小例子中，把延时摄影保存下来的所有图像放到一个叫做frames的文件夹下。下面 代码从frames的文件夹下读取所有图片并以24的帧率在窗口中显示成动画。</p>

<p>import os</p>

<p>from itertools import cycle import cv2</p>

<p>#列出frames文件夹下的所有图片 filenames = os.listdir(1 frames *)</p>

<p>#通过itertools.cycle生成一个无限循环的迭代器，每次迭代都输出下一张图像对象 img_iter = cycle([cv2.imread(os.sep.join([&lsquo;frames&rsquo;, x])) for x in filenames])</p>

<p>key =    0</p>

<p>while key ! =    27:</p>

<p>cv2.imshow(* Animation *, next(img_iter)) key = cv2.waitKey(42)</p>

<p>在这个例子中采用了 Python的itertools模块中的cycle()函数，该函数可以把一个可遍 历结构编程一个无限循环的迭代器。另外从例子中还发现，cv2.waitKey()函数返回的就是 键盘上按下的按键。对于字母就是ASCII码，特殊按键如上下左右等，则对应特殊的值， 其实这就是键盘事件的最基本用法。</p>

<p>6.4.2鼠标和键盘事件</p>

<p>因为GUI总是交互的，所以鼠标和键盘事件基本使用必不可少，6.4.1节已经提到了 Cv2.waitKey()函数就是获取键盘消息的最基本方法。比如下面的循环代码就能够获取键盘 上按下的按键，并在终端输出：</p>

<p>while key ! =    27:</p>

<p>cv2.imshow(* Honeymoon Island *, img) key = cv2.waitKey()</p>

<p>#如果获取的键值小于256则作为ASCII码输出对应字符，否则直接输出值</p>

<p>msg =    * { } is pressed* . format (chr (key) if key &lt;    256 else</p>

<p>key)</p>

<p>print(msg)</p>

<p>通过这个程序能获取一些常用特殊按键的值，比如在笔者用的机器上，4个方向的按 键和删除键对应的值如下。</p>

<p>□上(T) : 65362；</p>

<p>□下(i) : 65364；</p>

<p>□左(一)：65361；</p>

<p>□右65363；</p>

<p>□删除(Delete) : 65535。</p>

<p>需要注意的是，在不同的操作系统里这些值可能是不一样的。鼠标事件比键盘事件稍 微复杂一点，需要定义一个回调函数，然后把回调函数和一个指定名称的窗口绑定，这样 只要鼠标位于画面区域内的事件就都能捕捉到。把下面这段代码插入到上段代码的while 之前，就能获取当前鼠标的位置和动作并输出。</p>

<p>#定义鼠标事件回调函数</p>

<p>def on一mouse(event, x, y, flags, param):</p>

<p>#鼠标左键按下，抬起，双击</p>

<p>if event == cv2.EVENT_LBUTTONDOWN:</p>

<p>print(* Left button down at ({},    {})’.format(x, y))</p>

<p>elif event == cv2.EVENT_LBUTTONUP:</p>

<p>print(* Left button up at ({},    {})’.format(x, y))</p>

<p>elif event == cv2.EVENT_LBUTTONDBLCLK:</p>

<p>print (&rsquo; Left button double clicked at ⑴，    { }) * .</p>

<p>format(x, y))</p>

<p>#鼠标右键按下，抬起，双击</p>

<p>elif event</p>

<p>cv2.EVENT RBUTTONDOWN:</p>

<p>print(* Right button down at ({},    { }) *.format(x, y))</p>

<p>elif event</p>

<p>cv2.EVENT RBUTTONUP:</p>

<p>{})，.format(x, y))</p>

<p>elif</p>

<p>print(* Right button up at ({}, event == cv2.EVENT RBUTTONDBLCLK:</p>

<p>print(&lsquo;Right button double clicked at ({},    {})</p>

<p>format(x, y))</p>

<p>#鼠标中/滚轮键(如果有的话)按下，抬起，双击</p>

<p>elif event == cv2.EVENT_MBUTTONDOWN:</p>

<p>print(&lsquo;Middle button down at ({},    {})*.format(x, y))</p>

<p>elif event == cv2.EVENT_MBUTTONUP:</p>

<p>print(&lsquo;Middle button up at ({},    {}) &lsquo;.format(x, y))</p>

<p>elif event == cv2.EVENT_MBUTTONDBLCLK:</p>

<p>print(&lsquo;Middle button double clicked at ({},    {})’.</p>

<p>format(x, y))</p>

<p>#鼠标移动</p>

<p>elif event == cv2.EVENT_MOUSEMOVE:</p>

<p>print (&lsquo;Moving at ({},    ⑴，• format (x, y))</p>

<p>#为指定的窗口绑定自定义的回调函数</p>

<p>cv2.namedWindow(* Honeymoon 工sland&rsquo;)</p>

<p>cv2.setMouseCallback(&lsquo;Honeymoon Island1, on_mouse)</p>

<p>6.4.3代码：物体检测标注的小工具</p>

<p>基于6.4.1和6.4.2两小节的基本使用，就能和OpenCV的基本绘图功能实现一个超级 简单的物体框标注小工具了。基本思路是对要标注的图像建立一个窗口循环，然后每次循 环的时候对图像进行一次复制。鼠标在画面上画框的操作，以及已经画好的框的相关信息 在全局变量中保存，并且在每个循环中根据这些信息，在复制的图像上再画一遍，然后显 示这份复制的图像。</p>

<p>基于这种实现思路，使用上采用一个尽量简化的设计如下。</p>

<p>□输入是一个文件夹的路径，下面包含了所有要标注物体框的图片。如果图片中标 注了物体，则生成一个相同名称加额外后缀名的文件保存标注信息。</p>

<p>□标注的方式是按下鼠标左键选择物体框的左上角，松开鼠标左键选择物体框的右 下角，按下鼠标右键删除上一个标注好的物体框。所有待标注物体的类别和标注 框颜色由用户自定义，如果没有定义则默认只标注一种物体，定义该物体名称为 Object。</p>

<p>□方向键一和一键用来遍历图片，t和I键用来选择当前要标注的物体，Delete键删 除一张图片和对应的标注信息。</p>

<p>每张图片的标注信息，以及自定义标注物体和颜色的信息用一个元组表示，第一个元 素是物体名字，第二个元素是代表BGR颜色的tuple或者代表标注框坐标的元组。对于这 种并不复杂的数据结构，直接利用Python的reprO函数，把数据结构保存成机器可读的字 符串放到文件里，读取的时候用eval()函数就能直接获得数据。这样的方便之处在于不需 要单独写格式解析器。如果需要，可以在此基础上再编写一个转换工具，这样就能够转换 成常见的Pascal VOC的标注格式或其他的自定义格式。</p>

<p>在这些思路和设计下，定义标注信息文件格式的例子如下：</p>

<p>(&lsquo;Hili&rsquo;f ((221,    163),    (741,    291)))</p>

<p>(’Horse&rsquo;, ((465,    430),    (613,    570)))</p>

<p>元组中第一项是物体名称，第二项是标注框左上角和右下角的坐标。这里之所以不把 标注信息的数据直接用pickle保存，是因为数据本身不会很复杂，直接保存还有更好的可 读性。自定义标注物体和对应标注框颜色的格式也类似，不过更简单些，因为括号可以不 写，具体如下：</p>

<p>第一项是物体名称，第二项是物体框的颜色。使用的时候把自己定义好的内容放到一 个文本里，然后保存成和待标注文件夹同名，后缀名为labels的文件。比如在一个samples 的文件夹下放上一些草原的照片，然后自定义一个和文件夹同名的samples.labels的文本文</p>

<p>件。把上段代码的内容放进去，就定义了小山头的框为黄色，骏马的框为青色，以及红色</p>

<p>的男青年。具体的标注小工具的代码如下：</p>

<p>import os import cv2</p>

<p># tkinter是Python内置的简单GUI库，实现一些比如打开文件夹、确认删除等操作十分方便 from tkFileDialog import askdirectory from tkMessageBox import askyesno #定义标注窗口的默认名称</p>

<p>WINDOW_NAME =    * Simple Bounding Box Labeling Tool *</p>

<p>#定义面刷新的大概帧率(是否能达到取决于计算机性能)</p>

<p>get_bbox_name =    *{}.bbox *.format</p>

<p>#是义物译框标注工具类</p>

<p>class SimpleBBoxLabeling:</p>

<p>def  init_(self, data_dir, fps=FPS, window_name=None):</p>

<table>
<thead>
<tr>
<th>self. data dir = data dir self.fps = fps</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>

<tbody>
<tr>
<td>self.window name</td>
<td>= window name</td>
<td>if</td>
<td>window name</td>
<td>else</td>
</tr>
</tbody>
</table>

<p>WINDOW_NAME</p>

<p>#pt0是正在画的左上角坐标，ptl是鼠标所在坐标</p>

<p>self ,_ptO = None</p>

<p>self.一ptl = None</p>

<p>#表弭当前是否正在画框的状态标记</p>

<p>self._drawing = False</p>

<p>#当俞标注物体的名称</p>

<p>self._cur_label = None</p>

<p>#当i图像 1 寸应的所有已标注框</p>

<p>self._bboxes =    []</p>

<p>#如＜有用户自定义的标注信息则读取，否则用默认的物体和颜色</p>

<p>label_path =    *{}.labels *.format(self._data_dir)</p>

<p>self.label一colors = DEFAULT_COLOR if not os.path.exists</p>

<p>(label_path) else self.load_labels(label_path)</p>

<p>#获取已经标注的f件列表和还未标S的文件列表</p>

<table>
<thead>
<tr>
<th></th>
<th>imagefiles</th>
<th>=[X</th>
<th>for</th>
<th>X</th>
<th>in os.listdir(self. data dir)</th>
</tr>
</thead>

<tbody>
<tr>
<td>if x</td>
<td>[x.rfind(&lsquo;.1)    +    1:]</td>
<td>.lower()</td>
<td>in</td>
<td>SUPPOTED FORMATS]</td>
<td></td>
</tr>

<tr>
<td></td>
<td>labeled =</td>
<td>[x for</td>
<td>X</td>
<td>in</td>
<td>imagefiles if os.path.exists</td>
</tr>

<tr>
<td>(get一</td>
<td>bbox_name(x))]to be labeled = [x</td>
<td>for</td>
<td>X</td>
<td>in imagef iles if x not in</td>
<td></td>
</tr>
</tbody>
</table>

<p>labeled]</p>

<p>#每次打开一个文件夹，都自动从还未标注的第一张开始 self._filelist = labeled + to_be_labeled self.—index = len(labeled)</p>

<p>if self._index &gt; len(self._filelist) -    1:</p>

<p>self._index = len(self._filelist) -    1</p>

<p>#鼠标回调函数</p>

<p>def _mouse_ops(self, event, x, y, flags, param):</p>

<p>#按下左键时，坐标为左上角，同时表明开始画框，改变drawing标记为True if event == cv2.EVENT_LBUTTONDOWN:</p>

<p>self.—drawing = True self._ptO =    (x, y)</p>

<p>#松开左键，秦明当前框画完了，坐标记为右下角并保存，同时改变drawing</p>

<p>标记为False</p>

<p>elif event == cv2.EVENT LBUTTONUP:</p>

<p>self.—drawing = False self._ptl =    (x, y)</p>

<p>self._bboxes.append((self._cur_label, (self,_ptOz</p>

<p>self._ptl)))</p>

<p>#实时更新右下角坐标方便画框</p>

<p>elif event == cv2.EVENT MOUSEMOVE:</p>

<p>self,_ptl =    (x, y)</p>

<p>#按下鼠标右逼删除最近画好的框</p>

<p>elif event == cv2.EVENT_RBUTTONUP:</p>

<p>if self. bboxes:</p>

<p>self._bboxes.pop()</p>

<p>#清除所有标注框和当前状态</p>

<p>def _clean_bbox(self):</p>

<p>self ._ptO = None self ._ptl = None self._drawing = False self.—bboxes =    []</p>

<p>#画時注框和当前信息的函数</p>

<p>def _draw_bbox(self, img):</p>

<p>#吞图像下方多出BAR_HEIGHT这么多像素的区域，用于显示文件名和当前标</p>

<p>注物体等信息</p>

<p>h, w = img.shape[:2]</p>

<p>canvas = cv2.copyMakeBorder(img, 0, BAR—HEIGHT, 0,    0,</p>

<p>cv2.BORDER一CONSTANT, value=COLOR_GRAY)</p>

<p>#正在标注的物体信息，i卩果鼠标左键已经按下，则显示两个点坐标，否则显示 当前待标注物体的名称</p>

<p>label_msg =    *{} :    {},    {}&lsquo;.format(self._cur_label, self</p>

<p>ptO, self._ptl) </p>

<p>if self.—drawing </p>

<p>else * Current label:    {}*.format(self._cur_label)</p>

<p>#显示当前文件名，文件个数信息</p>

<p>msg =    *{}/{}:    {} I {}&lsquo;.format(self._index +    1, len</p>

<p>(self._filelist), self._filelist[self,_index], label_msg)</p>

<p>cv2.putText(canvasf msg, (1,    h+12),</p>

<p>cv2.FONT_HERS HEY_SIMPLEX z 0.5,    (0,— 0,    0)7 1)</p>

<p>#画出已经标好的框和对应名字</p>

<p>for label, (bptO, bptl) in self.—bboxes:</p>

<p>label—color = self.label_colors[label] if label</p>

<p>in self.label colors else COLOR GRAY</p>

<p>cv2.rectangle(canvas, bptO, bptl, label_color,</p>

<p>thickness=2)</p>

<p>cv2.putText(canvas, label, (bptO[0]+3, bptO[1]+15), cv2.FONT_HERSHEY_SIMPLEX,</p>

<p>0.5, label—color, 2)</p>

<p>#画正在标注的框和对应名字</p>

<p>if self,_drawing:</p>

<p>label_color = self.label_colors[self._cur_label] if self._cur_label in self.label—colors else COLOR_GRAY</p>

<p>if self._ptl[0]    &gt;= self._ptO[0] and self._ptl[1]</p>

<p>&gt;=self,_ptO[1]:</p>

<p>cv2.rectangle(canvas, self._ptO, self._ptl,</p>

<p>label_color, thickness=2)</p>

<p>cv2.putText(canvas, self,_cur_label, (self,_ptO[0] +    3, self._pt0[1]    +    15),</p>

<p>cv2.FONT_HERSHEY_SIMPLEX z 0.5, label_color, 2)</p>

<p>return canvas</p>

<p>#利用repr ()函数导出标注框数据到文件 @staticmethod</p>

<p>def export_bbox(filepath, bboxes): if bboxes:</p>

<p>with open (filepath, * w *) as f: for bbox in bboxes:</p>

<p>line = repr(bbox) +    &lsquo;\n *</p>

<p>f.write(line)</p>

<p>elif os.path.exists(filepath): os.remove(filepath)</p>

<p>#利用eval()函数读取标注框字符串到数据 @staticmethod</p>

<p>def load_bbox(filepath):    ,</p>

<p>bboxes =    []</p>

<p>with open (filepath, * r *) as f:</p>

<p>line = f.readline().rstrip() while line:</p>

<p>bboxes.append(eval(line)) line = f.readline() .rstrip ()</p>

<p>return bboxes</p>

<p>#利用eval()函数读取物体及对应颜色信息到数据 Qstaticmethod</p>

<p>def load_labels(filepath): label_colors =    {}</p>

<p>with open (filepath, * r *) as f:</p>

<p>line = f.readline().rstrip() while line:</p>

<p>label, color = eval(line) label_colors[label] = color line = f.readline() .rstrip ()</p>

<p>return label—colors</p>

<p>#读取图像文件和对应标运框信息(如果有的话)</p>

<p>@staticmethod</p>

<p>def load_sample(filepath):</p>

<p>img = cv2.imread(filepath)</p>

<p>bbox_filepath = get_bbox_name(filepath)</p>

<p>bboxes =    []</p>

<p>if os.path.exists(bbox_filepath):</p>

<p>bboxes = SimpleBBoxLabeling.load_bbox(bbox_filepath)</p>

<p>return img, bboxes</p>

<p>#导出当前标注框信息并清空</p>

<p>def _export_n_clean_bbox(self):</p>

<p>bbox_filepath = os.sep.join([self._data_dir, get<em>bbox</em> name(self._filelist[self._index])])</p>

<p>self.export_bbox(bbox_filepath, self._bboxes) self._clean_bbox()</p>

<p>#删除当前样i和对应丑标注框信息</p>

<p>def _delete_current_sample(self):</p>

<p>filename = self._f ilelist[self,_index] filepath = os.sep.join([self._data_dir, filename]) if os.path.exists(filepath):</p>

<p>os.remove(filepath) filepath = get_bbox_name(filepath) if os.path.exists(filepath):</p>

<p>os.remove(filepath) self._filelist.pop(self._index) print(*{} is deleted!1.format(filename))</p>

<p>#开始OpenCV窗口循环的方法，定义了程序的主逻辑</p>

<p>def start(self):</p>

<p>#之前标注的文件名，用于程序判断是否需要执行一次图像读取</p>

<p>last_filename =    &ldquo;</p>

<p>#标注物体在列表中的下标</p>

<p>label_index =    0</p>

<p>#所有标注物体名称的列表</p>

<p>labels = self.label_colors.keys()</p>

<p>#待标注物体的种类数</p>

<p>n_labels = len(labels)</p>

<p>定义窗口和鼠标回调</p>

<p>cv2.namedWindow(self.window_name)</p>

<p>cv2.setMouseCallback(self.window_name, self,_mouse_ops) key = KEY_EMPTY #定义每次环的持续时间 delay = int (1000    / FPS)</p>

<p>#只要没有按下Esc键，就持续循环 while key ! = KEY_ESC:</p>

<p>#上下方向键角于选择当前标注物体 if key == KEY_UP:</p>

<p>#删除当前图片和对应忌注信息</p>

<p>elif key == KEY_DELETE:</p>

<p>if askyesno(丨Delete Sample *, &lsquo;Are you sure? *): self._delete_current_sample() key : KEY_EMPTY</p>

<p>continue</p>

<p>#如果键盘操作执行了换图片，则重新读取，更新图片</p>

<p>filename = self.—filelist[self.—index]</p>

<p>if filename ! = last_filename:</p>

<p>filepath = os.sep.join([self._data_dir,</p>

<p>filename])</p>

<p>img, self,_bboxes = self.load_sainple(filepath)</p>

<p>#更新当前标注物体羞称</p>

<p>self,_cur_label = labels[label_index]</p>

<p>#把禄注和关信息画在图片上并显示指i的时间</p>

<p>canvas = self._draw_bbox(img)</p>

<p>cv2.imshow(self•window_name, canvas)</p>

<p>key = cv2.waitKey(delay)</p>

<p>#当前文件名就是下次循环的老文件名</p>

<p>last filename = filename</p>

<p>print(* Finished!&lsquo;) cv2.destroyAllWindows()</p>

<p>#如果退出程序，需要对当前文件进行保存</p>

<p>self.export_bbox(os.sep.join([self._data_dir,</p>

<p>g e t_bb o x_n ame(filename)]), self._bboxes) print(&lsquo;Labels updated!&rsquo;)</p>

<p>if <em>name</em> ==    1<em>main</em>* :</p>

<p>dir_with_images = askdirectory(title=&lsquo;Where are y the images? *) labeling_task = SimpleBBoxLabeling(dir_with_images) labeling_task.start()</p>

<p>需要注意的是，程序中几个比较通用且独立的方法前加上了一句@staticmethod,表明 是个静态方法。执行程序并选择samples文件夹，就可以在文件夹下生成和图片同名、后 缀为bbox的标注信息文件了。标注时的画面如图6-9所示。</p>

<p>图6-9标注小工具使用界面</p>

    </div>

    
    

    
    

    <footer class="post-footer">
      

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/02-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/03-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/12-%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89cv/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%9F%BA%E7%A1%80/02-%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7/01-opencv/01-opencv-%E4%BB%8B%E7%BB%8D/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">01 OpenCV 介绍</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/02-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/03-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/12-%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89cv/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/05-python-%E5%9F%BA%E7%A1%80/01-python-%E7%AE%80%E4%BB%8B/">
            <span class="next-text nav-default">01 Python 简介</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="iteratelyd@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="http://github.com/iterateself" class="iconfont icon-github" title="github"></a>
      <a href="https://www.zhihu.com/people/thebegin/activities" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="https://www.douban.com/people/68028070/" class="iconfont icon-douban" title="douban"></a>
  <a href="http://iterate.site/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> site pv: <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
    <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> site uv: <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2018
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">iterateself</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>


<script type="text/javascript" src="/dist/even.min.js?v=3.2.0"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>








</body>
</html>
