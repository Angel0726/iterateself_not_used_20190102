<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>06 进行预测 - 迭代自己</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="iterateself" />
  <meta name="description" content="进行预测 第6篇，检测图片中的物体，使用训练完成的模型，通过框置信度与类别置信度的乘积，筛选最优的检测框。 1. 检测函数 使用已经训练完成的 YOLO v3 模型" />

  <meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.47.1" />


<link rel="canonical" href="http://iterate.site/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/02-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/03-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/11-%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-cv/11-%E6%91%84%E5%83%8F%E5%A4%B4%E6%8B%8D%E6%91%84%E7%9A%84%E4%B8%80%E5%BC%A0%E9%9D%99%E6%80%81%E5%9B%BE%E7%89%87/02-%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/02-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%97%B6%E4%BB%A3%E7%9A%84%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/03-one-stage-%E7%9A%84%E6%96%B9%E6%B3%95/yolov3/02-yolov3-%E4%BD%BF%E7%94%A8/01-keras-%E5%AE%9E%E7%8E%B0/06-%E8%BF%9B%E8%A1%8C%E9%A2%84%E6%B5%8B/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">




<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<link href="/dist/even.min.css?v=3.2.0" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">




<meta property="og:title" content="06 进行预测" />
<meta property="og:description" content="进行预测 第6篇，检测图片中的物体，使用训练完成的模型，通过框置信度与类别置信度的乘积，筛选最优的检测框。 1. 检测函数 使用已经训练完成的 YOLO v3 模型" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://iterate.site/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/02-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/03-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/11-%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-cv/11-%E6%91%84%E5%83%8F%E5%A4%B4%E6%8B%8D%E6%91%84%E7%9A%84%E4%B8%80%E5%BC%A0%E9%9D%99%E6%80%81%E5%9B%BE%E7%89%87/02-%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/02-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%97%B6%E4%BB%A3%E7%9A%84%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/03-one-stage-%E7%9A%84%E6%96%B9%E6%B3%95/yolov3/02-yolov3-%E4%BD%BF%E7%94%A8/01-keras-%E5%AE%9E%E7%8E%B0/06-%E8%BF%9B%E8%A1%8C%E9%A2%84%E6%B5%8B/" /><meta property="article:published_time" content="2018-09-25T00:00:00&#43;00:00"/>
<meta property="article:modified_time" content="2018-09-25T00:00:00&#43;00:00"/>
<meta itemprop="name" content="06 进行预测">
<meta itemprop="description" content="进行预测 第6篇，检测图片中的物体，使用训练完成的模型，通过框置信度与类别置信度的乘积，筛选最优的检测框。 1. 检测函数 使用已经训练完成的 YOLO v3 模型">


<meta itemprop="datePublished" content="2018-09-25T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2018-09-25T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="3776">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="06 进行预测"/>
<meta name="twitter:description" content="进行预测 第6篇，检测图片中的物体，使用训练完成的模型，通过框置信度与类别置信度的乘积，筛选最优的检测框。 1. 检测函数 使用已经训练完成的 YOLO v3 模型"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">迭代自己</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">最新</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a><a href="/catalog/">
        <li class="mobile-menu-item">完整目录</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">迭代自己</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">最新</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/catalog/">完整目录</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">06 进行预测</h1>

      <div class="post-meta">
        <span class="post-time"> 2018-09-25 </span>
        
        <span class="more-meta"> 3776 words </span>
        <span class="more-meta"> 8 mins read </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> times read </span>
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  
  <div class="post-toc-content">
    <nav id="TableOfContents">
<ul>
<li><a href="#进行预测">进行预测</a>
<ul>
<li><a href="#1-检测函数"><strong>1. 检测函数</strong></a></li>
<li><a href="#2-yolo参数">2. YOLO参数</a></li>
<li><a href="#3-输出封装">3. 输出封装</a></li>
<li><a href="#4-yolo评估">4. YOLO评估</a></li>
<li><a href="#5-检测方法">5. 检测方法</a></li>
<li><a href="#补充">补充</a></li>
<li><a href="#1-concatenate">1. concatenate</a></li>
<li><a href="#2-gather">2. gather</a></li>
</ul></li>
<li><a href="#相关资料">相关资料</a></li>
</ul>
</nav>
  </div>
</div>

    
    

    
    <div class="post-content">
      

<h1 id="进行预测">进行预测</h1>

<p>第6篇，检测图片中的物体，使用训练完成的模型，通过框置信度与类别置信度的乘积，筛选最优的检测框。</p>

<h2 id="1-检测函数"><strong>1. 检测函数</strong></h2>

<p>使用已经训练完成的 YOLO v3 模型，检测图片中的物体，其中：</p>

<ul>
<li>创建YOLO类的实例yolo；</li>
<li>使用Image.open()加载图像image；</li>
<li>调用yolo.detect_image()检测图像image；</li>
<li>关闭yolo的session；</li>
<li>显示检测完成的图像r_image；</li>
</ul>

<p>实现：</p>

<pre><code>def detect_img_for_test():
    yolo = YOLO()
    img_path = './dataset/img.jpg'
    image = Image.open(img_path)
    r_image = yolo.detect_image(image)
    yolo.close_session()
    r_image.show()
</code></pre>

<p>输出：</p>

<p><img src="http://pacdb2bfr.bkt.clouddn.com/blog/image/180925/fCBg8L370b.png?imageslim" alt="mark" /></p>

<h2 id="2-yolo参数">2. YOLO参数</h2>

<p>YOLO类的初始化参数：</p>

<ul>
<li>anchors_path：anchor box的配置文件，9个宽高组合；</li>
<li>model_path：已训练完成的模型，支持重新训练的模型；</li>
<li>classes_path：类别文件，与模型文件匹配；</li>
<li>score：置信度的阈值，删除小于阈值的候选框；</li>
<li>iou：候选框的IoU阈值，删除同类别中大于阈值的候选框；</li>
<li>class_names：类别列表，读取classes_path；</li>
<li>anchors：anchor box列表，读取anchors_path；</li>
<li>model_image_size：模型所检测图像的尺寸，输入图像都需要按此填充；</li>
<li>colors：通过HSV色域，生成随机颜色集合，数量等于类别数class_names；</li>
<li>boxes、scores、classes：检测的核心输出，函数generate()所生成，是模型的输出封装。</li>
</ul>

<p>实现：</p>

<pre><code class="language-python">self.anchors_path = 'configs/yolo_anchors.txt'  # Anchors
self.model_path = 'model_data/yolo_weights.h5'  # 模型文件
self.classes_path = 'configs/coco_classes.txt'  # 类别文件

self.score = 0.20
self.iou = 0.20
self.class_names = self._get_class()  # 获取类别
self.anchors = self._get_anchors()  # 获取anchor
self.sess = K.get_session()
self.model_image_size = (416, 416)  # fixed size or (None, None), hw
self.colors = self.__get_colors(self.class_names)
self.boxes, self.scores, self.classes = self.generate()
</code></pre>

<p>在中：</p>

<ul>
<li>将HSV的第0位H值，按1等分，其余SV值，均为1，生成一组HSV列表；</li>
<li>调用hsv_to_rgb，将HSV色域转换为RGB色域；</li>
<li>0~1的RGB值乘以255，转换为完整的颜色值，(0~255)；</li>
<li>随机shuffle颜色列表；</li>
</ul>

<p>实现：</p>

<pre><code class="language-python">@staticmethod
def __get_colors(names):
    # 不同的框，不同的颜色
    hsv_tuples = [(float(x) / len(names), 1., 1.)
                  for x in range(len(names))]  # 不同颜色
    colors = list(map(lambda x: colorsys.hsv_to_rgb(*x), hsv_tuples))
    colors = list(map(lambda x: (int(x[0] * 255), int(x[1] * 255), int(x[2] * 255)), colors))  # RGB
    np.random.seed(10101)
    np.random.shuffle(colors)
    np.random.seed(None)

    return colors
</code></pre>

<blockquote>
<p>选择 HSV 划分，而不是 RGB 的原因是，HSV 的颜色值偏移更好，画出的框，颜色更容易区分。</p>
</blockquote>

<hr />

<h2 id="3-输出封装">3. 输出封装</h2>

<p>boxes、scores、classes是在模型的基础上，继续封装，由函数generate()所生成，其中：</p>

<ul>
<li>boxes：框的四个点坐标，(top, left, bottom, right)；</li>
<li>scores：框的类别置信度，融合框置信度和类别置信度；</li>
<li>classes：框的类别；</li>
</ul>

<p>在函数generate()中，设置参数：</p>

<ul>
<li>num_anchors：anchor box的总数，一般是9个；</li>
<li>num_classes：类别总数，如COCO是80个类；</li>
<li>yolo_model：由yolo_body所创建的模型，调用load_weights加载参数；</li>
</ul>

<p>实现：</p>

<pre><code class="language-python">num_anchors = len(self.anchors)  # anchors的数量
num_classes = len(self.class_names)  # 类别数

self.yolo_model = yolo_body(Input(shape=(416, 416, 3)), 3, num_classes)
self.yolo_model.load_weights(model_path)  # 加载模型参数
</code></pre>

<p>接着，设置input_image_shape为placeholder，即TF中的参数变量。在yolo_eval中：</p>

<ul>
<li>继续封装yolo_model的输出output；</li>
<li>anchors，anchor box列表；</li>
<li>类别class_names的总数len()；</li>
<li>输入图片的可选尺寸，input_image_shape，即(416, 416)；</li>
<li>score_threshold，框的整体置信度阈值score；</li>
<li>iou_threshold，同类别框的IoU阈值iou；</li>
<li>返回，框的坐标boxes，框的类别置信度scores，框的类别classes；</li>
</ul>

<p>实现：</p>

<pre><code class="language-python">self.input_image_shape = K.placeholder(shape=(2,))
boxes, scores, classes = yolo_eval(
    self.yolo_model.output, self.anchors, len(self.class_names),
    self.input_image_shape, score_threshold=self.score, iou_threshold=self.iou)
return boxes, scores, classes
</code></pre>

<blockquote>
<p>输出的scores值，都会大于score_threshold，小于的在yolo_eval()中已被删除。</p>
</blockquote>

<hr />

<h2 id="4-yolo评估">4. YOLO评估</h2>

<p>在函数yolo_eval()中，完成预测逻辑的封装，其中输入：</p>

<ul>
<li>yolo_outputs：YOLO模型的输出，3个尺度的列表，即13-26-52，最后1维是预测值，由255=3x(5+80)组成，3是每层的anchor数，5是4个框值xywh和1个框中含有物体的置信度，80是COCO的类别数；</li>
<li>anchors：9个anchor box的值；</li>
<li>num_classes：类别个数，COCO是80个类别；</li>
<li>image_shape：placeholder类型的TF参数，默认(416, 416)；</li>
<li>max_boxes：图中最大的检测框数，20个；</li>
<li>score_threshold：框置信度阈值，小于阈值的框被删除，需要的框较多，则调低阈值，需要的框较少，则调高阈值；</li>
<li>iou_threshold：同类别框的IoU阈值，大于阈值的重叠框被删除，重叠物体较多，则调高阈值，重叠物体较少，则调低阈值；</li>
</ul>

<p>其中，yolo_outputs格式，如下：</p>

<pre><code>[(?, 13, 13, 255), (?, 26, 26, 255), (?, 52, 52, 255)]
</code></pre>

<p>其中，anchors列表，如下：</p>

<pre><code>[(10,13), (16,30), (33,23), (30,61), (62,45), (59,119), (116,90), (156,198), (373,326)]
</code></pre>

<p>实现：</p>

<pre><code class="language-python">boxes, scores, classes = yolo_eval(
    self.yolo_model.output, self.anchors, len(self.class_names),
    self.input_image_shape, score_threshold=self.score, iou_threshold=self.iou)

def yolo_eval(yolo_outputs, anchors, num_classes, image_shape,
              max_boxes=20, score_threshold=.6, iou_threshold=.5):
</code></pre>

<p>接着，处理参数：</p>

<ul>
<li>num_layers，输出特征图的层数，3层；</li>
<li>anchor_mask，将anchors划分为3个层，第1层13x13是678，第2层26x26是345，第3层52x52是012；</li>
<li>input_shape：输入图像的尺寸，也就是第0个特征图的尺寸乘以32，即13x32=416，这与Darknet的网络结构有关。</li>
</ul>

<pre><code class="language-python">num_layers = len(yolo_outputs)
anchor_mask = [[6, 7, 8], [3, 4, 5], [0, 1, 2]] if num_layers == 3 else [[3, 4, 5], [1, 2, 3]]  # default setting
input_shape = K.shape(yolo_outputs[0])[1:3] * 32
</code></pre>

<blockquote>
<p>特征图越大，13-&gt;52，检测的物体越小，需要的anchors越小，所以anchors列表以倒序赋值。</p>
</blockquote>

<p>接着，在YOLO的第l层输出yolo_outputs中，调用yolo_boxes_and_scores()，提取框_boxes和置信度_box_scores，将3个层的框数据放入列表boxes和box_scores，再拼接concatenate展平，输出的数据就是所有的框和置信度。</p>

<p>其中，输出的boxes和box_scores的格式，如下：</p>

<pre><code>boxes: (?, 4)  # ?是框数
box_scores: (?, 80)
</code></pre>

<p>实现：</p>

<pre><code class="language-python">boxes = []
box_scores = []
for l in range(num_layers):
    _boxes, _box_scores = yolo_boxes_and_scores(
        yolo_outputs[l], anchors[anchor_mask[l]], num_classes, input_shape, image_shape)
    boxes.append(_boxes)
    box_scores.append(_box_scores)
boxes = K.concatenate(boxes, axis=0)
box_scores = K.concatenate(box_scores, axis=0)
</code></pre>

<blockquote>
<p>concatenate的作用是：将多个层的数据展平，因为框已经还原为真实坐标，不同尺度没有差异。</p>
</blockquote>

<p>在函数yolo_boxes_and_scores()中：</p>

<ul>
<li>yolo_head的输出：box_xy是box的中心坐标，(0~1)相对位置；box_wh是box的宽高，(0~1)相对值；box_confidence是框中物体置信度；box_class_probs是类别置信度；</li>
<li>yolo_correct_boxes，将box_xy和box_wh的(0~1)相对值，转换为真实坐标，输出boxes是(y_min,x_min,y_max,x_max)的值；</li>
<li>reshape，将不同网格的值展平为框的列表，即(?,13,13,3,4)-&gt;(?,4)；</li>
<li>box_scores是框置信度与类别置信度的乘积，再reshape展平，(?,80)；</li>
<li>返回框boxes和框置信度box_scores。</li>
</ul>

<p>实现：</p>

<pre><code class="language-python">def yolo_boxes_and_scores(feats, anchors, num_classes, input_shape, image_shape):
    '''Process Conv layer output'''
    box_xy, box_wh, box_confidence, box_class_probs = yolo_head(
        feats, anchors, num_classes, input_shape)
    boxes = yolo_correct_boxes(box_xy, box_wh, input_shape, image_shape)
    boxes = K.reshape(boxes, [-1, 4])
    box_scores = box_confidence * box_class_probs
    box_scores = K.reshape(box_scores, [-1, num_classes])
    return boxes, box_scores
</code></pre>

<p>接着：</p>

<ul>
<li>mask，过滤小于置信度阈值的框，只保留大于置信度的框，mask掩码；</li>
<li>max_boxes_tensor，每张图片的最大检测框数，max_boxes是20；</li>
</ul>

<p>实现：</p>

<pre><code class="language-python">mask = box_scores &gt;= score_threshold
max_boxes_tensor = K.constant(max_boxes, dtype='int32')
</code></pre>

<p>接着：</p>

<ul>
<li>通过掩码mask和类别c，筛选框class_boxes和置信度class_box_scores；</li>
<li>通过NMS，非极大值抑制，筛选出框boxes的NMS索引nms_index；</li>
<li>根据索引，选择gather输出的框class_boxes和置信class_box_scores度，再生成类别信息classes；</li>
<li>将多个类别的数据组合，生成最终的检测数据框，并返回。</li>
</ul>

<p>实现：</p>

<pre><code class="language-python">boxes_ = []
scores_ = []
classes_ = []
for c in range(num_classes):
    class_boxes = tf.boolean_mask(boxes, mask[:, c])
    class_box_scores = tf.boolean_mask(box_scores[:, c], mask[:, c])
    nms_index = tf.image.non_max_suppression(
        class_boxes, class_box_scores, max_boxes_tensor, iou_threshold=iou_threshold)
    class_boxes = K.gather(class_boxes, nms_index)
    class_box_scores = K.gather(class_box_scores, nms_index)
    classes = K.ones_like(class_box_scores, 'int32') * c
    boxes_.append(class_boxes)
    scores_.append(class_box_scores)
    classes_.append(classes)
boxes_ = K.concatenate(boxes_, axis=0)
scores_ = K.concatenate(scores_, axis=0)
classes_ = K.concatenate(classes_, axis=0)
</code></pre>

<p>输出格式：</p>

<pre><code>boxes_: (?, 4)
scores_: (?,)
classes_: (?,)
</code></pre>

<hr />

<h2 id="5-检测方法">5. 检测方法</h2>

<p>第1步，图像处理：</p>

<ul>
<li>将图像等比例转换为检测尺寸，检测尺寸需要是32的倍数，周围进行填充；</li>
<li>将图片增加1维，符合输入参数格式；</li>
</ul>

<pre><code class="language-python">if self.model_image_size != (None, None):  # 416x416, 416=32*13，必须为32的倍数，最小尺度是除以32
    assert self.model_image_size[0] % 32 == 0, 'Multiples of 32 required'
    assert self.model_image_size[1] % 32 == 0, 'Multiples of 32 required'
    boxed_image = letterbox_image(image, tuple(reversed(self.model_image_size)))  # 填充图像
else:
    new_image_size = (image.width - (image.width % 32), image.height - (image.height % 32))
    boxed_image = letterbox_image(image, new_image_size)
image_data = np.array(boxed_image, dtype='float32')
print('detector size {}'.format(image_data.shape))
image_data /= 255.  # 转换0~1
image_data = np.expand_dims(image_data, 0)  # 添加批次维度，将图片增加1维
</code></pre>

<p>第2步，feed数据，图像，图像尺寸；</p>

<pre><code class="language-python">out_boxes, out_scores, out_classes = self.sess.run(
    [self.boxes, self.scores, self.classes],
    feed_dict={
        self.yolo_model.input: image_data,
        self.input_image_shape: [image.size[1], image.size[0]],
        K.learning_phase(): 0
    })
</code></pre>

<p>第3步，绘制边框，自动设置边框宽度，绘制边框和类别文字，使用Pillow绘图库。</p>

<pre><code class="language-python">font = ImageFont.truetype(font='font/FiraMono-Medium.otf',
                          size=np.floor(3e-2 * image.size[1] + 0.5).astype('int32'))  # 字体
thickness = (image.size[0] + image.size[1]) // 512  # 厚度
for i, c in reversed(list(enumerate(out_classes))):
    predicted_class = self.class_names[c]  # 类别
    box = out_boxes[i]  # 框
    score = out_scores[i]  # 执行度

    label = '{} {:.2f}'.format(predicted_class, score)  # 标签
    draw = ImageDraw.Draw(image)  # 画图
    label_size = draw.textsize(label, font)  # 标签文字

    top, left, bottom, right = box
    top = max(0, np.floor(top + 0.5).astype('int32'))
    left = max(0, np.floor(left + 0.5).astype('int32'))
    bottom = min(image.size[1], np.floor(bottom + 0.5).astype('int32'))
    right = min(image.size[0], np.floor(right + 0.5).astype('int32'))
    print(label, (left, top), (right, bottom))  # 边框

    if top - label_size[1] &gt;= 0:  # 标签文字
        text_origin = np.array([left, top - label_size[1]])
    else:
        text_origin = np.array([left, top + 1])

    # My kingdom for a good redistributable image drawing library.
    for i in range(thickness):  # 画框
        draw.rectangle(
            [left + i, top + i, right - i, bottom - i],
            outline=self.colors[c])
    draw.rectangle(  # 文字背景
        [tuple(text_origin), tuple(text_origin + label_size)],
        fill=self.colors[c])
    draw.text(text_origin, label, fill=(0, 0, 0), font=font)  # 文案
    del draw
</code></pre>

<hr />

<h2 id="补充">补充</h2>

<h2 id="1-concatenate">1. concatenate</h2>

<p>concatenate将相同维度的数据元素连接到一起。</p>

<p>实现：</p>

<pre><code class="language-python">from keras import backend as K

sess = K.get_session()

a = K.constant([[2, 4], [1, 2]])
b = K.constant([[3, 2], [5, 6]])
c = [a, b]
c = K.concatenate(c, axis=0)

print(sess.run(c))
&quot;&quot;&quot;
[[2. 4.] [1. 2.] [3. 2.] [5. 6.]]
&quot;&quot;&quot;
</code></pre>

<h2 id="2-gather">2. gather</h2>

<p>gather以索引选择列表元素。</p>

<p>实现：</p>

<pre><code class="language-python">from keras import backend as K

sess = K.get_session()

a = K.constant([[2, 4], [1, 2], [5, 6]])
b = K.gather(a, [1, 2])

print(sess.run(b))
&quot;&quot;&quot;
[[1. 2.] [5. 6.]]
&quot;&quot;&quot;
</code></pre>

<h1 id="相关资料">相关资料</h1>

<ul>
<li><a href="https://mp.weixin.qq.com/s/J1ddmUvT_F2HcljLtg_uWQ">探索 YOLO v3 源码 - 完结篇 预测</a></li>
</ul>

    </div>

    
    

    
    

    <footer class="post-footer">
      

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/02-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/03-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/11-%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-cv/11-%E6%91%84%E5%83%8F%E5%A4%B4%E6%8B%8D%E6%91%84%E7%9A%84%E4%B8%80%E5%BC%A0%E9%9D%99%E6%80%81%E5%9B%BE%E7%89%87/02-%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/02-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%97%B6%E4%BB%A3%E7%9A%84%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/03-one-stage-%E7%9A%84%E6%96%B9%E6%B3%95/yolov3/01-yolov3-%E4%BB%8B%E7%BB%8D/06-%E8%BF%9B%E8%A1%8C%E9%A2%84%E6%B5%8B/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">06 进行预测</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02-python/06-python-%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/python-h5py/">
            <span class="next-text nav-default">Python h5py</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="iteratelyd@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="http://github.com/iterateself" class="iconfont icon-github" title="github"></a>
      <a href="https://www.zhihu.com/people/thebegin/activities" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="https://www.douban.com/people/68028070/" class="iconfont icon-douban" title="douban"></a>
  <a href="http://iterate.site/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> site pv: <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
    <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> site uv: <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2018
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">iterateself</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>


<script type="text/javascript" src="/dist/even.min.js?v=3.2.0"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>








</body>
</html>
