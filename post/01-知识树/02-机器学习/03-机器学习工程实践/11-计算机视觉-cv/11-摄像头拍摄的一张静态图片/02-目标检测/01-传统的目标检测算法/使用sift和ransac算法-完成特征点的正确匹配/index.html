<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>使用SIFT和RANSAC算法 完成特征点的正确匹配 - 迭代自己</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="iterateself" />
  <meta name="description" content="需要补充的 一直听到或看到 sift 算法，一直没有怎么深入理解，还是要仔细总结下的。 利用SIFT和RANSAC算法（openCV框架）实现物体的检测与" />

  <meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.47.1" />


<link rel="canonical" href="http://iterate.site/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/02-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/03-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/11-%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-cv/11-%E6%91%84%E5%83%8F%E5%A4%B4%E6%8B%8D%E6%91%84%E7%9A%84%E4%B8%80%E5%BC%A0%E9%9D%99%E6%80%81%E5%9B%BE%E7%89%87/02-%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/01-%E4%BC%A0%E7%BB%9F%E7%9A%84%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/%E4%BD%BF%E7%94%A8sift%E5%92%8Cransac%E7%AE%97%E6%B3%95-%E5%AE%8C%E6%88%90%E7%89%B9%E5%BE%81%E7%82%B9%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%8C%B9%E9%85%8D/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">




<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<link href="/dist/even.min.css?v=3.2.0" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">




<meta property="og:title" content="使用SIFT和RANSAC算法 完成特征点的正确匹配" />
<meta property="og:description" content="需要补充的 一直听到或看到 sift 算法，一直没有怎么深入理解，还是要仔细总结下的。 利用SIFT和RANSAC算法（openCV框架）实现物体的检测与" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://iterate.site/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/02-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/03-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/11-%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-cv/11-%E6%91%84%E5%83%8F%E5%A4%B4%E6%8B%8D%E6%91%84%E7%9A%84%E4%B8%80%E5%BC%A0%E9%9D%99%E6%80%81%E5%9B%BE%E7%89%87/02-%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/01-%E4%BC%A0%E7%BB%9F%E7%9A%84%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/%E4%BD%BF%E7%94%A8sift%E5%92%8Cransac%E7%AE%97%E6%B3%95-%E5%AE%8C%E6%88%90%E7%89%B9%E5%BE%81%E7%82%B9%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%8C%B9%E9%85%8D/" /><meta property="article:published_time" content="2018-10-31T00:00:00&#43;00:00"/>
<meta property="article:modified_time" content="2018-10-31T00:00:00&#43;00:00"/>
<meta itemprop="name" content="使用SIFT和RANSAC算法 完成特征点的正确匹配">
<meta itemprop="description" content="需要补充的 一直听到或看到 sift 算法，一直没有怎么深入理解，还是要仔细总结下的。 利用SIFT和RANSAC算法（openCV框架）实现物体的检测与">


<meta itemprop="datePublished" content="2018-10-31T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2018-10-31T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="2922">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="使用SIFT和RANSAC算法 完成特征点的正确匹配"/>
<meta name="twitter:description" content="需要补充的 一直听到或看到 sift 算法，一直没有怎么深入理解，还是要仔细总结下的。 利用SIFT和RANSAC算法（openCV框架）实现物体的检测与"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">迭代自己</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">最新</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a><a href="/catalog/">
        <li class="mobile-menu-item">完整目录</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">迭代自己</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">最新</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/catalog/">完整目录</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">使用SIFT和RANSAC算法 完成特征点的正确匹配</h1>

      <div class="post-meta">
        <span class="post-time"> 2018-10-31 </span>
        
        <span class="more-meta"> 2922 words </span>
        <span class="more-meta"> 6 mins read </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> times read </span>
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  
  <div class="post-toc-content">
    <nav id="TableOfContents">
<ul>
<li><a href="#需要补充的">需要补充的</a></li>
<li><a href="#利用sift和ransac算法-opencv框架-实现物体的检测与定位-并求出变换矩阵-findfundamentalmat和findhomography的比较">利用SIFT和RANSAC算法（openCV框架）实现物体的检测与定位，并求出变换矩阵（findFundamentalMat和findHomography的比较）</a></li>
<li><a href="#相关资料">相关资料</a></li>
</ul>
</nav>
  </div>
</div>

    
    

    
    <div class="post-content">
      

<h1 id="需要补充的">需要补充的</h1>

<ul>
<li>一直听到或看到 sift 算法，一直没有怎么深入理解，还是要仔细总结下的。</li>
</ul>

<h1 id="利用sift和ransac算法-opencv框架-实现物体的检测与定位-并求出变换矩阵-findfundamentalmat和findhomography的比较">利用SIFT和RANSAC算法（openCV框架）实现物体的检测与定位，并求出变换矩阵（findFundamentalMat和findHomography的比较）</h1>

<p>本文目标是通过使用SIFT和RANSAC<a href="http://lib.csdn.net/base/datastructure">算法</a>，完成特征点的正确匹配，并求出变换矩阵，通过变换矩阵计算出要识别物体的边界（文章中有部分源码，整个工程我也上传了，请点击<a href="http://download.csdn.net/detail/qq_25352981/8907557">这里</a>）。</p>

<p>SIFT算法是目前公认的效果最好的特征点检测算法，关于该算法的就不多说了，网上的资料有很多，在此提供两个链接，一个是SIFT原文的译文，一个是关于SIFT算法的详细解释：</p>

<p><a href="http://www.cnblogs.com/cuteshongshong/archive/2012/05/25/2506374.html">SIFT算法译文</a></p>

<p><a href="http://blog.csdn.net/zddblog/article/details/7521424">SIFT算法详解</a></p>

<p>整个实现过程可以复述如下：提供两张初始图片，一幅为模板图像，一幅为<a href="http://lib.csdn.net/base/softwaretest">测试</a>图片，目的就是根据模板图片中的物体，检测出测试图片中的物体，并表示出物体的具体位置和大小，测试图片中的物体位置和大小，已经事先用白色方框标记。</p>

<p>首先，对两幅图片，都使用SIFT算法提取特征点，提取结果如下：（SIFT特征提取方法就用的是上文链接“SIFT算法详解”中提供的代码）</p>

<p><img src="http://images.iterate.site/blog/image/181031/i69CAI95Ca.png?imageslim" alt="mark" /></p>

<p><img src="http://images.iterate.site/blog/image/181031/ah652fa09d.png?imageslim" alt="mark" /></p>

<p>然后对特征点进行匹配，按照SIFT算法原文作者的思路，每个特征点产生一个128维的向量，计算向量之间的欧式距离，采用最近比次近的方式完成匹配，如果最近距离比上次近距离小于0.8，则认为这是一个正确的匹配， 否则认为匹配不成功。结果这种匹配后的情况如下图：</p>

<p><img src="http://images.iterate.site/blog/image/181031/B1g23046Ge.png?imageslim" alt="mark" /></p>

<p>可以发现，仍然存在着很多错误的匹配点，所以再尝试用RANSAC算法消除错误匹配，尝试使用<a href="http://lib.csdn.net/base/opencv">OpenCV</a>中的findFundamentalMat函数消除错误匹配：</p>

<p><img src="http://images.iterate.site/blog/image/181031/KaK8BGH4k2.png?imageslim" alt="mark" /></p>

<p>通过使用findFundamentalMat函数，函数返回一个3*3的矩阵，一开始我认为这个矩阵就是变换矩阵，只要将左图中的点与这个变换矩阵相乘，就可以得到右图中的对应点。但是这其实是不对的。</p>

<p>在这里有一个误解，就是findFundamentalMat函数确实可以使用RANSAC方法消除错误匹配，从名字上可以发现，这个函数的作用是返回基础矩阵的，基础矩阵和变换矩阵是两个不同的概念。基础矩阵描述是三维场景中的像点之间的对应关系（其实到现在为止这个函数求出的基础矩阵有个毛用我也不知道）。所以说，如果使用这个函数，这个实验也就能做到这一步了，没法再往下做了。</p>

<p>所以，为了得到变换矩阵，后来我才发现openCV中还有函数findHomography，这个函数才是真正的计算变换矩阵的函数，它的函数返回值才是真正的变换矩阵。</p>

<p>其实这个问题困扰了我很久，关于消除错误匹配的方法，网上查出来的多数都是通过findFundamentalMat函数来进行，所以我就想当然的认为该函数的返回值是变换矩阵了。而网上关于findHomography的介绍比较少，所以才会让人们误解findFundamentalMat会计算出变换矩阵了。</p>

<p>尝试用findHomography函数返回的矩阵，在模板图像中，已经用绿色方框标示出物体轮廓，根据物体的四个边界点，与变换矩阵相乘，即可得到变换后的物体的轮廓的四个边界点，将此边界点连接即为物体轮廓，如下图所示（绿色方框为事先标注的模板物体中的轮廓，白色方框为事先标注的测试图片中的轮廓，红色方框为经过绿色方框经变换矩阵变换后计算出的轮廓）：</p>

<p><img src="http://images.iterate.site/blog/image/181031/f5C6jgJ1GF.png?imageslim" alt="mark" /></p>

<p>从结果可以看出，这才是比较正确的结果。</p>

<p>实验过程中的主要代码如下（这是主要的代码，SIFT算法和一些其他的功能函数我都写在了其他的文件中）：</p>

<pre><code class="language-cpp">#include&lt;math.h&gt;  
#include&lt;time.h&gt;  

#include &lt;windows.h&gt;  
#include &lt;iostream&gt;  
using namespace std;  
#include &lt;cv.h&gt;  
#include &lt;highgui.h&gt;  
#include &lt;cxcore.h&gt;  
using namespace cv;  
#include “sift.h”  
#include “my_function.h”  

int main()  
{  
    //加载两幅图片  
    Mat src1 = imread(”F:\\ylab\\image database\\camera\\obj01_001.jpg”);  
    Mat src2 = imread(”F:\\ylab\\image database\\imagesTest2\\test01_.jpg”);  

    //这四个坐标是模板图像中绿色方框的四个顶点  
    Point2f m1(173.0,0.0),m2(168.0,464.0),m3(507.0,464.0),m4(499.0,0.0);  
    std::vector&lt;Point2f&gt; obj_corners(4);  
    obj_corners[0] = cvPoint(173.0,0.0);   
    obj_corners[1] = cvPoint(168.0,464.0);  
    obj_corners[2] = cvPoint(507.0,464.0);   
    obj_corners[3] = cvPoint(499.0,0.0);  

    //原始图片比较大，我这里将图片同一处理成了640*480的大小  
    Size certainsize=Size(640,480);  
    Mat src_1;  
    Mat src_2;  
    resize(src1,src_1,certainsize);  
    resize(src2,src_2,certainsize);  

    //两个图像的特征点序列  
    Vector&lt;Keypoint&gt; feature_1,feature_2;  

    //采用sift算法，计算特征点序列，这个SIFT函数是在另外的文件中写好的  
    Sift(src_1, feature_1, 1.6);  
    Sift(src_2, feature_2, 1.6);  

    //feature_dis为带有距离的特征点结构体序列  
    Vector&lt;Key_point&gt; feature_dis_1;  
    Vector&lt;Key_point&gt; feature_dis_2;  
    Vector&lt;Key_point&gt; result;  

    //对特征点进行匹配，这个Match_feature是我自己写的，就是采用最近比次近小于0.8即为合适的匹配，这种匹配方式  
    //openCV中并没有，所以我就自己写了  
    Match_feature(feature_1,feature_2,feature_dis_1,feature_dis_2);   

    printf(”The number of features is %d\n”,feature_1.size());  
    printf(”The number of the match features is %d\n”,feature_dis_1.size());  

    //从这里开始使用RANSAC方法进行运算  
    //下面的程序都好无奈，所有的结构都只能转化成openCV的类型才能用openCV的函数。。  
    Ptr&lt;DescriptorMatcher&gt; descriptor_matcher = DescriptorMatcher::create( ”BruteForce” );//创建特征匹配器    
    int count=feature_dis_1.size();  

    //把特征点序列转化成openCV能够使用的类型  
    vector&lt;KeyPoint&gt;keypoints1,keypoints2;  
    KeyPoint keyp;  
    for(int i=0;i&lt;count;i++)  
    {  
        keyp.pt.x=feature_dis_1[i].dx;  
        keyp.pt.y=feature_dis_1[i].dy;  
        keypoints1.push_back(keyp);  
        keyp.pt.x=feature_dis_2[i].dx;  
        keyp.pt.y=feature_dis_2[i].dy;  
        keypoints2.push_back(keyp);  
    }  

    Mat descriptors1(count,FEATURE_ELEMENT_LENGTH, CV_32F);  
    Mat descriptors2(count,FEATURE_ELEMENT_LENGTH, CV_32F);  

     for (int i=0; i&lt;count; i++)  
    {  
        for(int j=0;j&lt;FEATURE_ELEMENT_LENGTH;j++)  
        {  
            descriptors1.at&lt;float&gt;(i,j)=feature_dis_1[i].descriptor[j];  
            descriptors2.at&lt;float&gt;(i,j)=feature_dis_2[i].descriptor[j];  
        }  

    }  

    Mat img_match;  
    vector&lt;DMatch&gt; matches;   
    descriptor_matcher-&gt;match( descriptors1, descriptors2, matches );   
    Mat img_matches;  
    drawMatches(src_1,keypoints1,src_2,keypoints2,matches,img_matches);  
    //其实我前面已经完成匹配了，到这里，用openCV自带的方式重新匹配了一遍，并且显示了一下  
    imshow(”SIFT”,img_matches);  
    //imwrite(“F:\\ylab\\CSDN_image\\3.jpg”,img_matches);  

    Mat p1(feature_dis_1.size(),2,CV_32F);  
    Mat p2(feature_dis_1.size(),2,CV_32F);  
    for(int i=0;i&lt;feature_dis_1.size();i++)  
    {  
        p1.at&lt;float&gt;(i,0)=feature_dis_1[i].dx;  
        p1.at&lt;float&gt;(i,1)=feature_dis_1[i].dy;  
        p2.at&lt;float&gt;(i,0)=feature_dis_2[i].dx;  
        p2.at&lt;float&gt;(i,1)=feature_dis_2[i].dy;  
    }  
    // 用RANSAC方法计算F  
    Mat m_Fundamental;  
    // 上面这个变量是基本矩阵  
    vector&lt;uchar&gt; m_RANSACStatus;  
    // 上面这个变量已经定义过，用于存储RANSAC后每个点的状态  

    //一开始使用findFundamentalMat函数，发现可以消除错误匹配，实现很好的效果，但是  
    //就是函数返回值不是变换矩阵，而是没有什么用的基础矩阵  
    m_Fundamental = findFundamentalMat(p1,p2,m_RANSACStatus,CV_FM_RANSAC);  

    //这里使用findHomography函数，这个函数的返回值才是真正的变换矩阵  
    Mat m_homography;  
    vector&lt;uchar&gt; m;  
    m_homography=findHomography(p1,p2,CV_RANSAC,3,m);                                

    //由变换矩阵，求得变换后的物体边界四个点  
    std::vector&lt;Point2f&gt; scene_corners(4);  
    perspectiveTransform( obj_corners, scene_corners, m_homography);  
    line( src_2, scene_corners[0] , scene_corners[1] , Scalar(0, 0, 255), 2 );  
    line( src_2, scene_corners[1] , scene_corners[2] , Scalar(0, 0, 255), 2 );  
    line( src_2, scene_corners[2] , scene_corners[3] , Scalar(0, 0, 255), 2 );  
    line( src_2, scene_corners[3] , scene_corners[0] , Scalar(0, 0, 255), 2 );  

    int nr=m_Fundamental.rows; // number of rows    
    int nc=m_Fundamental.cols * m_Fundamental.channels(); // total number of elements per line   

    // 计算野点个数  
    int OutlinerCount = 0;  
    for (int i=0; i&lt;Count; i++)  
    {  
         if (m_RANSACStatus[i] == 0) // 状态为0表示野点  
         {  
              OutlinerCount++;  
         }  
    }  

    // 计算内点  
     vector&lt;Point2f&gt; m_LeftInlier;  
     vector&lt;Point2f&gt; m_RightInlier;  
     vector&lt;DMatch&gt; m_InlierMatches;  
    // 上面三个变量用于保存内点和匹配关系  
    int ptCount = (int)matches.size();  
    int InlinerCount = ptCount - OutlinerCount;  
    m_InlierMatches.resize(InlinerCount);  
    m_LeftInlier.resize(InlinerCount);  
    m_RightInlier.resize(InlinerCount);  
    InlinerCount = 0;  
    for (int i=0; i&lt;ptCount; i++)  
    {  
         if (m_RANSACStatus[i] != 0)  
         {  
               m_LeftInlier[InlinerCount].x = p1.at&lt;float&gt;(i, 0);  
               m_LeftInlier[InlinerCount].y = p1.at&lt;float&gt;(i, 1);  
               m_RightInlier[InlinerCount].x = p2.at&lt;float&gt;(i, 0);  
              m_RightInlier[InlinerCount].y = p2.at&lt;float&gt;(i, 1);  
              m_InlierMatches[InlinerCount].queryIdx = InlinerCount;  
              m_InlierMatches[InlinerCount].trainIdx = InlinerCount;  
              InlinerCount++;  
           }  
    }  
    //printf(“最终的匹配点个数为：%d\n”,InlinerCount);  
    //// 把内点转换为drawMatches可以使用的格式  
    vector&lt;KeyPoint&gt; key1(InlinerCount);  
    vector&lt;KeyPoint&gt; key2(InlinerCount);  
    KeyPoint::convert(m_LeftInlier, key1);  
    KeyPoint::convert(m_RightInlier, key2);  

    // 显示计算F过后的内点匹配  
    //Mat m_matLeftImage;  
    //Mat m_matRightImage;  
    // 以上两个变量保存的是左右两幅图像  

    line(src_1,m1,m2,Scalar(0,255,0),2);  
    line(src_1,m2,m3,Scalar(0,255,0),2);  
    line(src_1,m3,m4,Scalar(0,255,0),2);  
    line(src_1,m4,m1,Scalar(0,255,0),2);  

    Mat OutImage;  
    drawMatches(src_1, key1, src_2, key2, m_InlierMatches, OutImage);     
    imshow(”SIFT_RANSAC”,OutImage);   
    //imwrite(“F:\\ylab\\CSDN_image\\5.jpg”,OutImage);  
    cvWaitKey( 0 );  
    return 0;  
}  
</code></pre>

<h1 id="相关资料">相关资料</h1>

<ul>
<li><a href="https://blog.csdn.net/qq_25352981/article/details/46914837?utm_source=blogkpcl0">利用SIFT和RANSAC算法（openCV框架）实现物体的检测与定位，并求出变换矩阵（findFundamentalMat和findHomography的比较）</a></li>
</ul>

    </div>

    
    

    
    

    <footer class="post-footer">
      

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/02-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/03-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/11-%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-cv/11-%E6%91%84%E5%83%8F%E5%A4%B4%E6%8B%8D%E6%91%84%E7%9A%84%E4%B8%80%E5%BC%A0%E9%9D%99%E6%80%81%E5%9B%BE%E7%89%87/02-%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/01-%E4%BC%A0%E7%BB%9F%E7%9A%84%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/%E4%B8%89%E7%A7%8D%E5%BC%BA%E5%A4%A7%E7%9A%84%E7%89%A9%E4%BD%93%E8%AF%86%E5%88%AB%E6%96%B9%E6%B3%95/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">三种强大的物体识别方法</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/02-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/03-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/11-%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-cv/11-%E6%91%84%E5%83%8F%E5%A4%B4%E6%8B%8D%E6%91%84%E7%9A%84%E4%B8%80%E5%BC%A0%E9%9D%99%E6%80%81%E5%9B%BE%E7%89%87/02-%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/01-%E4%BC%A0%E7%BB%9F%E7%9A%84%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/%E5%88%A9%E7%94%A8-opencv-%E7%9A%84-cascade-%E6%9D%A5%E6%A3%80%E6%B5%8B%E7%89%A9%E4%BD%93/">
            <span class="next-text nav-default">利用 opencv 的 cascade 来检测物体</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="iteratelyd@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="http://github.com/iterateself" class="iconfont icon-github" title="github"></a>
      <a href="https://www.zhihu.com/people/thebegin/activities" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="https://www.douban.com/people/68028070/" class="iconfont icon-douban" title="douban"></a>
  <a href="http://iterate.site/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> site pv: <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
    <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> site uv: <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2018
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">iterateself</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>


<script type="text/javascript" src="/dist/even.min.js?v=3.2.0"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>








</body>
</html>
