---
title: 函数的参数与返回值
toc: true
date: 2018-08-28
---







#### Q 10 :

题目：

指出下面程序哪里可能有问题？

```
class CBuffer
{
    char * m_pBuffer;
    int m_size;
public:
    CBuffer(){
        m_pBuffer = NULL;
    }
    ~CBuffer(){
        Free();
    }
    void Allocte(int size) (1) {
        m_size = size;
        m_pBuffer = new char[size];
    }
private:
    void Free(){
        if(m_pBuffer! = NULL) (2){
            delete[] m_pBuffer;
            m_pBuffer = NULL;
        }
    }
public:
    void SaveString(const char* pText) const (3){
        strcpy(m_pBuffer, pText); (4)
    }
    char* GetBuffer() const{
        return m_pBuffer;
    }
};
void main (int argc, char* argv[])
{
    CBuffer buffer1;
    buffer1.SaveString("Microsoft");
    printf(buffer1.GetBuffer());
}
```

答案:
1
3
4

解答:
考察动态分配空间等周边细节处理。
1. 分配内存时, 未检测m_pBuffer是否为空, 容易造成内存泄露。<span style="color:red;">是的，的确，在分配之前要检测是否为空</span>
2. 常成员函数不应该对数据成员做出修改, 虽然可以修改指针数据成员指向的数据, 但原则上不应该这么做。<span style="color:red;">这个地方没明白，这个地方不是只是一个 strcpy 吗？为什么说是对数据成员做出了修改？还是说 const 函数不应该修改任何变量？</span>
3*. 字符串拷贝时, 未检测是否有足够空间, 可能造成程序崩溃。<span style="color:red;">是的，拷贝之前，要确保有足够的空间</span>





#### Q 18 :

题目：
以下函数用法正确的个数是：
```
void test1(){
    unsigned char array[MAX_CHAR + 1], i;
    for(i = 0;i <= MAX_CHAR; i++){
        array[i] = i;
    }
}

char *test2(){
    char p[] = "hello world";
    return p;
}
char *p = test2();

void test3(){
    char str[10];
    str++;
    *str = '0';
}
```

答案:
0

解答:
考察数组名和指针区别。
1. i的范围有可能超过unsigned char范围。<span style="color:red;">嗯，这个是的。</span>
2. 这里char p[] = "hello world"是数组，该数组是临时变量，函数结束后不能继续使用。<span style="color:red;">数组是临时变量，函数结束后不能继续使用</span>
3. 如果为char *p = "hello world"，这里p是指针并指向常量区字串，虽然p会被销毁，但字符串仍然在，就不会出问题。<span style="color:red;">嗯，这个之前不知道。p 会被销毁，那么这个字符串还可以返回回来吗？</span>
4. 这里 str 是数组名，数组名是常量，不可以自增，正确的操作是char *p = str; p++; *p = '0'。<span style="color:red;">数组名是常量，不可以自增，这个与上面的 Q5 的问题可以放在一起看，&a表示整个数组的地址，对&a的所有操作均是以一个数组为单位的。嗯，现在才对这个稍微有些了解，以前的都忘记了。</span>
