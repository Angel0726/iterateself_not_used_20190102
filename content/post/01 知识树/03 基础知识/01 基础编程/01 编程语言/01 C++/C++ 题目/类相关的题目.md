---
title: 类相关的题目
toc: true
date: 2018-08-28
---



## 构造函数的初始化列表

#### Q 14 :<span style="color:red;">这题没看懂</span>

题目：
有哪几种情况只能用 intialization list 而不能用 assignment？

答案*:
1. 当类中含有const成员变量；<span style="color:red;">const 成员变量可以在 initialization list 里面初始化吗？</span>
2. 基类无默认构造函数时，有参的构造函数都需要初始化表；<span style="color:red;">这个时候不能用 assignment 吗？</span>
3. 当类中含有reference成员变量。<span style="color:red;">怎么会有 referenece 成员变量？</span>

解答:
1. 见答案。





## 类与结构体的大小



#### [Q 15](http://blog.csdn.net/yby4769250/article/details/7294696) :

题目：
对以下数据结构中data的处理方式描述正确的是：
```
struct Node{
    int size;
    char data[0];
};
```

答案:
编译器会认为这就是一个长度为0的数组,而且会支持对于数组data的越界访问。

解答:
考察柔性数组。
1*. 柔性数组，作为占位符放在结构体末尾，使得结构体的大小动态可变，在声明结构体变量的时候可根据需要动态分配内存。<span style="color:red;">什么意思？什么是柔性数组？怎么使得结构体的大小动态可变的？怎么根据需要动态分配内存的？有什么好处？有坏处吗？</span>
2. 长度为0的数组并不占用空间，因为数组名本身不占空间，它只是一个偏移量， 数组名这个符号本身代表了一个不可修改的地址常量。<span style="color:red;">数组名本身不占空间，只是一个偏移量是什么意思？相对于结构体的一个偏移量吗？确认下。</span>
3. 常用于网络通信中构造不定长数据包，不会浪费空间浪费网络流量。<span style="color:red;">想具体知道他在实际中是怎么应用的。</span>



#### [Q 3](http://www.cnblogs.com/motadou/archive/2009/01/17/1558438.html) :

题目：
下面两个结构体：
```
struct One{
    double d;
    char c;
    int i;
}
struct Two{
    char c;
    double d;
    int i;
}
```
在 #pragma pack(4) 和 #pragma pack(8) 的情况下，结构体的大小分别是：<span style="color:red;">这个 #pragma pack(4) 是在哪里写的？在程序中可以指定这种对其的字节数吗？一般什么时候需要指定？</span>

答案:
16，16
16，24

解答:
考察结构体对齐。
1. 4字节对齐：Struct One[8 + (1 + 3(pading)) + 4], struct Two[(1 + 3(pading)) + 8 + 4]。
2. 8字节对齐：Struct One[8 + (1 + 3(pading) + 4)], struct Two[(1 + 7(pading)) + 8 + (4 + 4(pading))]。
3. 一句话总结：按序存储，装得下尽量装，装不下换一行。



#### Q 23 :

题目：
当一个类A中没有声明任何成员变量与成员函数,这时sizeof(A)的值是多少？

答案:
1

解答:
1. 一个空类对象的大小是 1byte 。这是被编译器安插进去的一个字节，这样就使得这个空类的两个实例得以在内存中配置独一无二的地址。<span style="color:red;">之前看到过，但是不知道这个字节是被编译器安插进去的。</span>

## 继承 虚函数


#### [Q 1](http://www.cnblogs.com/skynet/p/3343726.html) :

题目：

以下代码：

```
class ClassA{
public:
    virtual ~ClassA(){};
    virtual void FunctionA(){};
};
class ClassB{
public:
    virtual void FunctionB(){};
};
class ClassC:public ClassA, public ClassB{
    public:
};
ClassC Object;
ClassA* pA = &Object;
ClassB* pB = &Object;
ClassC* pC = &Object;
```

关于pA,pB,pC的取值,下面的描述中正确的是:

答案:
pA和pB不相同

解答:
考察多继承且有虚函数情况下C++存储对象模型。
1. 多继承按继承顺序组织对象模型，有虚函数时低地址包含指向虚函数表的指针。
2. 对象Object的存储模型：类A虚函数表指针(ptrA) | 类A数据 | 类B虚函数表指针(ptrB) | 类B数据 | 类C数据。
3. 子类的虚函数被放到了第一个基类的虚函数表最后（ptrA指向的虚函数表结构：类A虚函数 | 类C虚函数）。<span style="color:red;">这个地方没懂</span>
4. 有虚函数的继承，对象地址为指向虚函数表的指针的地址，即pC = &Object = &ptrA。<span style="color:red;">都是这样的吗？</span>
6. pC = pA = &ptrA = &Object，(pC = pA) < pB。

#### [Q 2](http://www.cnblogs.com/qlwy/archive/2011/08/25/2153584.html) :

题目：

下列程序的输出结果：

```
#include <iostream>
using namespace std;
class A{
public:
    void print(){
        cout << "A:print()";
    }
};
class B:private A{
public:
    void print(){
      cout << "B:print()";
    }
};
class C:public B{
public:
   void print(){
        A::print();
    }
};
int main(){
    C b;
    b.print();
}
```

答案:
编译出错

解答:
考察C++继承问题。
1. 类B私有继承类A。
2. 私有继承：类A的公有成员和保护成员都作为类B的私有成员，并且不能被类B的子类（如类C）所访问。<span style="color:red;">嗯，知道了，那么这个会使用在什么场景下？</span>




#### Q 13 :<span style="color:red;">这题没看懂</span>

题目：
下列代码的输出为：
```
class parent{
public:
    virtual void output();
};
void parent::output(){
    printf("parent!");
}
class son : public parent{
public:
    virtual void output();
};
void son::output(){
    printf("son!");
}
son s;
memset(&s, 0, sizeof(s));
parent& p = s;
p.output();
```

<span style="color:red;">有两点不知道，一个是虚函数的继承到底是什么样的？还有一个是 memset(&s,0,sizeof(s)) 这句是什么？</span>

答案:
没有输出结果，程序运行出错。

解答:
考察 memset 和虚函数指针。
1. 虚函数表地址被清空。<span style="color:red;">什么是虚函数表地址被清空？如果没有那句 memset，那么输出的是什么？</span>




#### Q 20 :

题目：
请选择下列程序的运行结果:

```
#include<iostream>
using namespace std;
class B0{
public:
    virtual void display(){
        cout << "B0::display0" << endl;
    }
};
class B1:public B0{
public:
    void display(){
        cout << "B1::display0" << endl;
    }
};
class D1: public B1{
public:
    void display(){
        cout << "D1::display0" << endl;
    }
};
void fun(B0 ptr){
    ptr.display();
}
int main(){
    B0 b0;
    B1 b1;
    D1 d1;
    fun(b0);
    fun(b1);
    fun(d1);
}
```

答案:
B0::display0
B0::display0
B0::display0
解答:
1. 这里传递的是对象本身而非指针，对象被直接转为基类对象，调用基类的函数。<span style="color:red;">这个不知道，对象被直接转为基类对象，调用基类的函数，那么虚函数也会被调用吗？</span>
2. 如果要实现虚函数动态绑定需要将 B0 ptr 改为 B0* ptr，ptr->display()。<span style="color:red;">也就是说，如果传递进去的是指针，那么就可以动态调用不同的基类里面的函数？</span>
3. 对象的形参传递需要先使用拷贝构造函数（默认）生成 B0 类型的临时变量，只拷贝基类部分数据（只有指向基类虚函数表的虚函数指针）。<span style="color:red;">嗯，也就是说，如果传递进去的是对象本身，那么实际上是会通过默认的拷贝构造函数生成一个 B0 类型的临时变量，所以，调用的 display() 是这个 B0 类型的临时变量的函数。嗯，这个还是很好的。</span>
